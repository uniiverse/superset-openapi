/* tslint:disable */
/* eslint-disable */
/**
 * Superset
 * Superset
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { DatasetDuplicateSchema } from '../models';
import { DatasetRelatedObjectsResponse } from '../models';
import { DatasetRestApiPost } from '../models';
import { DatasetRestApiPut } from '../models';
import { DistincResponseSchema } from '../models';
import { GetDeleteIdsSchema } from '../models';
import { GetExportIdsSchema } from '../models';
import { GetInfoSchema } from '../models';
import { GetItemSchema } from '../models';
import { GetListSchema } from '../models';
import { GetOrCreateDatasetSchema } from '../models';
import { GetRelatedSchema } from '../models';
import { InlineResponse2002 } from '../models';
import { InlineResponse20032 } from '../models';
import { InlineResponse20033 } from '../models';
import { InlineResponse20034 } from '../models';
import { InlineResponse20035 } from '../models';
import { InlineResponse20110 } from '../models';
import { InlineResponse2019 } from '../models';
import { InlineResponse400 } from '../models';
import { RelatedResponseSchema } from '../models';
/**
 * DatasetsApi - axios parameter creator
 * @export
 */
export const DatasetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes multiple Datasets in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDelete: async (q?: GetDeleteIdsSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dataset/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDistinctColumnNameGet: async (columnName: string, q?: GetRelatedSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1DatasetDistinctColumnNameGet.');
            }
            const localVarPath = `/api/v1/dataset/distinct/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicates a Dataset
         * @param {DatasetDuplicateSchema} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDuplicatePost: async (body: DatasetDuplicateSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatasetDuplicatePost.');
            }
            const localVarPath = `/api/v1/dataset/duplicate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports multiple datasets and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetExportGet: async (q?: GetExportIdsSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dataset/export/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetGet: async (q?: GetListSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dataset/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a table by name, or create it if it does not exist
         * @param {GetOrCreateDatasetSchema} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetGetOrCreatePost: async (body: GetOrCreateDatasetSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatasetGetOrCreatePost.');
            }
            const localVarPath = `/api/v1/dataset/get_or_create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {boolean} syncColumns 
         * @param {boolean} syncMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetImportPostForm: async (formData: Blob, overwrite: boolean, passwords: string, syncColumns: boolean, syncMetrics: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formData' is not null or undefined
            if (formData === null || formData === undefined) {
                throw new RequiredError('formData','Required parameter formData was null or undefined when calling apiV1DatasetImportPostForm.');
            }
            // verify required parameter 'overwrite' is not null or undefined
            if (overwrite === null || overwrite === undefined) {
                throw new RequiredError('overwrite','Required parameter overwrite was null or undefined when calling apiV1DatasetImportPostForm.');
            }
            // verify required parameter 'passwords' is not null or undefined
            if (passwords === null || passwords === undefined) {
                throw new RequiredError('passwords','Required parameter passwords was null or undefined when calling apiV1DatasetImportPostForm.');
            }
            // verify required parameter 'syncColumns' is not null or undefined
            if (syncColumns === null || syncColumns === undefined) {
                throw new RequiredError('syncColumns','Required parameter syncColumns was null or undefined when calling apiV1DatasetImportPostForm.');
            }
            // verify required parameter 'syncMetrics' is not null or undefined
            if (syncMetrics === null || syncMetrics === undefined) {
                throw new RequiredError('syncMetrics','Required parameter syncMetrics was null or undefined when calling apiV1DatasetImportPostForm.');
            }
            const localVarPath = `/api/v1/dataset/import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication jwt required


            if (formData !== undefined) { 
                localVarFormParams.append('formData', formData as any);
            }

            if (overwrite !== undefined) { 
                localVarFormParams.append('overwrite', overwrite as any);
            }

            if (passwords !== undefined) { 
                localVarFormParams.append('passwords', passwords as any);
            }

            if (syncColumns !== undefined) { 
                localVarFormParams.append('sync_columns', syncColumns as any);
            }

            if (syncMetrics !== undefined) { 
                localVarFormParams.append('sync_metrics', syncMetrics as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetInfoGet: async (q?: GetInfoSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dataset/_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Dataset column
         * @param {number} pk The dataset pk for this column
         * @param {number} columnId The column id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkColumnColumnIdDelete: async (pk: number, columnId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkColumnColumnIdDelete.');
            }
            // verify required parameter 'columnId' is not null or undefined
            if (columnId === null || columnId === undefined) {
                throw new RequiredError('columnId','Required parameter columnId was null or undefined when calling apiV1DatasetPkColumnColumnIdDelete.');
            }
            const localVarPath = `/api/v1/dataset/{pk}/column/{column_id}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"column_id"}}`, encodeURIComponent(String(columnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkDelete: async (pk: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkDelete.');
            }
            const localVarPath = `/api/v1/dataset/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkGet: async (pk: number, q?: GetItemSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkGet.');
            }
            const localVarPath = `/api/v1/dataset/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Dataset metric
         * @param {number} pk The dataset pk for this column
         * @param {number} metricId The metric id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkMetricMetricIdDelete: async (pk: number, metricId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkMetricMetricIdDelete.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling apiV1DatasetPkMetricMetricIdDelete.');
            }
            const localVarPath = `/api/v1/dataset/{pk}/metric/{metric_id}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"metric_id"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes a Dataset
         * @param {DatasetRestApiPut} body Dataset schema
         * @param {number} pk 
         * @param {boolean} [overrideColumns] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkPut: async (body: DatasetRestApiPut, pk: number, overrideColumns?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatasetPkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkPut.');
            }
            const localVarPath = `/api/v1/dataset/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (overrideColumns !== undefined) {
                localVarQueryParameter['override_columns'] = overrideColumns;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Refreshes and updates columns of a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkRefreshPut: async (pk: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkRefreshPut.');
            }
            const localVarPath = `/api/v1/dataset/{pk}/refresh`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get charts and dashboards count associated to a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkRelatedObjectsGet: async (pk: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkRelatedObjectsGet.');
            }
            const localVarPath = `/api/v1/dataset/{pk}/related_objects`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Dataset
         * @param {DatasetRestApiPost} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPost: async (body: DatasetRestApiPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatasetPost.');
            }
            const localVarPath = `/api/v1/dataset/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetRelatedColumnNameGet: async (columnName: string, q?: GetRelatedSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1DatasetRelatedColumnNameGet.');
            }
            const localVarPath = `/api/v1/dataset/related/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetsApi - functional programming interface
 * @export
 */
export const DatasetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes multiple Datasets in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetDelete(q?: GetDeleteIdsSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse400>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetDelete(q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<DistincResponseSchema>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetDistinctColumnNameGet(columnName, q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Duplicates a Dataset
         * @param {DatasetDuplicateSchema} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetDuplicatePost(body: DatasetDuplicateSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20110>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetDuplicatePost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Exports multiple datasets and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetExportGet(q?: GetExportIdsSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetExportGet(q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetGet(q?: GetListSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20032>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetGet(q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a table by name, or create it if it does not exist
         * @param {GetOrCreateDatasetSchema} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetGetOrCreatePost(body: GetOrCreateDatasetSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20033>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetGetOrCreatePost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {boolean} syncColumns 
         * @param {boolean} syncMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetImportPostForm(formData: Blob, overwrite: boolean, passwords: string, syncColumns: boolean, syncMetrics: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse400>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetImportPostForm(formData, overwrite, passwords, syncColumns, syncMetrics, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetInfoGet(q?: GetInfoSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2002>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetInfoGet(q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Dataset column
         * @param {number} pk The dataset pk for this column
         * @param {number} columnId The column id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkColumnColumnIdDelete(pk: number, columnId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse400>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetPkColumnColumnIdDelete(pk, columnId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a Dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkDelete(pk: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse400>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetPkDelete(pk, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkGet(pk: number, q?: GetItemSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20034>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetPkGet(pk, q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Dataset metric
         * @param {number} pk The dataset pk for this column
         * @param {number} metricId The metric id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkMetricMetricIdDelete(pk: number, metricId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse400>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetPkMetricMetricIdDelete(pk, metricId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Changes a Dataset
         * @param {DatasetRestApiPut} body Dataset schema
         * @param {number} pk 
         * @param {boolean} [overrideColumns] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkPut(body: DatasetRestApiPut, pk: number, overrideColumns?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20035>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetPkPut(body, pk, overrideColumns, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Refreshes and updates columns of a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkRefreshPut(pk: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse400>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetPkRefreshPut(pk, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get charts and dashboards count associated to a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkRelatedObjectsGet(pk: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<DatasetRelatedObjectsResponse>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetPkRelatedObjectsGet(pk, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new Dataset
         * @param {DatasetRestApiPost} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPost(body: DatasetRestApiPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2019>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<RelatedResponseSchema>>> {
            const localVarAxiosArgs = await DatasetsApiAxiosParamCreator(configuration).apiV1DatasetRelatedColumnNameGet(columnName, q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DatasetsApi - factory interface
 * @export
 */
export const DatasetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes multiple Datasets in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetDelete(q?: GetDeleteIdsSchema, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse400>> {
            return DatasetsApiFp(configuration).apiV1DatasetDelete(q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: AxiosRequestConfig): Promise<AxiosResponse<DistincResponseSchema>> {
            return DatasetsApiFp(configuration).apiV1DatasetDistinctColumnNameGet(columnName, q, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates a Dataset
         * @param {DatasetDuplicateSchema} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetDuplicatePost(body: DatasetDuplicateSchema, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20110>> {
            return DatasetsApiFp(configuration).apiV1DatasetDuplicatePost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Exports multiple datasets and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetExportGet(q?: GetExportIdsSchema, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return DatasetsApiFp(configuration).apiV1DatasetExportGet(q, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetGet(q?: GetListSchema, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20032>> {
            return DatasetsApiFp(configuration).apiV1DatasetGet(q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a table by name, or create it if it does not exist
         * @param {GetOrCreateDatasetSchema} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetGetOrCreatePost(body: GetOrCreateDatasetSchema, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20033>> {
            return DatasetsApiFp(configuration).apiV1DatasetGetOrCreatePost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {boolean} syncColumns 
         * @param {boolean} syncMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetImportPostForm(formData: Blob, overwrite: boolean, passwords: string, syncColumns: boolean, syncMetrics: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse400>> {
            return DatasetsApiFp(configuration).apiV1DatasetImportPostForm(formData, overwrite, passwords, syncColumns, syncMetrics, options).then((request) => request(axios, basePath));
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetInfoGet(q?: GetInfoSchema, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2002>> {
            return DatasetsApiFp(configuration).apiV1DatasetInfoGet(q, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Dataset column
         * @param {number} pk The dataset pk for this column
         * @param {number} columnId The column id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkColumnColumnIdDelete(pk: number, columnId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse400>> {
            return DatasetsApiFp(configuration).apiV1DatasetPkColumnColumnIdDelete(pk, columnId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkDelete(pk: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse400>> {
            return DatasetsApiFp(configuration).apiV1DatasetPkDelete(pk, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkGet(pk: number, q?: GetItemSchema, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20034>> {
            return DatasetsApiFp(configuration).apiV1DatasetPkGet(pk, q, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Dataset metric
         * @param {number} pk The dataset pk for this column
         * @param {number} metricId The metric id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkMetricMetricIdDelete(pk: number, metricId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse400>> {
            return DatasetsApiFp(configuration).apiV1DatasetPkMetricMetricIdDelete(pk, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes a Dataset
         * @param {DatasetRestApiPut} body Dataset schema
         * @param {number} pk 
         * @param {boolean} [overrideColumns] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkPut(body: DatasetRestApiPut, pk: number, overrideColumns?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20035>> {
            return DatasetsApiFp(configuration).apiV1DatasetPkPut(body, pk, overrideColumns, options).then((request) => request(axios, basePath));
        },
        /**
         * Refreshes and updates columns of a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkRefreshPut(pk: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse400>> {
            return DatasetsApiFp(configuration).apiV1DatasetPkRefreshPut(pk, options).then((request) => request(axios, basePath));
        },
        /**
         * Get charts and dashboards count associated to a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPkRelatedObjectsGet(pk: number, options?: AxiosRequestConfig): Promise<AxiosResponse<DatasetRelatedObjectsResponse>> {
            return DatasetsApiFp(configuration).apiV1DatasetPkRelatedObjectsGet(pk, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Dataset
         * @param {DatasetRestApiPost} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetPost(body: DatasetRestApiPost, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2019>> {
            return DatasetsApiFp(configuration).apiV1DatasetPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DatasetRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: AxiosRequestConfig): Promise<AxiosResponse<RelatedResponseSchema>> {
            return DatasetsApiFp(configuration).apiV1DatasetRelatedColumnNameGet(columnName, q, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetsApi - object-oriented interface
 * @export
 * @class DatasetsApi
 * @extends {BaseAPI}
 */
export class DatasetsApi extends BaseAPI {
    /**
     * Deletes multiple Datasets in a bulk operation.
     * @param {GetDeleteIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetDelete(q?: GetDeleteIdsSchema, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse400>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetDelete(q, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: AxiosRequestConfig) : Promise<AxiosResponse<DistincResponseSchema>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetDistinctColumnNameGet(columnName, q, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Duplicates a Dataset
     * @param {DatasetDuplicateSchema} body Dataset schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetDuplicatePost(body: DatasetDuplicateSchema, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20110>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetDuplicatePost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Exports multiple datasets and downloads them as YAML files
     * @param {GetExportIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetExportGet(q?: GetExportIdsSchema, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetExportGet(q, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of models
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetGet(q?: GetListSchema, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20032>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetGet(q, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Retrieve a table by name, or create it if it does not exist
     * @param {GetOrCreateDatasetSchema} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetGetOrCreatePost(body: GetOrCreateDatasetSchema, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20033>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetGetOrCreatePost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {Blob} formData 
     * @param {boolean} overwrite 
     * @param {string} passwords 
     * @param {boolean} syncColumns 
     * @param {boolean} syncMetrics 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetImportPostForm(formData: Blob, overwrite: boolean, passwords: string, syncColumns: boolean, syncMetrics: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse400>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetImportPostForm(formData, overwrite, passwords, syncColumns, syncMetrics, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get metadata information about this API resource
     * @param {GetInfoSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetInfoGet(q?: GetInfoSchema, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2002>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetInfoGet(q, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Dataset column
     * @param {number} pk The dataset pk for this column
     * @param {number} columnId The column id for this dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetPkColumnColumnIdDelete(pk: number, columnId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse400>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkColumnColumnIdDelete(pk, columnId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a Dataset
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetPkDelete(pk: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse400>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkDelete(pk, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an item model
     * @param {number} pk 
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetPkGet(pk: number, q?: GetItemSchema, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20034>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkGet(pk, q, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Dataset metric
     * @param {number} pk The dataset pk for this column
     * @param {number} metricId The metric id for this dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetPkMetricMetricIdDelete(pk: number, metricId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse400>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkMetricMetricIdDelete(pk, metricId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes a Dataset
     * @param {DatasetRestApiPut} body Dataset schema
     * @param {number} pk 
     * @param {boolean} [overrideColumns] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetPkPut(body: DatasetRestApiPut, pk: number, overrideColumns?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20035>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkPut(body, pk, overrideColumns, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refreshes and updates columns of a dataset
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetPkRefreshPut(pk: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse400>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkRefreshPut(pk, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get charts and dashboards count associated to a dataset
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetPkRelatedObjectsGet(pk: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<DatasetRelatedObjectsResponse>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkRelatedObjectsGet(pk, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new Dataset
     * @param {DatasetRestApiPost} body Dataset schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetPost(body: DatasetRestApiPost, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2019>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetPost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public async apiV1DatasetRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: AxiosRequestConfig) : Promise<AxiosResponse<RelatedResponseSchema>> {
        return DatasetsApiFp(this.configuration).apiV1DatasetRelatedColumnNameGet(columnName, q, options).then((request) => request(this.axios, this.basePath));
    }
}
