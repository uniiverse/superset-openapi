/*
 * Superset
 * Superset
 *
 * OpenAPI spec version: v1
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 3.0.44
 *
 * Do not edit the class manually.
 *
 */
import {ApiClient} from '../ApiClient';
import {ChartDataFilter} from './ChartDataFilter';

/**
 * The ChartDataExtras model module.
 * @module model/ChartDataExtras
 * @version v1
 */
export class ChartDataExtras {
  /**
   * Constructs a new <code>ChartDataExtras</code>.
   * @alias module:model/ChartDataExtras
   * @class
   */
  constructor() {
  }

  /**
   * Constructs a <code>ChartDataExtras</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ChartDataExtras} obj Optional instance to populate.
   * @return {module:model/ChartDataExtras} The populated <code>ChartDataExtras</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new ChartDataExtras();
      if (data.hasOwnProperty('having'))
        obj.having = ApiClient.convertToType(data['having'], 'String');
      if (data.hasOwnProperty('having_druid'))
        obj.havingDruid = ApiClient.convertToType(data['having_druid'], [ChartDataFilter]);
      if (data.hasOwnProperty('relative_end'))
        obj.relativeEnd = ApiClient.convertToType(data['relative_end'], 'String');
      if (data.hasOwnProperty('relative_start'))
        obj.relativeStart = ApiClient.convertToType(data['relative_start'], 'String');
      if (data.hasOwnProperty('time_grain_sqla'))
        obj.timeGrainSqla = ApiClient.convertToType(data['time_grain_sqla'], 'String');
      if (data.hasOwnProperty('where'))
        obj.where = ApiClient.convertToType(data['where'], 'String');
    }
    return obj;
  }
}

/**
 * HAVING clause to be added to aggregate queries using AND operator.
 * @member {String} having
 */
ChartDataExtras.prototype.having = undefined;

/**
 * HAVING filters to be added to legacy Druid datasource queries. This field is deprecated
 * @member {Array.<module:model/ChartDataFilter>} havingDruid
 */
ChartDataExtras.prototype.havingDruid = undefined;

/**
 * Allowed values for the <code>relativeEnd</code> property.
 * @enum {String}
 * @readonly
 */
ChartDataExtras.RelativeEndEnum = {
  /**
   * value: "today"
   * @const
   */
  today: "today",

  /**
   * value: "now"
   * @const
   */
  now: "now"
};
/**
 * End time for relative time deltas. Default: `config[\"DEFAULT_RELATIVE_START_TIME\"]`
 * @member {module:model/ChartDataExtras.RelativeEndEnum} relativeEnd
 */
ChartDataExtras.prototype.relativeEnd = undefined;

/**
 * Allowed values for the <code>relativeStart</code> property.
 * @enum {String}
 * @readonly
 */
ChartDataExtras.RelativeStartEnum = {
  /**
   * value: "today"
   * @const
   */
  today: "today",

  /**
   * value: "now"
   * @const
   */
  now: "now"
};
/**
 * Start time for relative time deltas. Default: `config[\"DEFAULT_RELATIVE_START_TIME\"]`
 * @member {module:model/ChartDataExtras.RelativeStartEnum} relativeStart
 */
ChartDataExtras.prototype.relativeStart = undefined;

/**
 * Allowed values for the <code>timeGrainSqla</code> property.
 * @enum {String}
 * @readonly
 */
ChartDataExtras.TimeGrainSqlaEnum = {
  /**
   * value: "PT1S"
   * @const
   */
  pT1S: "PT1S",

  /**
   * value: "PT5S"
   * @const
   */
  pT5S: "PT5S",

  /**
   * value: "PT30S"
   * @const
   */
  pT30S: "PT30S",

  /**
   * value: "PT1M"
   * @const
   */
  pT1M: "PT1M",

  /**
   * value: "PT5M"
   * @const
   */
  pT5M: "PT5M",

  /**
   * value: "PT10M"
   * @const
   */
  pT10M: "PT10M",

  /**
   * value: "PT15M"
   * @const
   */
  pT15M: "PT15M",

  /**
   * value: "PT30M"
   * @const
   */
  pT30M: "PT30M",

  /**
   * value: "PT1H"
   * @const
   */
  pT1H: "PT1H",

  /**
   * value: "PT6H"
   * @const
   */
  pT6H: "PT6H",

  /**
   * value: "P1D"
   * @const
   */
  p1D: "P1D",

  /**
   * value: "P1W"
   * @const
   */
  p1W: "P1W",

  /**
   * value: "P1M"
   * @const
   */
  p1M: "P1M",

  /**
   * value: "P3M"
   * @const
   */
  p3M: "P3M",

  /**
   * value: "P1Y"
   * @const
   */
  p1Y: "P1Y",

  /**
   * value: "1969-12-28T00:00:00Z/P1W"
   * @const
   */
  _19691228T000000ZP1W: "1969-12-28T00:00:00Z/P1W",

  /**
   * value: "1969-12-29T00:00:00Z/P1W"
   * @const
   */
  _19691229T000000ZP1W: "1969-12-29T00:00:00Z/P1W",

  /**
   * value: "P1W/1970-01-03T00:00:00Z"
   * @const
   */
  p1W19700103T000000Z: "P1W/1970-01-03T00:00:00Z",

  /**
   * value: "P1W/1970-01-04T00:00:00Z"
   * @const
   */
  p1W19700104T000000Z: "P1W/1970-01-04T00:00:00Z"
};
/**
 * To what level of granularity should the temporal column be aggregated. Supports [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) durations.
 * @member {module:model/ChartDataExtras.TimeGrainSqlaEnum} timeGrainSqla
 */
ChartDataExtras.prototype.timeGrainSqla = undefined;

/**
 * WHERE clause to be added to queries using AND operator.
 * @member {String} where
 */
ChartDataExtras.prototype.where = undefined;

