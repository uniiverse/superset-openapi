/*
 * Superset
 * Superset
 *
 * OpenAPI spec version: v1
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 3.0.44
 *
 * Do not edit the class manually.
 *
 */
import {ApiClient} from '../ApiClient';
import {AnnotationLayer} from './AnnotationLayer';
import {ChartDataFilter} from './ChartDataFilter';

/**
 * The ChartDataQueryObject model module.
 * @module model/ChartDataQueryObject
 * @version v1
 */
export class ChartDataQueryObject {
  /**
   * Constructs a new <code>ChartDataQueryObject</code>.
   * @alias module:model/ChartDataQueryObject
   * @class
   */
  constructor() {
  }

  /**
   * Constructs a <code>ChartDataQueryObject</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ChartDataQueryObject} obj Optional instance to populate.
   * @return {module:model/ChartDataQueryObject} The populated <code>ChartDataQueryObject</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new ChartDataQueryObject();
      if (data.hasOwnProperty('annotation_layers'))
        obj.annotationLayers = ApiClient.convertToType(data['annotation_layers'], [AnnotationLayer]);
      if (data.hasOwnProperty('applied_time_extras'))
        obj.appliedTimeExtras = ApiClient.convertToType(data['applied_time_extras'], Object);
      if (data.hasOwnProperty('apply_fetch_values_predicate'))
        obj.applyFetchValuesPredicate = ApiClient.convertToType(data['apply_fetch_values_predicate'], 'Boolean');
      if (data.hasOwnProperty('columns'))
        obj.columns = ApiClient.convertToType(data['columns'], [Object]);
      if (data.hasOwnProperty('datasource'))
        obj.datasource = ApiClient.convertToType(data['datasource'], Object);
      if (data.hasOwnProperty('druid_time_origin'))
        obj.druidTimeOrigin = ApiClient.convertToType(data['druid_time_origin'], 'String');
      if (data.hasOwnProperty('extras'))
        obj.extras = ApiClient.convertToType(data['extras'], Object);
      if (data.hasOwnProperty('filters'))
        obj.filters = ApiClient.convertToType(data['filters'], [ChartDataFilter]);
      if (data.hasOwnProperty('granularity'))
        obj.granularity = ApiClient.convertToType(data['granularity'], 'String');
      if (data.hasOwnProperty('granularity_sqla'))
        obj.granularitySqla = ApiClient.convertToType(data['granularity_sqla'], 'String');
      if (data.hasOwnProperty('groupby'))
        obj.groupby = ApiClient.convertToType(data['groupby'], [Object]);
      if (data.hasOwnProperty('having'))
        obj.having = ApiClient.convertToType(data['having'], 'String');
      if (data.hasOwnProperty('having_filters'))
        obj.havingFilters = ApiClient.convertToType(data['having_filters'], [ChartDataFilter]);
      if (data.hasOwnProperty('is_rowcount'))
        obj.isRowcount = ApiClient.convertToType(data['is_rowcount'], 'Boolean');
      if (data.hasOwnProperty('is_timeseries'))
        obj.isTimeseries = ApiClient.convertToType(data['is_timeseries'], 'Boolean');
      if (data.hasOwnProperty('metrics'))
        obj.metrics = ApiClient.convertToType(data['metrics'], [Object]);
      if (data.hasOwnProperty('order_desc'))
        obj.orderDesc = ApiClient.convertToType(data['order_desc'], 'Boolean');
      if (data.hasOwnProperty('orderby'))
        obj.orderby = ApiClient.convertToType(data['orderby'], [Object]);
      if (data.hasOwnProperty('post_processing'))
        obj.postProcessing = ApiClient.convertToType(data['post_processing'], [AllOfChartDataQueryObjectPostProcessingItems]);
      if (data.hasOwnProperty('result_type'))
        obj.resultType = ApiClient.convertToType(data['result_type'], Object);
      if (data.hasOwnProperty('row_limit'))
        obj.rowLimit = ApiClient.convertToType(data['row_limit'], 'Number');
      if (data.hasOwnProperty('row_offset'))
        obj.rowOffset = ApiClient.convertToType(data['row_offset'], 'Number');
      if (data.hasOwnProperty('series_columns'))
        obj.seriesColumns = ApiClient.convertToType(data['series_columns'], [Object]);
      if (data.hasOwnProperty('series_limit'))
        obj.seriesLimit = ApiClient.convertToType(data['series_limit'], 'Number');
      if (data.hasOwnProperty('series_limit_metric'))
        obj.seriesLimitMetric = ApiClient.convertToType(data['series_limit_metric'], Object);
      if (data.hasOwnProperty('time_offsets'))
        obj.timeOffsets = ApiClient.convertToType(data['time_offsets'], ['String']);
      if (data.hasOwnProperty('time_range'))
        obj.timeRange = ApiClient.convertToType(data['time_range'], 'String');
      if (data.hasOwnProperty('time_shift'))
        obj.timeShift = ApiClient.convertToType(data['time_shift'], 'String');
      if (data.hasOwnProperty('timeseries_limit'))
        obj.timeseriesLimit = ApiClient.convertToType(data['timeseries_limit'], 'Number');
      if (data.hasOwnProperty('timeseries_limit_metric'))
        obj.timeseriesLimitMetric = ApiClient.convertToType(data['timeseries_limit_metric'], Object);
      if (data.hasOwnProperty('url_params'))
        obj.urlParams = ApiClient.convertToType(data['url_params'], {'String': 'String'});
      if (data.hasOwnProperty('where'))
        obj.where = ApiClient.convertToType(data['where'], 'String');
    }
    return obj;
  }
}

/**
 * Annotation layers to apply to chart
 * @member {Array.<module:model/AnnotationLayer>} annotationLayers
 */
ChartDataQueryObject.prototype.annotationLayers = undefined;

/**
 * A mapping of temporal extras that have been applied to the query
 * @member {Object} appliedTimeExtras
 */
ChartDataQueryObject.prototype.appliedTimeExtras = undefined;

/**
 * Add fetch values predicate (where clause) to query if defined in datasource
 * @member {Boolean} applyFetchValuesPredicate
 */
ChartDataQueryObject.prototype.applyFetchValuesPredicate = undefined;

/**
 * Columns which to select in the query.
 * @member {Array.<Object>} columns
 */
ChartDataQueryObject.prototype.columns = undefined;

/**
 * @member {Object} datasource
 */
ChartDataQueryObject.prototype.datasource = undefined;

/**
 * Starting point for time grain counting on legacy Druid datasources. Used to change e.g. Monday/Sunday first-day-of-week. This field is deprecated and should be passed to `extras` as `druid_time_origin`.
 * @member {String} druidTimeOrigin
 */
ChartDataQueryObject.prototype.druidTimeOrigin = undefined;

/**
 * Extra parameters to add to the query.
 * @member {Object} extras
 */
ChartDataQueryObject.prototype.extras = undefined;

/**
 * @member {Array.<module:model/ChartDataFilter>} filters
 */
ChartDataQueryObject.prototype.filters = undefined;

/**
 * Name of temporal column used for time filtering. For legacy Druid datasources this defines the time grain.
 * @member {String} granularity
 */
ChartDataQueryObject.prototype.granularity = undefined;

/**
 * Name of temporal column used for time filtering for SQL datasources. This field is deprecated, use `granularity` instead.
 * @member {String} granularitySqla
 */
ChartDataQueryObject.prototype.granularitySqla = undefined;

/**
 * Columns by which to group the query. This field is deprecated, use `columns` instead.
 * @member {Array.<Object>} groupby
 */
ChartDataQueryObject.prototype.groupby = undefined;

/**
 * HAVING clause to be added to aggregate queries using AND operator. This field is deprecated and should be passed to `extras`.
 * @member {String} having
 */
ChartDataQueryObject.prototype.having = undefined;

/**
 * HAVING filters to be added to legacy Druid datasource queries. This field is deprecated and should be passed to `extras` as `having_druid`.
 * @member {Array.<module:model/ChartDataFilter>} havingFilters
 */
ChartDataQueryObject.prototype.havingFilters = undefined;

/**
 * Should the rowcount of the actual query be returned
 * @member {Boolean} isRowcount
 */
ChartDataQueryObject.prototype.isRowcount = undefined;

/**
 * Is the `query_object` a timeseries.
 * @member {Boolean} isTimeseries
 */
ChartDataQueryObject.prototype.isTimeseries = undefined;

/**
 * Aggregate expressions. Metrics can be passed as both references to datasource metrics (strings), or ad-hoc metricswhich are defined only within the query object. See `ChartDataAdhocMetricSchema` for the structure of ad-hoc metrics.
 * @member {Array.<Object>} metrics
 */
ChartDataQueryObject.prototype.metrics = undefined;

/**
 * Reverse order. Default: `false`
 * @member {Boolean} orderDesc
 */
ChartDataQueryObject.prototype.orderDesc = undefined;

/**
 * Expects a list of lists where the first element is the column name which to sort by, and the second element is a boolean.
 * @member {Array.<Object>} orderby
 */
ChartDataQueryObject.prototype.orderby = undefined;

/**
 * Post processing operations to be applied to the result set. Operations are applied to the result set in sequential order.
 * @member {Array.<Object>} postProcessing
 */
ChartDataQueryObject.prototype.postProcessing = undefined;

/**
 * @member {Object} resultType
 */
ChartDataQueryObject.prototype.resultType = undefined;

/**
 * Maximum row count (0=disabled). Default: `config[\"ROW_LIMIT\"]`
 * @member {Number} rowLimit
 */
ChartDataQueryObject.prototype.rowLimit = undefined;

/**
 * Number of rows to skip. Default: `0`
 * @member {Number} rowOffset
 */
ChartDataQueryObject.prototype.rowOffset = undefined;

/**
 * Columns to use when limiting series count. All columns must be present in the `columns` property. Requires `series_limit` and `series_limit_metric` to be set.
 * @member {Array.<Object>} seriesColumns
 */
ChartDataQueryObject.prototype.seriesColumns = undefined;

/**
 * Maximum number of series. Requires `series` and `series_limit_metric` to be set.
 * @member {Number} seriesLimit
 */
ChartDataQueryObject.prototype.seriesLimit = undefined;

/**
 * Metric used to limit timeseries queries by. Requires `series` and `series_limit` to be set.
 * @member {Object} seriesLimitMetric
 */
ChartDataQueryObject.prototype.seriesLimitMetric = undefined;

/**
 * @member {Array.<String>} timeOffsets
 */
ChartDataQueryObject.prototype.timeOffsets = undefined;

/**
 * A time rage, either expressed as a colon separated string `since : until` or human readable freeform. Valid formats for `since` and `until` are:  - ISO 8601 - X days/years/hours/day/year/weeks - X days/years/hours/day/year/weeks ago - X days/years/hours/day/year/weeks from now  Additionally, the following freeform can be used:  - Last day - Last week - Last month - Last quarter - Last year - No filter - Last X seconds/minutes/hours/days/weeks/months/years - Next X seconds/minutes/hours/days/weeks/months/years 
 * @member {String} timeRange
 */
ChartDataQueryObject.prototype.timeRange = undefined;

/**
 * A human-readable date/time string. Please refer to [parsdatetime](https://github.com/bear/parsedatetime) documentation for details on valid values.
 * @member {String} timeShift
 */
ChartDataQueryObject.prototype.timeShift = undefined;

/**
 * Maximum row count for timeseries queries. This field is deprecated, use `series_limit` instead.Default: `0`
 * @member {Number} timeseriesLimit
 */
ChartDataQueryObject.prototype.timeseriesLimit = undefined;

/**
 * Metric used to limit timeseries queries by. This field is deprecated, use `series_limit_metric` instead.
 * @member {Object} timeseriesLimitMetric
 */
ChartDataQueryObject.prototype.timeseriesLimitMetric = undefined;

/**
 * Optional query parameters passed to a dashboard or Explore  view
 * @member {Object.<String, String>} urlParams
 */
ChartDataQueryObject.prototype.urlParams = undefined;

/**
 * WHERE clause to be added to queries using AND operator.This field is deprecated and should be passed to `extras`.
 * @member {String} where
 */
ChartDataQueryObject.prototype.where = undefined;

