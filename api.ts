/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Superset
 * Superset
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:8088/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AdvancedDataTypeConvertSchema
 */
export interface AdvancedDataTypeConvertSchema {
    /**
     * 
     * @type {string}
     * @memberof AdvancedDataTypeConvertSchema
     */
    type: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof AdvancedDataTypeConvertSchema
     */
    values: Array<any>;
}
/**
 * 
 * @export
 * @interface AdvancedDataTypeSchema
 */
export interface AdvancedDataTypeSchema {
    /**
     * The string representation of the parsed values
     * @type {string}
     * @memberof AdvancedDataTypeSchema
     */
    displayValue?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedDataTypeSchema
     */
    errorMessage?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AdvancedDataTypeSchema
     */
    validFilterOperators?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AdvancedDataTypeSchema
     */
    values?: Array<string>;
}
/**
 * 
 * @export
 * @interface AnnotationLayer
 */
export interface AnnotationLayer {
    /**
     * Type of annotation layer
     * @type {string}
     * @memberof AnnotationLayer
     */
    annotationType?: AnnotationLayer.AnnotationTypeEnum;
    /**
     * Layer color
     * @type {string}
     * @memberof AnnotationLayer
     */
    color?: string;
    /**
     * Columns to use as the description. If none are provided, all will be shown.
     * @type {Array<string>}
     * @memberof AnnotationLayer
     */
    descriptionColumns?: Array<string>;
    /**
     * Should line be hidden. Only applies to line annotations
     * @type {boolean}
     * @memberof AnnotationLayer
     */
    hideLine?: boolean;
    /**
     * Column containing end of interval. Only applies to interval layers
     * @type {string}
     * @memberof AnnotationLayer
     */
    intervalEndColumn?: string;
    /**
     * Name of layer
     * @type {string}
     * @memberof AnnotationLayer
     */
    name: string;
    /**
     * Opacity of layer
     * @type {string}
     * @memberof AnnotationLayer
     */
    opacity?: AnnotationLayer.OpacityEnum;
    /**
     * which properties should be overridable
     * @type {{ [key: string]: any; }}
     * @memberof AnnotationLayer
     */
    overrides?: { [key: string]: any; };
    /**
     * Should the layer be shown
     * @type {boolean}
     * @memberof AnnotationLayer
     */
    show: boolean;
    /**
     * Should the label always be shown
     * @type {boolean}
     * @memberof AnnotationLayer
     */
    showLabel?: boolean;
    /**
     * Should markers be shown. Only applies to line annotations.
     * @type {boolean}
     * @memberof AnnotationLayer
     */
    showMarkers: boolean;
    /**
     * Type of source for annotation data
     * @type {string}
     * @memberof AnnotationLayer
     */
    sourceType?: AnnotationLayer.SourceTypeEnum;
    /**
     * Line style. Only applies to time-series annotations
     * @type {string}
     * @memberof AnnotationLayer
     */
    style?: AnnotationLayer.StyleEnum;
    /**
     * Column with event date or interval start date
     * @type {string}
     * @memberof AnnotationLayer
     */
    timeColumn?: string;
    /**
     * Column with title
     * @type {string}
     * @memberof AnnotationLayer
     */
    titleColumn?: string;
    /**
     * For formula annotations, this contains the formula. For other types, this is the primary key of the source object.
     * @type {any}
     * @memberof AnnotationLayer
     */
    value: any;
    /**
     * Width of annotation line
     * @type {number}
     * @memberof AnnotationLayer
     */
    width?: number;
}

/**
 * @export
 * @namespace AnnotationLayer
 */
export namespace AnnotationLayer {
    /**
     * @export
     * @enum {string}
     */
    export enum AnnotationTypeEnum {
        FORMULA = <any> 'FORMULA',
        INTERVAL = <any> 'INTERVAL',
        EVENT = <any> 'EVENT',
        TIMESERIES = <any> 'TIME_SERIES'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OpacityEnum {
        Empty = <any> '',
        OpacityLow = <any> 'opacityLow',
        OpacityMedium = <any> 'opacityMedium',
        OpacityHigh = <any> 'opacityHigh'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SourceTypeEnum {
        Empty = <any> '',
        Line = <any> 'line',
        NATIVE = <any> 'NATIVE',
        Table = <any> 'table'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StyleEnum {
        Dashed = <any> 'dashed',
        Dotted = <any> 'dotted',
        Solid = <any> 'solid',
        LongDashed = <any> 'longDashed'
    }
}
/**
 * 
 * @export
 * @interface AnnotationLayerRestApiGet
 */
export interface AnnotationLayerRestApiGet {
    /**
     * 
     * @type {string}
     * @memberof AnnotationLayerRestApiGet
     */
    descr?: string;
    /**
     * 
     * @type {number}
     * @memberof AnnotationLayerRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationLayerRestApiGet
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface AnnotationLayerRestApiGetList
 */
export interface AnnotationLayerRestApiGetList {
    /**
     * 
     * @type {AnnotationLayerRestApiGetListUser}
     * @memberof AnnotationLayerRestApiGetList
     */
    changedBy?: AnnotationLayerRestApiGetListUser;
    /**
     * 
     * @type {Date}
     * @memberof AnnotationLayerRestApiGetList
     */
    changedOn?: Date;
    /**
     * 
     * @type {any}
     * @memberof AnnotationLayerRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {AnnotationLayerRestApiGetListUser1}
     * @memberof AnnotationLayerRestApiGetList
     */
    createdBy?: AnnotationLayerRestApiGetListUser1;
    /**
     * 
     * @type {Date}
     * @memberof AnnotationLayerRestApiGetList
     */
    createdOn?: Date;
    /**
     * 
     * @type {string}
     * @memberof AnnotationLayerRestApiGetList
     */
    descr?: string;
    /**
     * 
     * @type {number}
     * @memberof AnnotationLayerRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationLayerRestApiGetList
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface AnnotationLayerRestApiGetListUser
 */
export interface AnnotationLayerRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof AnnotationLayerRestApiGetListUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationLayerRestApiGetListUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface AnnotationLayerRestApiGetListUser1
 */
export interface AnnotationLayerRestApiGetListUser1 {
    /**
     * 
     * @type {string}
     * @memberof AnnotationLayerRestApiGetListUser1
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationLayerRestApiGetListUser1
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface AnnotationLayerRestApiPost
 */
export interface AnnotationLayerRestApiPost {
    /**
     * Give a description for this annotation layer
     * @type {string}
     * @memberof AnnotationLayerRestApiPost
     */
    descr?: string;
    /**
     * The annotation layer name
     * @type {string}
     * @memberof AnnotationLayerRestApiPost
     */
    name: string;
}
/**
 * 
 * @export
 * @interface AnnotationLayerRestApiPut
 */
export interface AnnotationLayerRestApiPut {
    /**
     * Give a description for this annotation layer
     * @type {string}
     * @memberof AnnotationLayerRestApiPut
     */
    descr?: string;
    /**
     * The annotation layer name
     * @type {string}
     * @memberof AnnotationLayerRestApiPut
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface AnnotationRestApiGet
 */
export interface AnnotationRestApiGet {
    /**
     * 
     * @type {Date}
     * @memberof AnnotationRestApiGet
     */
    endDttm?: Date;
    /**
     * 
     * @type {number}
     * @memberof AnnotationRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationRestApiGet
     */
    jsonMetadata?: string;
    /**
     * 
     * @type {AnnotationRestApiGetAnnotationLayer}
     * @memberof AnnotationRestApiGet
     */
    layer: AnnotationRestApiGetAnnotationLayer;
    /**
     * 
     * @type {string}
     * @memberof AnnotationRestApiGet
     */
    longDescr?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationRestApiGet
     */
    shortDescr?: string;
    /**
     * 
     * @type {Date}
     * @memberof AnnotationRestApiGet
     */
    startDttm?: Date;
}
/**
 * 
 * @export
 * @interface AnnotationRestApiGetAnnotationLayer
 */
export interface AnnotationRestApiGetAnnotationLayer {
    /**
     * 
     * @type {number}
     * @memberof AnnotationRestApiGetAnnotationLayer
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationRestApiGetAnnotationLayer
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface AnnotationRestApiGetList
 */
export interface AnnotationRestApiGetList {
    /**
     * 
     * @type {AnnotationRestApiGetListUser}
     * @memberof AnnotationRestApiGetList
     */
    changedBy?: AnnotationRestApiGetListUser;
    /**
     * 
     * @type {any}
     * @memberof AnnotationRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {AnnotationRestApiGetListUser1}
     * @memberof AnnotationRestApiGetList
     */
    createdBy?: AnnotationRestApiGetListUser1;
    /**
     * 
     * @type {Date}
     * @memberof AnnotationRestApiGetList
     */
    endDttm?: Date;
    /**
     * 
     * @type {number}
     * @memberof AnnotationRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationRestApiGetList
     */
    longDescr?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationRestApiGetList
     */
    shortDescr?: string;
    /**
     * 
     * @type {Date}
     * @memberof AnnotationRestApiGetList
     */
    startDttm?: Date;
}
/**
 * 
 * @export
 * @interface AnnotationRestApiGetListUser
 */
export interface AnnotationRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof AnnotationRestApiGetListUser
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof AnnotationRestApiGetListUser
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface AnnotationRestApiGetListUser1
 */
export interface AnnotationRestApiGetListUser1 {
    /**
     * 
     * @type {string}
     * @memberof AnnotationRestApiGetListUser1
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof AnnotationRestApiGetListUser1
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface AnnotationRestApiPost
 */
export interface AnnotationRestApiPost {
    /**
     * The annotation end date time
     * @type {Date}
     * @memberof AnnotationRestApiPost
     */
    endDttm: Date;
    /**
     * JSON metadata
     * @type {string}
     * @memberof AnnotationRestApiPost
     */
    jsonMetadata?: string;
    /**
     * A long description
     * @type {string}
     * @memberof AnnotationRestApiPost
     */
    longDescr?: string;
    /**
     * A short description
     * @type {string}
     * @memberof AnnotationRestApiPost
     */
    shortDescr: string;
    /**
     * The annotation start date time
     * @type {Date}
     * @memberof AnnotationRestApiPost
     */
    startDttm: Date;
}
/**
 * 
 * @export
 * @interface AnnotationRestApiPut
 */
export interface AnnotationRestApiPut {
    /**
     * The annotation end date time
     * @type {Date}
     * @memberof AnnotationRestApiPut
     */
    endDttm?: Date;
    /**
     * JSON metadata
     * @type {string}
     * @memberof AnnotationRestApiPut
     */
    jsonMetadata?: string;
    /**
     * A long description
     * @type {string}
     * @memberof AnnotationRestApiPut
     */
    longDescr?: string;
    /**
     * A short description
     * @type {string}
     * @memberof AnnotationRestApiPut
     */
    shortDescr?: string;
    /**
     * The annotation start date time
     * @type {Date}
     * @memberof AnnotationRestApiPut
     */
    startDttm?: Date;
}
/**
 * Dict with public properties form the DB Engine
 * @export
 * @interface Apiv1databaseavailableEngineInformation
 */
export interface Apiv1databaseavailableEngineInformation {
    /**
     * Whether the engine supports SSH Tunnels
     * @type {boolean}
     * @memberof Apiv1databaseavailableEngineInformation
     */
    disableSshTunneling?: boolean;
    /**
     * Whether the engine supports file uploads
     * @type {boolean}
     * @memberof Apiv1databaseavailableEngineInformation
     */
    supportsFileUpload?: boolean;
}
/**
 * 
 * @export
 * @interface AssetsImportBody
 */
export interface AssetsImportBody {
    /**
     * upload file (ZIP or JSON)
     * @type {Blob}
     * @memberof AssetsImportBody
     */
    bundle?: Blob;
    /**
     * JSON map of passwords for each featured database in the ZIP file. If the ZIP includes a database config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof AssetsImportBody
     */
    passwords?: string;
    /**
     * JSON map of passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof AssetsImportBody
     */
    sshTunnelPasswords?: string;
    /**
     * JSON map of private_key_passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key_password\"}`.
     * @type {string}
     * @memberof AssetsImportBody
     */
    sshTunnelPrivateKeyPasswords?: string;
    /**
     * JSON map of private_keys for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key\"}`.
     * @type {string}
     * @memberof AssetsImportBody
     */
    sshTunnelPrivateKeys?: string;
}
/**
 * 
 * @export
 * @interface AvailableDomainsSchema
 */
export interface AvailableDomainsSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof AvailableDomainsSchema
     */
    domains?: Array<string>;
}
/**
 * 
 * @export
 * @interface CacheInvalidationRequestSchema
 */
export interface CacheInvalidationRequestSchema {
    /**
     * The uid of the dataset/datasource this new chart will use. A complete datasource identification needs `datasouce_uid` 
     * @type {Array<string>}
     * @memberof CacheInvalidationRequestSchema
     */
    datasourceUids?: Array<string>;
    /**
     * A list of the data source and database names
     * @type {Array<Datasource>}
     * @memberof CacheInvalidationRequestSchema
     */
    datasources?: Array<Datasource>;
}
/**
 * 
 * @export
 * @interface CacheRestApiGet
 */
export interface CacheRestApiGet {
    /**
     * 
     * @type {number}
     * @memberof CacheRestApiGet
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface CacheRestApiGetList
 */
export interface CacheRestApiGetList {
    /**
     * 
     * @type {number}
     * @memberof CacheRestApiGetList
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface CacheRestApiPost
 */
export interface CacheRestApiPost {
    /**
     * 
     * @type {number}
     * @memberof CacheRestApiPost
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface CacheRestApiPut
 */
export interface CacheRestApiPut {
    /**
     * 
     * @type {number}
     * @memberof CacheRestApiPut
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ChartCacheScreenshotResponseSchema
 */
export interface ChartCacheScreenshotResponseSchema {
    /**
     * The cache key
     * @type {string}
     * @memberof ChartCacheScreenshotResponseSchema
     */
    cacheKey?: string;
    /**
     * The url to render the chart
     * @type {string}
     * @memberof ChartCacheScreenshotResponseSchema
     */
    chartUrl?: string;
    /**
     * The url to fetch the screenshot
     * @type {string}
     * @memberof ChartCacheScreenshotResponseSchema
     */
    imageUrl?: string;
}
/**
 * 
 * @export
 * @interface ChartDataAdhocMetricSchema
 */
export interface ChartDataAdhocMetricSchema {
    /**
     * Aggregation operator.Only required for simple expression types.
     * @type {string}
     * @memberof ChartDataAdhocMetricSchema
     */
    aggregate?: ChartDataAdhocMetricSchema.AggregateEnum;
    /**
     * 
     * @type {ChartDataColumn}
     * @memberof ChartDataAdhocMetricSchema
     */
    column?: ChartDataColumn;
    /**
     * Simple or SQL metric
     * @type {string}
     * @memberof ChartDataAdhocMetricSchema
     */
    expressionType: ChartDataAdhocMetricSchema.ExpressionTypeEnum;
    /**
     * When false, the label will be automatically generated based on the aggregate expression. When true, a custom label has to be specified.
     * @type {boolean}
     * @memberof ChartDataAdhocMetricSchema
     */
    hasCustomLabel?: boolean;
    /**
     * Indicates if the filter has been added by a filter component as opposed to being a part of the original query.
     * @type {boolean}
     * @memberof ChartDataAdhocMetricSchema
     */
    isExtra?: boolean;
    /**
     * Label for the metric. Is automatically generated unlesshasCustomLabel is true, in which case label must be defined.
     * @type {string}
     * @memberof ChartDataAdhocMetricSchema
     */
    label?: string;
    /**
     * Unique identifier. Can be any string value, as long as all metrics have a unique identifier. If undefined, a random namewill be generated.
     * @type {string}
     * @memberof ChartDataAdhocMetricSchema
     */
    optionName?: string;
    /**
     * The metric as defined by a SQL aggregate expression. Only required for SQL expression type.
     * @type {string}
     * @memberof ChartDataAdhocMetricSchema
     */
    sqlExpression?: string;
    /**
     * Optional time grain for temporal filters
     * @type {string}
     * @memberof ChartDataAdhocMetricSchema
     */
    timeGrain?: string;
}

/**
 * @export
 * @namespace ChartDataAdhocMetricSchema
 */
export namespace ChartDataAdhocMetricSchema {
    /**
     * @export
     * @enum {string}
     */
    export enum AggregateEnum {
        AVG = <any> 'AVG',
        COUNT = <any> 'COUNT',
        COUNTDISTINCT = <any> 'COUNT_DISTINCT',
        MAX = <any> 'MAX',
        MIN = <any> 'MIN',
        SUM = <any> 'SUM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ExpressionTypeEnum {
        SIMPLE = <any> 'SIMPLE',
        SQL = <any> 'SQL'
    }
}
/**
 * 
 * @export
 * @interface ChartDataAggregateOptionsSchema
 */
export interface ChartDataAggregateOptionsSchema {
    /**
     * The keys are the name of the aggregate column to be created, and the values specify the details of how to apply the aggregation. If an operator requires additional options, these can be passed here to be unpacked in the operator call. The following numpy operators are supported: average, argmin, argmax, cumsum, cumprod, max, mean, median, nansum, nanmin, nanmax, nanmean, nanmedian, min, percentile, prod, product, std, sum, var. Any options required by the operator can be passed to the `options` object.  In the example, a new column `first_quantile` is created based on values in the column `my_col` using the `percentile` operator with the `q=0.25` parameter.
     * @type {any}
     * @memberof ChartDataAggregateOptionsSchema
     */
    aggregates?: any;
}
/**
 * 
 * @export
 * @interface ChartDataAsyncResponseSchema
 */
export interface ChartDataAsyncResponseSchema {
    /**
     * Unique session async channel ID
     * @type {string}
     * @memberof ChartDataAsyncResponseSchema
     */
    channelId?: string;
    /**
     * Unique async job ID
     * @type {string}
     * @memberof ChartDataAsyncResponseSchema
     */
    jobId?: string;
    /**
     * Unique result URL for fetching async query data
     * @type {string}
     * @memberof ChartDataAsyncResponseSchema
     */
    resultUrl?: string;
    /**
     * Status value for async job
     * @type {string}
     * @memberof ChartDataAsyncResponseSchema
     */
    status?: string;
    /**
     * Requesting user ID
     * @type {string}
     * @memberof ChartDataAsyncResponseSchema
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface ChartDataBoxplotOptionsSchema
 */
export interface ChartDataBoxplotOptionsSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof ChartDataBoxplotOptionsSchema
     */
    groupby?: Array<string>;
    /**
     * Aggregate expressions. Metrics can be passed as both references to datasource metrics (strings), or ad-hoc metricswhich are defined only within the query object. See `ChartDataAdhocMetricSchema` for the structure of ad-hoc metrics. When metrics is undefined or null, the query is executed without a groupby. However, when metrics is an array (length >= 0), a groupby clause is added to the query.
     * @type {Array<any>}
     * @memberof ChartDataBoxplotOptionsSchema
     */
    metrics?: Array<any>;
    /**
     * Upper and lower percentiles for percentile whisker type.
     * @type {any}
     * @memberof ChartDataBoxplotOptionsSchema
     */
    percentiles?: any;
    /**
     * Whisker type. Any numpy function will work.
     * @type {string}
     * @memberof ChartDataBoxplotOptionsSchema
     */
    whiskerType: ChartDataBoxplotOptionsSchema.WhiskerTypeEnum;
}

/**
 * @export
 * @namespace ChartDataBoxplotOptionsSchema
 */
export namespace ChartDataBoxplotOptionsSchema {
    /**
     * @export
     * @enum {string}
     */
    export enum WhiskerTypeEnum {
        Tukey = <any> 'tukey',
        Minmax = <any> 'min/max',
        Percentile = <any> 'percentile'
    }
}
/**
 * 
 * @export
 * @interface ChartDataColumn
 */
export interface ChartDataColumn {
    /**
     * The name of the target column
     * @type {string}
     * @memberof ChartDataColumn
     */
    columnName?: string;
    /**
     * Type of target column
     * @type {string}
     * @memberof ChartDataColumn
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface ChartDataContributionOptionsSchema
 */
export interface ChartDataContributionOptionsSchema {
    /**
     * Should cell values be calculated across the row or column.
     * @type {string}
     * @memberof ChartDataContributionOptionsSchema
     */
    orientation: ChartDataContributionOptionsSchema.OrientationEnum;
}

/**
 * @export
 * @namespace ChartDataContributionOptionsSchema
 */
export namespace ChartDataContributionOptionsSchema {
    /**
     * @export
     * @enum {string}
     */
    export enum OrientationEnum {
        Row = <any> 'row',
        Column = <any> 'column'
    }
}
/**
 * 
 * @export
 * @interface ChartDataDatasource
 */
export interface ChartDataDatasource {
    /**
     * Datasource id
     * @type {number}
     * @memberof ChartDataDatasource
     */
    id: number;
    /**
     * Datasource type
     * @type {string}
     * @memberof ChartDataDatasource
     */
    type?: ChartDataDatasource.TypeEnum;
}

/**
 * @export
 * @namespace ChartDataDatasource
 */
export namespace ChartDataDatasource {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        SlTable = <any> 'sl_table',
        Table = <any> 'table',
        Dataset = <any> 'dataset',
        Query = <any> 'query',
        SavedQuery = <any> 'saved_query',
        View = <any> 'view'
    }
}
/**
 * 
 * @export
 * @interface ChartDataExtras
 */
export interface ChartDataExtras {
    /**
     * HAVING clause to be added to aggregate queries using AND operator.
     * @type {string}
     * @memberof ChartDataExtras
     */
    having?: string;
    /**
     * HAVING filters to be added to legacy Druid datasource queries. This field is deprecated
     * @type {Array<ChartDataFilter>}
     * @memberof ChartDataExtras
     */
    havingDruid?: Array<ChartDataFilter>;
    /**
     * End time for relative time deltas. Default: `config[\"DEFAULT_RELATIVE_START_TIME\"]`
     * @type {string}
     * @memberof ChartDataExtras
     */
    relativeEnd?: ChartDataExtras.RelativeEndEnum;
    /**
     * Start time for relative time deltas. Default: `config[\"DEFAULT_RELATIVE_START_TIME\"]`
     * @type {string}
     * @memberof ChartDataExtras
     */
    relativeStart?: ChartDataExtras.RelativeStartEnum;
    /**
     * To what level of granularity should the temporal column be aggregated. Supports [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) durations.
     * @type {string}
     * @memberof ChartDataExtras
     */
    timeGrainSqla?: ChartDataExtras.TimeGrainSqlaEnum;
    /**
     * WHERE clause to be added to queries using AND operator.
     * @type {string}
     * @memberof ChartDataExtras
     */
    where?: string;
}

/**
 * @export
 * @namespace ChartDataExtras
 */
export namespace ChartDataExtras {
    /**
     * @export
     * @enum {string}
     */
    export enum RelativeEndEnum {
        Today = <any> 'today',
        Now = <any> 'now'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RelativeStartEnum {
        Today = <any> 'today',
        Now = <any> 'now'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TimeGrainSqlaEnum {
        PT1S = <any> 'PT1S',
        PT5S = <any> 'PT5S',
        PT30S = <any> 'PT30S',
        PT1M = <any> 'PT1M',
        PT5M = <any> 'PT5M',
        PT10M = <any> 'PT10M',
        PT15M = <any> 'PT15M',
        PT30M = <any> 'PT30M',
        PT1H = <any> 'PT1H',
        PT6H = <any> 'PT6H',
        P1D = <any> 'P1D',
        P1W = <any> 'P1W',
        P1M = <any> 'P1M',
        P3M = <any> 'P3M',
        P1Y = <any> 'P1Y',
        _19691228T000000ZP1W = <any> '1969-12-28T00:00:00Z/P1W',
        _19691229T000000ZP1W = <any> '1969-12-29T00:00:00Z/P1W',
        P1W19700103T000000Z = <any> 'P1W/1970-01-03T00:00:00Z',
        P1W19700104T000000Z = <any> 'P1W/1970-01-04T00:00:00Z'
    }
}
/**
 * 
 * @export
 * @interface ChartDataFilter
 */
export interface ChartDataFilter {
    /**
     * The column to filter by. Can be either a string (physical or saved expression) or an object (adhoc column)
     * @type {any}
     * @memberof ChartDataFilter
     */
    col: any;
    /**
     * Optional time grain for temporal filters
     * @type {string}
     * @memberof ChartDataFilter
     */
    grain?: string;
    /**
     * Indicates if the filter has been added by a filter component as opposed to being a part of the original query.
     * @type {boolean}
     * @memberof ChartDataFilter
     */
    isExtra?: boolean;
    /**
     * The comparison operator.
     * @type {string}
     * @memberof ChartDataFilter
     */
    op: ChartDataFilter.OpEnum;
    /**
     * The value or values to compare against. Can be a string, integer, decimal, None or list, depending on the operator.
     * @type {any}
     * @memberof ChartDataFilter
     */
    val?: any;
}

/**
 * @export
 * @namespace ChartDataFilter
 */
export namespace ChartDataFilter {
    /**
     * @export
     * @enum {string}
     */
    export enum OpEnum {
        Equal = <any> '==',
        NotEqual = <any> '!=',
        GreaterThan = <any> '>',
        LessThan = <any> '<',
        GreaterThanOrEqualTo = <any> '>=',
        LessThanOrEqualTo = <any> '<=',
        LIKE = <any> 'LIKE',
        ILIKE = <any> 'ILIKE',
        ISNULL = <any> 'IS NULL',
        ISNOTNULL = <any> 'IS NOT NULL',
        IN = <any> 'IN',
        NOTIN = <any> 'NOT IN',
        REGEX = <any> 'REGEX',
        ISTRUE = <any> 'IS TRUE',
        ISFALSE = <any> 'IS FALSE',
        TEMPORALRANGE = <any> 'TEMPORAL_RANGE'
    }
}
/**
 * 
 * @export
 * @interface ChartDataGeodeticParseOptionsSchema
 */
export interface ChartDataGeodeticParseOptionsSchema {
    /**
     * Name of target column for decoded altitude. If omitted, altitude information in geodetic string is ignored.
     * @type {string}
     * @memberof ChartDataGeodeticParseOptionsSchema
     */
    altitude?: string;
    /**
     * Name of source column containing geodetic point strings
     * @type {string}
     * @memberof ChartDataGeodeticParseOptionsSchema
     */
    geodetic: string;
    /**
     * Name of target column for decoded latitude
     * @type {string}
     * @memberof ChartDataGeodeticParseOptionsSchema
     */
    latitude: string;
    /**
     * Name of target column for decoded longitude
     * @type {string}
     * @memberof ChartDataGeodeticParseOptionsSchema
     */
    longitude: string;
}
/**
 * 
 * @export
 * @interface ChartDataGeohashDecodeOptionsSchema
 */
export interface ChartDataGeohashDecodeOptionsSchema {
    /**
     * Name of source column containing geohash string
     * @type {string}
     * @memberof ChartDataGeohashDecodeOptionsSchema
     */
    geohash: string;
    /**
     * Name of target column for decoded latitude
     * @type {string}
     * @memberof ChartDataGeohashDecodeOptionsSchema
     */
    latitude: string;
    /**
     * Name of target column for decoded longitude
     * @type {string}
     * @memberof ChartDataGeohashDecodeOptionsSchema
     */
    longitude: string;
}
/**
 * 
 * @export
 * @interface ChartDataGeohashEncodeOptionsSchema
 */
export interface ChartDataGeohashEncodeOptionsSchema {
    /**
     * Name of target column for encoded geohash string
     * @type {string}
     * @memberof ChartDataGeohashEncodeOptionsSchema
     */
    geohash: string;
    /**
     * Name of source latitude column
     * @type {string}
     * @memberof ChartDataGeohashEncodeOptionsSchema
     */
    latitude: string;
    /**
     * Name of source longitude column
     * @type {string}
     * @memberof ChartDataGeohashEncodeOptionsSchema
     */
    longitude: string;
}
/**
 * 
 * @export
 * @interface ChartDataPivotOptionsSchema
 */
export interface ChartDataPivotOptionsSchema {
    /**
     * The keys are the name of the aggregate column to be created, and the values specify the details of how to apply the aggregation. If an operator requires additional options, these can be passed here to be unpacked in the operator call. The following numpy operators are supported: average, argmin, argmax, cumsum, cumprod, max, mean, median, nansum, nanmin, nanmax, nanmean, nanmedian, min, percentile, prod, product, std, sum, var. Any options required by the operator can be passed to the `options` object.  In the example, a new column `first_quantile` is created based on values in the column `my_col` using the `percentile` operator with the `q=0.25` parameter.
     * @type {any}
     * @memberof ChartDataPivotOptionsSchema
     */
    aggregates?: any;
    /**
     * Value to replace missing pivot columns names with.
     * @type {string}
     * @memberof ChartDataPivotOptionsSchema
     */
    columnFillValue?: string;
    /**
     * Columns to group by on the table columns
     * @type {Array<string>}
     * @memberof ChartDataPivotOptionsSchema
     */
    columns?: Array<string>;
    /**
     * Do not include columns whose entries are all missing (default: `true`).
     * @type {boolean}
     * @memberof ChartDataPivotOptionsSchema
     */
    dropMissingColumns?: boolean;
    /**
     * Name of marginal distribution row/column. (default: `All`)
     * @type {string}
     * @memberof ChartDataPivotOptionsSchema
     */
    marginalDistributionName?: string;
    /**
     * Add totals for row/column. (default: `false`)
     * @type {boolean}
     * @memberof ChartDataPivotOptionsSchema
     */
    marginalDistributions?: boolean;
    /**
     * Value to replace missing values with in aggregate calculations.
     * @type {number}
     * @memberof ChartDataPivotOptionsSchema
     */
    metricFillValue?: number;
}
/**
 * 
 * @export
 * @interface ChartDataPostProcessingOperation
 */
export interface ChartDataPostProcessingOperation {
    /**
     * Post processing operation type
     * @type {string}
     * @memberof ChartDataPostProcessingOperation
     */
    operation: ChartDataPostProcessingOperation.OperationEnum;
    /**
     * Options specifying how to perform the operation. Please refer to the respective post processing operation option schemas. For example, `ChartDataPostProcessingOperationOptions` specifies the required options for the pivot operation.
     * @type {any}
     * @memberof ChartDataPostProcessingOperation
     */
    options?: any;
}

/**
 * @export
 * @namespace ChartDataPostProcessingOperation
 */
export namespace ChartDataPostProcessingOperation {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        Aggregate = <any> 'aggregate',
        Boxplot = <any> 'boxplot',
        Compare = <any> 'compare',
        Contribution = <any> 'contribution',
        Cum = <any> 'cum',
        Diff = <any> 'diff',
        EscapeSeparator = <any> 'escape_separator',
        Flatten = <any> 'flatten',
        GeodeticParse = <any> 'geodetic_parse',
        GeohashDecode = <any> 'geohash_decode',
        GeohashEncode = <any> 'geohash_encode',
        Pivot = <any> 'pivot',
        Prophet = <any> 'prophet',
        Rename = <any> 'rename',
        Resample = <any> 'resample',
        Rolling = <any> 'rolling',
        Select = <any> 'select',
        Sort = <any> 'sort',
        UnescapeSeparator = <any> 'unescape_separator'
    }
}
/**
 * 
 * @export
 * @interface ChartDataProphetOptionsSchema
 */
export interface ChartDataProphetOptionsSchema {
    /**
     * Width of predicted confidence interval
     * @type {number}
     * @memberof ChartDataProphetOptionsSchema
     */
    confidenceInterval: number;
    /**
     * Should monthly seasonality be applied. An integer value will specify Fourier order of seasonality, `None` will automatically detect seasonality.
     * @type {any}
     * @memberof ChartDataProphetOptionsSchema
     */
    monthlySeasonality?: any;
    /**
     * Time periods (in units of `time_grain`) to predict into the future
     * @type {number}
     * @memberof ChartDataProphetOptionsSchema
     */
    periods: number;
    /**
     * Time grain used to specify time period increments in prediction. Supports [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) durations.
     * @type {string}
     * @memberof ChartDataProphetOptionsSchema
     */
    timeGrain: ChartDataProphetOptionsSchema.TimeGrainEnum;
    /**
     * Should weekly seasonality be applied. An integer value will specify Fourier order of seasonality, `None` will automatically detect seasonality.
     * @type {any}
     * @memberof ChartDataProphetOptionsSchema
     */
    weeklySeasonality?: any;
    /**
     * Should yearly seasonality be applied. An integer value will specify Fourier order of seasonality, `None` will automatically detect seasonality.
     * @type {any}
     * @memberof ChartDataProphetOptionsSchema
     */
    yearlySeasonality?: any;
}

/**
 * @export
 * @namespace ChartDataProphetOptionsSchema
 */
export namespace ChartDataProphetOptionsSchema {
    /**
     * @export
     * @enum {string}
     */
    export enum TimeGrainEnum {
        PT1S = <any> 'PT1S',
        PT5S = <any> 'PT5S',
        PT30S = <any> 'PT30S',
        PT1M = <any> 'PT1M',
        PT5M = <any> 'PT5M',
        PT10M = <any> 'PT10M',
        PT15M = <any> 'PT15M',
        PT30M = <any> 'PT30M',
        PT1H = <any> 'PT1H',
        PT6H = <any> 'PT6H',
        P1D = <any> 'P1D',
        P1W = <any> 'P1W',
        P1M = <any> 'P1M',
        P3M = <any> 'P3M',
        P1Y = <any> 'P1Y',
        _19691228T000000ZP1W = <any> '1969-12-28T00:00:00Z/P1W',
        _19691229T000000ZP1W = <any> '1969-12-29T00:00:00Z/P1W',
        P1W19700103T000000Z = <any> 'P1W/1970-01-03T00:00:00Z',
        P1W19700104T000000Z = <any> 'P1W/1970-01-04T00:00:00Z'
    }
}
/**
 * 
 * @export
 * @interface ChartDataQueryContextSchema
 */
export interface ChartDataQueryContextSchema {
    /**
     * Override the default cache timeout
     * @type {number}
     * @memberof ChartDataQueryContextSchema
     */
    customCacheTimeout?: number;
    /**
     * 
     * @type {ChartDataDatasource}
     * @memberof ChartDataQueryContextSchema
     */
    datasource?: ChartDataDatasource;
    /**
     * Should the queries be forced to load from the source. Default: `false`
     * @type {boolean}
     * @memberof ChartDataQueryContextSchema
     */
    force?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ChartDataQueryContextSchema
     */
    formData?: any;
    /**
     * 
     * @type {Array<ChartDataQueryObject>}
     * @memberof ChartDataQueryContextSchema
     */
    queries?: Array<ChartDataQueryObject>;
    /**
     * 
     * @type {any}
     * @memberof ChartDataQueryContextSchema
     */
    resultFormat?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartDataQueryContextSchema
     */
    resultType?: any;
}
/**
 * 
 * @export
 * @interface ChartDataQueryObject
 */
export interface ChartDataQueryObject {
    /**
     * Annotation layers to apply to chart
     * @type {Array<AnnotationLayer>}
     * @memberof ChartDataQueryObject
     */
    annotationLayers?: Array<AnnotationLayer>;
    /**
     * A mapping of temporal extras that have been applied to the query
     * @type {any}
     * @memberof ChartDataQueryObject
     */
    appliedTimeExtras?: any;
    /**
     * Add fetch values predicate (where clause) to query if defined in datasource
     * @type {boolean}
     * @memberof ChartDataQueryObject
     */
    applyFetchValuesPredicate?: boolean;
    /**
     * Columns which to select in the query.
     * @type {Array<any>}
     * @memberof ChartDataQueryObject
     */
    columns?: Array<any>;
    /**
     * 
     * @type {ChartDataDatasource}
     * @memberof ChartDataQueryObject
     */
    datasource?: ChartDataDatasource;
    /**
     * Starting point for time grain counting on legacy Druid datasources. Used to change e.g. Monday/Sunday first-day-of-week. This field is deprecated and should be passed to `extras` as `druid_time_origin`.
     * @type {string}
     * @memberof ChartDataQueryObject
     */
    druidTimeOrigin?: string;
    /**
     * Extra parameters to add to the query.
     * @type {ChartDataExtras}
     * @memberof ChartDataQueryObject
     */
    extras?: ChartDataExtras;
    /**
     * 
     * @type {Array<ChartDataFilter>}
     * @memberof ChartDataQueryObject
     */
    filters?: Array<ChartDataFilter>;
    /**
     * Name of temporal column used for time filtering. For legacy Druid datasources this defines the time grain.
     * @type {string}
     * @memberof ChartDataQueryObject
     */
    granularity?: string;
    /**
     * Name of temporal column used for time filtering for SQL datasources. This field is deprecated, use `granularity` instead.
     * @type {string}
     * @memberof ChartDataQueryObject
     */
    granularitySqla?: string;
    /**
     * Columns by which to group the query. This field is deprecated, use `columns` instead.
     * @type {Array<any>}
     * @memberof ChartDataQueryObject
     */
    groupby?: Array<any>;
    /**
     * HAVING clause to be added to aggregate queries using AND operator. This field is deprecated and should be passed to `extras`.
     * @type {string}
     * @memberof ChartDataQueryObject
     */
    having?: string;
    /**
     * HAVING filters to be added to legacy Druid datasource queries. This field is deprecated and should be passed to `extras` as `having_druid`.
     * @type {Array<ChartDataFilter>}
     * @memberof ChartDataQueryObject
     */
    havingFilters?: Array<ChartDataFilter>;
    /**
     * Should the rowcount of the actual query be returned
     * @type {boolean}
     * @memberof ChartDataQueryObject
     */
    isRowcount?: boolean;
    /**
     * Is the `query_object` a timeseries.
     * @type {boolean}
     * @memberof ChartDataQueryObject
     */
    isTimeseries?: boolean;
    /**
     * Aggregate expressions. Metrics can be passed as both references to datasource metrics (strings), or ad-hoc metricswhich are defined only within the query object. See `ChartDataAdhocMetricSchema` for the structure of ad-hoc metrics.
     * @type {Array<any>}
     * @memberof ChartDataQueryObject
     */
    metrics?: Array<any>;
    /**
     * Reverse order. Default: `false`
     * @type {boolean}
     * @memberof ChartDataQueryObject
     */
    orderDesc?: boolean;
    /**
     * Expects a list of lists where the first element is the column name which to sort by, and the second element is a boolean.
     * @type {Array<any>}
     * @memberof ChartDataQueryObject
     */
    orderby?: Array<any>;
    /**
     * Post processing operations to be applied to the result set. Operations are applied to the result set in sequential order.
     * @type {Array<ChartDataPostProcessingOperation>}
     * @memberof ChartDataQueryObject
     */
    postProcessing?: Array<ChartDataPostProcessingOperation>;
    /**
     * 
     * @type {any}
     * @memberof ChartDataQueryObject
     */
    resultType?: any;
    /**
     * Maximum row count (0=disabled). Default: `config[\"ROW_LIMIT\"]`
     * @type {number}
     * @memberof ChartDataQueryObject
     */
    rowLimit?: number;
    /**
     * Number of rows to skip. Default: `0`
     * @type {number}
     * @memberof ChartDataQueryObject
     */
    rowOffset?: number;
    /**
     * Columns to use when limiting series count. All columns must be present in the `columns` property. Requires `series_limit` and `series_limit_metric` to be set.
     * @type {Array<any>}
     * @memberof ChartDataQueryObject
     */
    seriesColumns?: Array<any>;
    /**
     * Maximum number of series. Requires `series` and `series_limit_metric` to be set.
     * @type {number}
     * @memberof ChartDataQueryObject
     */
    seriesLimit?: number;
    /**
     * Metric used to limit timeseries queries by. Requires `series` and `series_limit` to be set.
     * @type {any}
     * @memberof ChartDataQueryObject
     */
    seriesLimitMetric?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChartDataQueryObject
     */
    timeOffsets?: Array<string>;
    /**
     * A time rage, either expressed as a colon separated string `since : until` or human readable freeform. Valid formats for `since` and `until` are:  - ISO 8601 - X days/years/hours/day/year/weeks - X days/years/hours/day/year/weeks ago - X days/years/hours/day/year/weeks from now  Additionally, the following freeform can be used:  - Last day - Last week - Last month - Last quarter - Last year - No filter - Last X seconds/minutes/hours/days/weeks/months/years - Next X seconds/minutes/hours/days/weeks/months/years 
     * @type {string}
     * @memberof ChartDataQueryObject
     */
    timeRange?: string;
    /**
     * A human-readable date/time string. Please refer to [parsdatetime](https://github.com/bear/parsedatetime) documentation for details on valid values.
     * @type {string}
     * @memberof ChartDataQueryObject
     */
    timeShift?: string;
    /**
     * Maximum row count for timeseries queries. This field is deprecated, use `series_limit` instead.Default: `0`
     * @type {number}
     * @memberof ChartDataQueryObject
     */
    timeseriesLimit?: number;
    /**
     * Metric used to limit timeseries queries by. This field is deprecated, use `series_limit_metric` instead.
     * @type {any}
     * @memberof ChartDataQueryObject
     */
    timeseriesLimitMetric?: any;
    /**
     * Optional query parameters passed to a dashboard or Explore  view
     * @type {{ [key: string]: string; }}
     * @memberof ChartDataQueryObject
     */
    urlParams?: { [key: string]: string; };
    /**
     * WHERE clause to be added to queries using AND operator.This field is deprecated and should be passed to `extras`.
     * @type {string}
     * @memberof ChartDataQueryObject
     */
    where?: string;
}
/**
 * 
 * @export
 * @interface ChartDataResponseResult
 */
export interface ChartDataResponseResult {
    /**
     * All requested annotation data
     * @type {Array<{ [key: string]: string; }>}
     * @memberof ChartDataResponseResult
     */
    annotationData?: Array<{ [key: string]: string; }>;
    /**
     * A list with applied filters
     * @type {Array<any>}
     * @memberof ChartDataResponseResult
     */
    appliedFilters?: Array<any>;
    /**
     * Unique cache key for query object
     * @type {string}
     * @memberof ChartDataResponseResult
     */
    cacheKey: string;
    /**
     * Cache timeout in following order: custom timeout, datasource timeout, cache default timeout, config default cache timeout.
     * @type {number}
     * @memberof ChartDataResponseResult
     */
    cacheTimeout: number;
    /**
     * Cache timestamp
     * @type {string}
     * @memberof ChartDataResponseResult
     */
    cachedDttm: string;
    /**
     * A list of column names
     * @type {Array<string>}
     * @memberof ChartDataResponseResult
     */
    colnames?: Array<string>;
    /**
     * A list of generic data types of each column
     * @type {Array<number>}
     * @memberof ChartDataResponseResult
     */
    coltypes?: Array<number>;
    /**
     * A list with results
     * @type {Array<any>}
     * @memberof ChartDataResponseResult
     */
    data?: Array<any>;
    /**
     * Error
     * @type {string}
     * @memberof ChartDataResponseResult
     */
    error?: string;
    /**
     * Start timestamp of time range
     * @type {number}
     * @memberof ChartDataResponseResult
     */
    fromDttm?: number;
    /**
     * Is the result cached
     * @type {boolean}
     * @memberof ChartDataResponseResult
     */
    isCached: boolean;
    /**
     * The executed query statement
     * @type {string}
     * @memberof ChartDataResponseResult
     */
    query: string;
    /**
     * A list with rejected filters
     * @type {Array<any>}
     * @memberof ChartDataResponseResult
     */
    rejectedFilters?: Array<any>;
    /**
     * Amount of rows in result set
     * @type {number}
     * @memberof ChartDataResponseResult
     */
    rowcount?: number;
    /**
     * Stacktrace if there was an error
     * @type {string}
     * @memberof ChartDataResponseResult
     */
    stacktrace?: string;
    /**
     * Status of the query
     * @type {string}
     * @memberof ChartDataResponseResult
     */
    status?: ChartDataResponseResult.StatusEnum;
    /**
     * End timestamp of time range
     * @type {number}
     * @memberof ChartDataResponseResult
     */
    toDttm?: number;
}

/**
 * @export
 * @namespace ChartDataResponseResult
 */
export namespace ChartDataResponseResult {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Stopped = <any> 'stopped',
        Failed = <any> 'failed',
        Pending = <any> 'pending',
        Running = <any> 'running',
        Scheduled = <any> 'scheduled',
        Success = <any> 'success',
        TimedOut = <any> 'timed_out'
    }
}
/**
 * 
 * @export
 * @interface ChartDataResponseSchema
 */
export interface ChartDataResponseSchema {
    /**
     * A list of results for each corresponding query in the request.
     * @type {Array<ChartDataResponseResult>}
     * @memberof ChartDataResponseSchema
     */
    result?: Array<ChartDataResponseResult>;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGet
 */
export interface ChartDataRestApiGet {
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGet
     */
    cacheTimeout?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGet
     */
    certificationDetails?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGet
     */
    certifiedBy?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGet
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {ChartDataRestApiGetDashboard}
     * @memberof ChartDataRestApiGet
     */
    dashboards?: ChartDataRestApiGetDashboard;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGet
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ChartDataRestApiGet
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {ChartDataRestApiGetUser}
     * @memberof ChartDataRestApiGet
     */
    owners?: ChartDataRestApiGetUser;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGet
     */
    params?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGet
     */
    queryContext?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGet
     */
    sliceName?: string;
    /**
     * 
     * @type {ChartDataRestApiGetTag}
     * @memberof ChartDataRestApiGet
     */
    tags?: ChartDataRestApiGetTag;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGet
     */
    thumbnailUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGet
     */
    url?: any;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGet
     */
    vizType?: string;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGetDashboard
 */
export interface ChartDataRestApiGetDashboard {
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetDashboard
     */
    dashboardTitle?: string;
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGetDashboard
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetDashboard
     */
    jsonMetadata?: string;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGetList
 */
export interface ChartDataRestApiGetList {
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGetList
     */
    cacheTimeout?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetList
     */
    certificationDetails?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetList
     */
    certifiedBy?: string;
    /**
     * 
     * @type {ChartDataRestApiGetListUser}
     * @memberof ChartDataRestApiGetList
     */
    changedBy?: ChartDataRestApiGetListUser;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    changedByName?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    changedByUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    changedOnDttm?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    changedOnUtc?: any;
    /**
     * 
     * @type {ChartDataRestApiGetListUser3}
     * @memberof ChartDataRestApiGetList
     */
    createdBy?: ChartDataRestApiGetListUser3;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    createdByName?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    createdByUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    createdOnDeltaHumanized?: any;
    /**
     * 
     * @type {ChartDataRestApiGetListDashboard}
     * @memberof ChartDataRestApiGetList
     */
    dashboards?: ChartDataRestApiGetListDashboard;
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGetList
     */
    datasourceId?: number;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    datasourceNameText?: any;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetList
     */
    datasourceType?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    datasourceUrl?: any;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetList
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    descriptionMarkeddown?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    editUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    formData?: any;
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ChartDataRestApiGetList
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof ChartDataRestApiGetList
     */
    lastSavedAt?: Date;
    /**
     * 
     * @type {ChartDataRestApiGetListUser1}
     * @memberof ChartDataRestApiGetList
     */
    lastSavedBy?: ChartDataRestApiGetListUser1;
    /**
     * 
     * @type {ChartDataRestApiGetListUser2}
     * @memberof ChartDataRestApiGetList
     */
    owners?: ChartDataRestApiGetListUser2;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetList
     */
    params?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetList
     */
    sliceName?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    sliceUrl?: any;
    /**
     * 
     * @type {ChartDataRestApiGetListSqlaTable}
     * @memberof ChartDataRestApiGetList
     */
    table?: ChartDataRestApiGetListSqlaTable;
    /**
     * 
     * @type {ChartDataRestApiGetListTag}
     * @memberof ChartDataRestApiGetList
     */
    tags?: ChartDataRestApiGetListTag;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    thumbnailUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetList
     */
    url?: any;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetList
     */
    vizType?: string;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGetListDashboard
 */
export interface ChartDataRestApiGetListDashboard {
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListDashboard
     */
    dashboardTitle?: string;
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGetListDashboard
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGetListSqlaTable
 */
export interface ChartDataRestApiGetListSqlaTable {
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListSqlaTable
     */
    defaultEndpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListSqlaTable
     */
    tableName: string;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGetListTag
 */
export interface ChartDataRestApiGetListTag {
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGetListTag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListTag
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetListTag
     */
    type?: any;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGetListUser
 */
export interface ChartDataRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGetListUser1
 */
export interface ChartDataRestApiGetListUser1 {
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListUser1
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGetListUser1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListUser1
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGetListUser2
 */
export interface ChartDataRestApiGetListUser2 {
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListUser2
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGetListUser2
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListUser2
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGetListUser3
 */
export interface ChartDataRestApiGetListUser3 {
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListUser3
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGetListUser3
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetListUser3
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGetTag
 */
export interface ChartDataRestApiGetTag {
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGetTag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetTag
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartDataRestApiGetTag
     */
    type?: any;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiGetUser
 */
export interface ChartDataRestApiGetUser {
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetUser
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof ChartDataRestApiGetUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiGetUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ChartDataRestApiPost
 */
export interface ChartDataRestApiPost {
    /**
     * Duration (in seconds) of the caching timeout for this chart. Note this defaults to the datasource/table timeout if undefined.
     * @type {number}
     * @memberof ChartDataRestApiPost
     */
    cacheTimeout?: number;
    /**
     * Details of the certification
     * @type {string}
     * @memberof ChartDataRestApiPost
     */
    certificationDetails?: string;
    /**
     * Person or group that has certified this chart
     * @type {string}
     * @memberof ChartDataRestApiPost
     */
    certifiedBy?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChartDataRestApiPost
     */
    dashboards?: Array<number>;
    /**
     * The id of the dataset/datasource this new chart will use. A complete datasource identification needs `datasouce_id` and `datasource_type`.
     * @type {number}
     * @memberof ChartDataRestApiPost
     */
    datasourceId: number;
    /**
     * The datasource name.
     * @type {string}
     * @memberof ChartDataRestApiPost
     */
    datasourceName?: string;
    /**
     * The type of dataset/datasource identified on `datasource_id`.
     * @type {string}
     * @memberof ChartDataRestApiPost
     */
    datasourceType: ChartDataRestApiPost.DatasourceTypeEnum;
    /**
     * A description of the chart propose.
     * @type {string}
     * @memberof ChartDataRestApiPost
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiPost
     */
    externalUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChartDataRestApiPost
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChartDataRestApiPost
     */
    owners?: Array<number>;
    /**
     * Parameters are generated dynamically when clicking the save or overwrite button in the explore view. This JSON object for power users who may want to alter specific parameters.
     * @type {string}
     * @memberof ChartDataRestApiPost
     */
    params?: string;
    /**
     * The query context represents the queries that need to run in order to generate the data the visualization, and in what format the data should be returned.
     * @type {string}
     * @memberof ChartDataRestApiPost
     */
    queryContext?: string;
    /**
     * The query context generation represents whether the query_contextis user generated or not so that it does not update user modfiedstate.
     * @type {boolean}
     * @memberof ChartDataRestApiPost
     */
    queryContextGeneration?: boolean;
    /**
     * The name of the chart.
     * @type {string}
     * @memberof ChartDataRestApiPost
     */
    sliceName: string;
    /**
     * The type of chart visualization used.
     * @type {string}
     * @memberof ChartDataRestApiPost
     */
    vizType?: string;
}

/**
 * @export
 * @namespace ChartDataRestApiPost
 */
export namespace ChartDataRestApiPost {
    /**
     * @export
     * @enum {string}
     */
    export enum DatasourceTypeEnum {
        SlTable = <any> 'sl_table',
        Table = <any> 'table',
        Dataset = <any> 'dataset',
        Query = <any> 'query',
        SavedQuery = <any> 'saved_query',
        View = <any> 'view'
    }
}
/**
 * 
 * @export
 * @interface ChartDataRestApiPut
 */
export interface ChartDataRestApiPut {
    /**
     * Duration (in seconds) of the caching timeout for this chart. Note this defaults to the datasource/table timeout if undefined.
     * @type {number}
     * @memberof ChartDataRestApiPut
     */
    cacheTimeout?: number;
    /**
     * Details of the certification
     * @type {string}
     * @memberof ChartDataRestApiPut
     */
    certificationDetails?: string;
    /**
     * Person or group that has certified this chart
     * @type {string}
     * @memberof ChartDataRestApiPut
     */
    certifiedBy?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChartDataRestApiPut
     */
    dashboards?: Array<number>;
    /**
     * The id of the dataset/datasource this new chart will use. A complete datasource identification needs `datasouce_id` and `datasource_type`.
     * @type {number}
     * @memberof ChartDataRestApiPut
     */
    datasourceId?: number;
    /**
     * The type of dataset/datasource identified on `datasource_id`.
     * @type {string}
     * @memberof ChartDataRestApiPut
     */
    datasourceType?: ChartDataRestApiPut.DatasourceTypeEnum;
    /**
     * A description of the chart propose.
     * @type {string}
     * @memberof ChartDataRestApiPut
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataRestApiPut
     */
    externalUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChartDataRestApiPut
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChartDataRestApiPut
     */
    owners?: Array<number>;
    /**
     * Parameters are generated dynamically when clicking the save or overwrite button in the explore view. This JSON object for power users who may want to alter specific parameters.
     * @type {string}
     * @memberof ChartDataRestApiPut
     */
    params?: string;
    /**
     * The query context represents the queries that need to run in order to generate the data the visualization, and in what format the data should be returned.
     * @type {string}
     * @memberof ChartDataRestApiPut
     */
    queryContext?: string;
    /**
     * The query context generation represents whether the query_contextis user generated or not so that it does not update user modfiedstate.
     * @type {boolean}
     * @memberof ChartDataRestApiPut
     */
    queryContextGeneration?: boolean;
    /**
     * The name of the chart.
     * @type {string}
     * @memberof ChartDataRestApiPut
     */
    sliceName?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ChartDataRestApiPut
     */
    tags?: Array<Tag>;
    /**
     * The type of chart visualization used.
     * @type {string}
     * @memberof ChartDataRestApiPut
     */
    vizType?: string;
}

/**
 * @export
 * @namespace ChartDataRestApiPut
 */
export namespace ChartDataRestApiPut {
    /**
     * @export
     * @enum {string}
     */
    export enum DatasourceTypeEnum {
        SlTable = <any> 'sl_table',
        Table = <any> 'table',
        Dataset = <any> 'dataset',
        Query = <any> 'query',
        SavedQuery = <any> 'saved_query',
        View = <any> 'view'
    }
}
/**
 * 
 * @export
 * @interface ChartDataRollingOptionsSchema
 */
export interface ChartDataRollingOptionsSchema {
    /**
     * Should the label be at the center of the window.Default: `false`
     * @type {boolean}
     * @memberof ChartDataRollingOptionsSchema
     */
    center?: boolean;
    /**
     * The minimum amount of periods required for a row to be included in the result set.
     * @type {number}
     * @memberof ChartDataRollingOptionsSchema
     */
    minPeriods?: number;
    /**
     * Type of rolling window. Any numpy function will work.
     * @type {string}
     * @memberof ChartDataRollingOptionsSchema
     */
    rollingType: ChartDataRollingOptionsSchema.RollingTypeEnum;
    /**
     * Optional options to pass to rolling method. Needed for e.g. quantile operation.
     * @type {any}
     * @memberof ChartDataRollingOptionsSchema
     */
    rollingTypeOptions?: any;
    /**
     * Type of window function. See [SciPy window functions](https://docs.scipy.org/doc/scipy/reference /signal.windows.html#module-scipy.signal.windows) for more details. Some window functions require passing additional parameters to `rolling_type_options`. For instance, to use `gaussian`, the parameter `std` needs to be provided.
     * @type {string}
     * @memberof ChartDataRollingOptionsSchema
     */
    winType?: ChartDataRollingOptionsSchema.WinTypeEnum;
    /**
     * Size of the rolling window in days.
     * @type {number}
     * @memberof ChartDataRollingOptionsSchema
     */
    window: number;
}

/**
 * @export
 * @namespace ChartDataRollingOptionsSchema
 */
export namespace ChartDataRollingOptionsSchema {
    /**
     * @export
     * @enum {string}
     */
    export enum RollingTypeEnum {
        Average = <any> 'average',
        Argmin = <any> 'argmin',
        Argmax = <any> 'argmax',
        Cumsum = <any> 'cumsum',
        Cumprod = <any> 'cumprod',
        Max = <any> 'max',
        Mean = <any> 'mean',
        Median = <any> 'median',
        Nansum = <any> 'nansum',
        Nanmin = <any> 'nanmin',
        Nanmax = <any> 'nanmax',
        Nanmean = <any> 'nanmean',
        Nanmedian = <any> 'nanmedian',
        Nanpercentile = <any> 'nanpercentile',
        Min = <any> 'min',
        Percentile = <any> 'percentile',
        Prod = <any> 'prod',
        Product = <any> 'product',
        Std = <any> 'std',
        Sum = <any> 'sum',
        Var = <any> 'var'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WinTypeEnum {
        Boxcar = <any> 'boxcar',
        Triang = <any> 'triang',
        Blackman = <any> 'blackman',
        Hamming = <any> 'hamming',
        Bartlett = <any> 'bartlett',
        Parzen = <any> 'parzen',
        Bohman = <any> 'bohman',
        Blackmanharris = <any> 'blackmanharris',
        Nuttall = <any> 'nuttall',
        Barthann = <any> 'barthann',
        Kaiser = <any> 'kaiser',
        Gaussian = <any> 'gaussian',
        GeneralGaussian = <any> 'general_gaussian',
        Slepian = <any> 'slepian',
        Exponential = <any> 'exponential'
    }
}
/**
 * 
 * @export
 * @interface ChartDataSelectOptionsSchema
 */
export interface ChartDataSelectOptionsSchema {
    /**
     * Columns which to select from the input data, in the desired order. If columns are renamed, the original column name should be referenced here.
     * @type {Array<string>}
     * @memberof ChartDataSelectOptionsSchema
     */
    columns?: Array<string>;
    /**
     * Columns to exclude from selection.
     * @type {Array<string>}
     * @memberof ChartDataSelectOptionsSchema
     */
    exclude?: Array<string>;
    /**
     * columns which to rename, mapping source column to target column. For instance, `{'y': 'y2'}` will rename the column `y` to `y2`.
     * @type {Array<any>}
     * @memberof ChartDataSelectOptionsSchema
     */
    rename?: Array<any>;
}
/**
 * 
 * @export
 * @interface ChartDataSortOptionsSchema
 */
export interface ChartDataSortOptionsSchema {
    /**
     * The keys are the name of the aggregate column to be created, and the values specify the details of how to apply the aggregation. If an operator requires additional options, these can be passed here to be unpacked in the operator call. The following numpy operators are supported: average, argmin, argmax, cumsum, cumprod, max, mean, median, nansum, nanmin, nanmax, nanmean, nanmedian, min, percentile, prod, product, std, sum, var. Any options required by the operator can be passed to the `options` object.  In the example, a new column `first_quantile` is created based on values in the column `my_col` using the `percentile` operator with the `q=0.25` parameter.
     * @type {any}
     * @memberof ChartDataSortOptionsSchema
     */
    aggregates?: any;
    /**
     * columns by by which to sort. The key specifies the column name, value specifies if sorting in ascending order.
     * @type {any}
     * @memberof ChartDataSortOptionsSchema
     */
    columns: any;
}
/**
 * 
 * @export
 * @interface ChartEntityResponseSchema
 */
export interface ChartEntityResponseSchema {
    /**
     * Duration (in seconds) of the caching timeout for this chart. Note this defaults to the datasource/table timeout if undefined.
     * @type {number}
     * @memberof ChartEntityResponseSchema
     */
    cacheTimeout?: number;
    /**
     * Details of the certification
     * @type {string}
     * @memberof ChartEntityResponseSchema
     */
    certificationDetails?: string;
    /**
     * Person or group that has certified this chart
     * @type {string}
     * @memberof ChartEntityResponseSchema
     */
    certifiedBy?: string;
    /**
     * The ISO date that the chart was last changed.
     * @type {string}
     * @memberof ChartEntityResponseSchema
     */
    changedOn?: string;
    /**
     * A description of the chart propose.
     * @type {string}
     * @memberof ChartEntityResponseSchema
     */
    description?: string;
    /**
     * Sanitized HTML version of the chart description.
     * @type {string}
     * @memberof ChartEntityResponseSchema
     */
    descriptionMarkeddown?: string;
    /**
     * Form data from the Explore controls used to form the chart's data query.
     * @type {any}
     * @memberof ChartEntityResponseSchema
     */
    formData?: any;
    /**
     * The id of the chart.
     * @type {number}
     * @memberof ChartEntityResponseSchema
     */
    id?: number;
    /**
     * The name of the chart.
     * @type {string}
     * @memberof ChartEntityResponseSchema
     */
    sliceName?: string;
    /**
     * The URL of the chart.
     * @type {string}
     * @memberof ChartEntityResponseSchema
     */
    sliceUrl?: string;
}
/**
 * 
 * @export
 * @interface ChartFavStarResponseResult
 */
export interface ChartFavStarResponseResult {
    /**
     * The Chart id
     * @type {number}
     * @memberof ChartFavStarResponseResult
     */
    id?: number;
    /**
     * The FaveStar value
     * @type {boolean}
     * @memberof ChartFavStarResponseResult
     */
    value?: boolean;
}
/**
 * 
 * @export
 * @interface ChartGetDatasourceObjectDataResponse
 */
export interface ChartGetDatasourceObjectDataResponse {
    /**
     * The datasource identifier
     * @type {number}
     * @memberof ChartGetDatasourceObjectDataResponse
     */
    datasourceId?: number;
    /**
     * The datasource type
     * @type {number}
     * @memberof ChartGetDatasourceObjectDataResponse
     */
    datasourceType?: number;
}
/**
 * 
 * @export
 * @interface ChartGetDatasourceObjectResponse
 */
export interface ChartGetDatasourceObjectResponse {
    /**
     * The name of the datasource
     * @type {string}
     * @memberof ChartGetDatasourceObjectResponse
     */
    label?: string;
    /**
     * 
     * @type {ChartGetDatasourceObjectDataResponse}
     * @memberof ChartGetDatasourceObjectResponse
     */
    value?: ChartGetDatasourceObjectDataResponse;
}
/**
 * 
 * @export
 * @interface ChartGetDatasourceResponseSchema
 */
export interface ChartGetDatasourceResponseSchema {
    /**
     * The total number of datasources
     * @type {number}
     * @memberof ChartGetDatasourceResponseSchema
     */
    count?: number;
    /**
     * 
     * @type {ChartGetDatasourceObjectResponse}
     * @memberof ChartGetDatasourceResponseSchema
     */
    result?: ChartGetDatasourceObjectResponse;
}
/**
 * 
 * @export
 * @interface ChartImportBody
 */
export interface ChartImportBody {
    /**
     * upload file (ZIP)
     * @type {Blob}
     * @memberof ChartImportBody
     */
    formData?: Blob;
    /**
     * overwrite existing charts?
     * @type {boolean}
     * @memberof ChartImportBody
     */
    overwrite?: boolean;
    /**
     * JSON map of passwords for each featured database in the ZIP file. If the ZIP includes a database config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof ChartImportBody
     */
    passwords?: string;
    /**
     * JSON map of passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof ChartImportBody
     */
    sshTunnelPasswords?: string;
    /**
     * JSON map of private_key_passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key_password\"}`.
     * @type {string}
     * @memberof ChartImportBody
     */
    sshTunnelPrivateKeyPasswords?: string;
    /**
     * JSON map of private_keys for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key\"}`.
     * @type {string}
     * @memberof ChartImportBody
     */
    sshTunnelPrivateKeys?: string;
}
/**
 * 
 * @export
 * @interface ChartRestApiGet
 */
export interface ChartRestApiGet {
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGet
     */
    cacheTimeout?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGet
     */
    certificationDetails?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGet
     */
    certifiedBy?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGet
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {ChartRestApiGetDashboard}
     * @memberof ChartRestApiGet
     */
    dashboards?: ChartRestApiGetDashboard;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGet
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ChartRestApiGet
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {ChartRestApiGetUser}
     * @memberof ChartRestApiGet
     */
    owners?: ChartRestApiGetUser;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGet
     */
    params?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGet
     */
    queryContext?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGet
     */
    sliceName?: string;
    /**
     * 
     * @type {ChartRestApiGetTag}
     * @memberof ChartRestApiGet
     */
    tags?: ChartRestApiGetTag;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGet
     */
    thumbnailUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGet
     */
    url?: any;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGet
     */
    vizType?: string;
}
/**
 * 
 * @export
 * @interface ChartRestApiGetDashboard
 */
export interface ChartRestApiGetDashboard {
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetDashboard
     */
    dashboardTitle?: string;
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGetDashboard
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetDashboard
     */
    jsonMetadata?: string;
}
/**
 * 
 * @export
 * @interface ChartRestApiGetList
 */
export interface ChartRestApiGetList {
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGetList
     */
    cacheTimeout?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetList
     */
    certificationDetails?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetList
     */
    certifiedBy?: string;
    /**
     * 
     * @type {ChartRestApiGetListUser}
     * @memberof ChartRestApiGetList
     */
    changedBy?: ChartRestApiGetListUser;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    changedByName?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    changedByUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    changedOnDttm?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    changedOnUtc?: any;
    /**
     * 
     * @type {ChartRestApiGetListUser3}
     * @memberof ChartRestApiGetList
     */
    createdBy?: ChartRestApiGetListUser3;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    createdByName?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    createdByUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    createdOnDeltaHumanized?: any;
    /**
     * 
     * @type {ChartRestApiGetListDashboard}
     * @memberof ChartRestApiGetList
     */
    dashboards?: ChartRestApiGetListDashboard;
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGetList
     */
    datasourceId?: number;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    datasourceNameText?: any;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetList
     */
    datasourceType?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    datasourceUrl?: any;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetList
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    descriptionMarkeddown?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    editUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    formData?: any;
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ChartRestApiGetList
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof ChartRestApiGetList
     */
    lastSavedAt?: Date;
    /**
     * 
     * @type {ChartRestApiGetListUser1}
     * @memberof ChartRestApiGetList
     */
    lastSavedBy?: ChartRestApiGetListUser1;
    /**
     * 
     * @type {ChartRestApiGetListUser2}
     * @memberof ChartRestApiGetList
     */
    owners?: ChartRestApiGetListUser2;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetList
     */
    params?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetList
     */
    sliceName?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    sliceUrl?: any;
    /**
     * 
     * @type {ChartRestApiGetListSqlaTable}
     * @memberof ChartRestApiGetList
     */
    table?: ChartRestApiGetListSqlaTable;
    /**
     * 
     * @type {ChartRestApiGetListTag}
     * @memberof ChartRestApiGetList
     */
    tags?: ChartRestApiGetListTag;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    thumbnailUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetList
     */
    url?: any;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetList
     */
    vizType?: string;
}
/**
 * 
 * @export
 * @interface ChartRestApiGetListDashboard
 */
export interface ChartRestApiGetListDashboard {
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListDashboard
     */
    dashboardTitle?: string;
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGetListDashboard
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ChartRestApiGetListSqlaTable
 */
export interface ChartRestApiGetListSqlaTable {
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListSqlaTable
     */
    defaultEndpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListSqlaTable
     */
    tableName: string;
}
/**
 * 
 * @export
 * @interface ChartRestApiGetListTag
 */
export interface ChartRestApiGetListTag {
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGetListTag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListTag
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetListTag
     */
    type?: any;
}
/**
 * 
 * @export
 * @interface ChartRestApiGetListUser
 */
export interface ChartRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ChartRestApiGetListUser1
 */
export interface ChartRestApiGetListUser1 {
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListUser1
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGetListUser1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListUser1
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ChartRestApiGetListUser2
 */
export interface ChartRestApiGetListUser2 {
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListUser2
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGetListUser2
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListUser2
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ChartRestApiGetListUser3
 */
export interface ChartRestApiGetListUser3 {
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListUser3
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGetListUser3
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetListUser3
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ChartRestApiGetTag
 */
export interface ChartRestApiGetTag {
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGetTag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetTag
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof ChartRestApiGetTag
     */
    type?: any;
}
/**
 * 
 * @export
 * @interface ChartRestApiGetUser
 */
export interface ChartRestApiGetUser {
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetUser
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof ChartRestApiGetUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiGetUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ChartRestApiPost
 */
export interface ChartRestApiPost {
    /**
     * Duration (in seconds) of the caching timeout for this chart. Note this defaults to the datasource/table timeout if undefined.
     * @type {number}
     * @memberof ChartRestApiPost
     */
    cacheTimeout?: number;
    /**
     * Details of the certification
     * @type {string}
     * @memberof ChartRestApiPost
     */
    certificationDetails?: string;
    /**
     * Person or group that has certified this chart
     * @type {string}
     * @memberof ChartRestApiPost
     */
    certifiedBy?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChartRestApiPost
     */
    dashboards?: Array<number>;
    /**
     * The id of the dataset/datasource this new chart will use. A complete datasource identification needs `datasouce_id` and `datasource_type`.
     * @type {number}
     * @memberof ChartRestApiPost
     */
    datasourceId: number;
    /**
     * The datasource name.
     * @type {string}
     * @memberof ChartRestApiPost
     */
    datasourceName?: string;
    /**
     * The type of dataset/datasource identified on `datasource_id`.
     * @type {string}
     * @memberof ChartRestApiPost
     */
    datasourceType: ChartRestApiPost.DatasourceTypeEnum;
    /**
     * A description of the chart propose.
     * @type {string}
     * @memberof ChartRestApiPost
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiPost
     */
    externalUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChartRestApiPost
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChartRestApiPost
     */
    owners?: Array<number>;
    /**
     * Parameters are generated dynamically when clicking the save or overwrite button in the explore view. This JSON object for power users who may want to alter specific parameters.
     * @type {string}
     * @memberof ChartRestApiPost
     */
    params?: string;
    /**
     * The query context represents the queries that need to run in order to generate the data the visualization, and in what format the data should be returned.
     * @type {string}
     * @memberof ChartRestApiPost
     */
    queryContext?: string;
    /**
     * The query context generation represents whether the query_contextis user generated or not so that it does not update user modfiedstate.
     * @type {boolean}
     * @memberof ChartRestApiPost
     */
    queryContextGeneration?: boolean;
    /**
     * The name of the chart.
     * @type {string}
     * @memberof ChartRestApiPost
     */
    sliceName: string;
    /**
     * The type of chart visualization used.
     * @type {string}
     * @memberof ChartRestApiPost
     */
    vizType?: string;
}

/**
 * @export
 * @namespace ChartRestApiPost
 */
export namespace ChartRestApiPost {
    /**
     * @export
     * @enum {string}
     */
    export enum DatasourceTypeEnum {
        SlTable = <any> 'sl_table',
        Table = <any> 'table',
        Dataset = <any> 'dataset',
        Query = <any> 'query',
        SavedQuery = <any> 'saved_query',
        View = <any> 'view'
    }
}
/**
 * 
 * @export
 * @interface ChartRestApiPut
 */
export interface ChartRestApiPut {
    /**
     * Duration (in seconds) of the caching timeout for this chart. Note this defaults to the datasource/table timeout if undefined.
     * @type {number}
     * @memberof ChartRestApiPut
     */
    cacheTimeout?: number;
    /**
     * Details of the certification
     * @type {string}
     * @memberof ChartRestApiPut
     */
    certificationDetails?: string;
    /**
     * Person or group that has certified this chart
     * @type {string}
     * @memberof ChartRestApiPut
     */
    certifiedBy?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChartRestApiPut
     */
    dashboards?: Array<number>;
    /**
     * The id of the dataset/datasource this new chart will use. A complete datasource identification needs `datasouce_id` and `datasource_type`.
     * @type {number}
     * @memberof ChartRestApiPut
     */
    datasourceId?: number;
    /**
     * The type of dataset/datasource identified on `datasource_id`.
     * @type {string}
     * @memberof ChartRestApiPut
     */
    datasourceType?: ChartRestApiPut.DatasourceTypeEnum;
    /**
     * A description of the chart propose.
     * @type {string}
     * @memberof ChartRestApiPut
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartRestApiPut
     */
    externalUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChartRestApiPut
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChartRestApiPut
     */
    owners?: Array<number>;
    /**
     * Parameters are generated dynamically when clicking the save or overwrite button in the explore view. This JSON object for power users who may want to alter specific parameters.
     * @type {string}
     * @memberof ChartRestApiPut
     */
    params?: string;
    /**
     * The query context represents the queries that need to run in order to generate the data the visualization, and in what format the data should be returned.
     * @type {string}
     * @memberof ChartRestApiPut
     */
    queryContext?: string;
    /**
     * The query context generation represents whether the query_contextis user generated or not so that it does not update user modfiedstate.
     * @type {boolean}
     * @memberof ChartRestApiPut
     */
    queryContextGeneration?: boolean;
    /**
     * The name of the chart.
     * @type {string}
     * @memberof ChartRestApiPut
     */
    sliceName?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ChartRestApiPut
     */
    tags?: Array<Tag>;
    /**
     * The type of chart visualization used.
     * @type {string}
     * @memberof ChartRestApiPut
     */
    vizType?: string;
}

/**
 * @export
 * @namespace ChartRestApiPut
 */
export namespace ChartRestApiPut {
    /**
     * @export
     * @enum {string}
     */
    export enum DatasourceTypeEnum {
        SlTable = <any> 'sl_table',
        Table = <any> 'table',
        Dataset = <any> 'dataset',
        Query = <any> 'query',
        SavedQuery = <any> 'saved_query',
        View = <any> 'view'
    }
}
/**
 * 
 * @export
 * @interface CssTemplateRestApiGet
 */
export interface CssTemplateRestApiGet {
    /**
     * 
     * @type {CssTemplateRestApiGetUser}
     * @memberof CssTemplateRestApiGet
     */
    createdBy?: CssTemplateRestApiGetUser;
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiGet
     */
    css?: string;
    /**
     * 
     * @type {number}
     * @memberof CssTemplateRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiGet
     */
    templateName?: string;
}
/**
 * 
 * @export
 * @interface CssTemplateRestApiGetList
 */
export interface CssTemplateRestApiGetList {
    /**
     * 
     * @type {CssTemplateRestApiGetListUser}
     * @memberof CssTemplateRestApiGetList
     */
    changedBy?: CssTemplateRestApiGetListUser;
    /**
     * 
     * @type {any}
     * @memberof CssTemplateRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {CssTemplateRestApiGetListUser1}
     * @memberof CssTemplateRestApiGetList
     */
    createdBy?: CssTemplateRestApiGetListUser1;
    /**
     * 
     * @type {Date}
     * @memberof CssTemplateRestApiGetList
     */
    createdOn?: Date;
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiGetList
     */
    css?: string;
    /**
     * 
     * @type {number}
     * @memberof CssTemplateRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiGetList
     */
    templateName?: string;
}
/**
 * 
 * @export
 * @interface CssTemplateRestApiGetListUser
 */
export interface CssTemplateRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiGetListUser
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof CssTemplateRestApiGetListUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiGetListUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface CssTemplateRestApiGetListUser1
 */
export interface CssTemplateRestApiGetListUser1 {
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiGetListUser1
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof CssTemplateRestApiGetListUser1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiGetListUser1
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface CssTemplateRestApiGetUser
 */
export interface CssTemplateRestApiGetUser {
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiGetUser
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof CssTemplateRestApiGetUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiGetUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface CssTemplateRestApiPost
 */
export interface CssTemplateRestApiPost {
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiPost
     */
    css?: string;
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiPost
     */
    templateName?: string;
}
/**
 * 
 * @export
 * @interface CssTemplateRestApiPut
 */
export interface CssTemplateRestApiPut {
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiPut
     */
    css?: string;
    /**
     * 
     * @type {string}
     * @memberof CssTemplateRestApiPut
     */
    templateName?: string;
}
/**
 * 
 * @export
 * @interface DashboardCopySchema
 */
export interface DashboardCopySchema {
    /**
     * Override CSS for the dashboard.
     * @type {string}
     * @memberof DashboardCopySchema
     */
    css?: string;
    /**
     * A title for the dashboard.
     * @type {string}
     * @memberof DashboardCopySchema
     */
    dashboardTitle?: string;
    /**
     * Whether or not to also copy all charts on the dashboard
     * @type {boolean}
     * @memberof DashboardCopySchema
     */
    duplicateSlices?: boolean;
    /**
     * This JSON object is generated dynamically when clicking the save or overwrite button in the dashboard view. It is exposed here for reference and for power users who may want to alter  specific parameters.
     * @type {string}
     * @memberof DashboardCopySchema
     */
    jsonMetadata: string;
}
/**
 * 
 * @export
 * @interface DashboardDatasetSchema
 */
export interface DashboardDatasetSchema {
    /**
     * 
     * @type {number}
     * @memberof DashboardDatasetSchema
     */
    cacheTimeout?: number;
    /**
     * 
     * @type {any}
     * @memberof DashboardDatasetSchema
     */
    columnFormats?: any;
    /**
     * 
     * @type {Array<number>}
     * @memberof DashboardDatasetSchema
     */
    columnTypes?: Array<number>;
    /**
     * 
     * @type {Array<any>}
     * @memberof DashboardDatasetSchema
     */
    columns?: Array<any>;
    /**
     * 
     * @type {Database}
     * @memberof DashboardDatasetSchema
     */
    database?: Database;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    datasourceName?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    defaultEndpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    editUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    fetchValuesPredicate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardDatasetSchema
     */
    filterSelect?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardDatasetSchema
     */
    filterSelectEnabled?: boolean;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof DashboardDatasetSchema
     */
    granularitySqla?: Array<Array<string>>;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    healthCheckMessage?: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardDatasetSchema
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardDatasetSchema
     */
    isSqllabView?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    mainDttmCol?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof DashboardDatasetSchema
     */
    metrics?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardDatasetSchema
     */
    offset?: number;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof DashboardDatasetSchema
     */
    orderByChoices?: Array<Array<string>>;
    /**
     * 
     * @type {Array<any>}
     * @memberof DashboardDatasetSchema
     */
    owners?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    params?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    perm?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    selectStar?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    sql?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    tableName?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    templateParams?: string;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof DashboardDatasetSchema
     */
    timeGrainSqla?: Array<Array<string>>;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardDatasetSchema
     */
    uid?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DashboardDatasetSchema
     */
    verboseMap?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface DashboardGetResponseSchema
 */
export interface DashboardGetResponseSchema {
    /**
     * Details of the certification
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    certificationDetails?: string;
    /**
     * Person or group that has certified this dashboard
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    certifiedBy?: string;
    /**
     * 
     * @type {User}
     * @memberof DashboardGetResponseSchema
     */
    changedBy?: User;
    /**
     * 
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    changedByName?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    changedByUrl?: string;
    /**
     * 
     * @type {Date}
     * @memberof DashboardGetResponseSchema
     */
    changedOn?: Date;
    /**
     * 
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    changedOnDeltaHumanized?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DashboardGetResponseSchema
     */
    charts?: Array<string>;
    /**
     * Override CSS for the dashboard.
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    css?: string;
    /**
     * A title for the dashboard.
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    dashboardTitle?: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardGetResponseSchema
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardGetResponseSchema
     */
    isManagedExternally?: boolean;
    /**
     * This JSON object is generated dynamically when clicking the save or overwrite button in the dashboard view. It is exposed here for reference and for power users who may want to alter  specific parameters.
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    jsonMetadata?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof DashboardGetResponseSchema
     */
    owners?: Array<User>;
    /**
     * This json object describes the positioning of the widgets in the dashboard. It is dynamically generated when adjusting the widgets size and positions by using drag & drop in the dashboard view
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    positionJson?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardGetResponseSchema
     */
    published?: boolean;
    /**
     * 
     * @type {Array<Roles>}
     * @memberof DashboardGetResponseSchema
     */
    roles?: Array<Roles>;
    /**
     * 
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    slug?: string;
    /**
     * 
     * @type {Array<Tag1>}
     * @memberof DashboardGetResponseSchema
     */
    tags?: Array<Tag1>;
    /**
     * 
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    thumbnailUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardGetResponseSchema
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface DashboardImportBody
 */
export interface DashboardImportBody {
    /**
     * upload file (ZIP or JSON)
     * @type {Blob}
     * @memberof DashboardImportBody
     */
    formData?: Blob;
    /**
     * overwrite existing dashboards?
     * @type {boolean}
     * @memberof DashboardImportBody
     */
    overwrite?: boolean;
    /**
     * JSON map of passwords for each featured database in the ZIP file. If the ZIP includes a database config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof DashboardImportBody
     */
    passwords?: string;
    /**
     * JSON map of passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof DashboardImportBody
     */
    sshTunnelPasswords?: string;
    /**
     * JSON map of private_key_passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key_password\"}`.
     * @type {string}
     * @memberof DashboardImportBody
     */
    sshTunnelPrivateKeyPasswords?: string;
    /**
     * JSON map of private_keys for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key\"}`.
     * @type {string}
     * @memberof DashboardImportBody
     */
    sshTunnelPrivateKeys?: string;
}
/**
 * 
 * @export
 * @interface DashboardPermalinkStateSchema
 */
export interface DashboardPermalinkStateSchema {
    /**
     * Current active dashboard tabs
     * @type {Array<string>}
     * @memberof DashboardPermalinkStateSchema
     */
    activeTabs?: Array<string>;
    /**
     * Optional anchor link added to url hash
     * @type {string}
     * @memberof DashboardPermalinkStateSchema
     */
    anchor?: string;
    /**
     * Data mask used for native filter state
     * @type {any}
     * @memberof DashboardPermalinkStateSchema
     */
    dataMask?: any;
    /**
     * URL Parameters
     * @type {Array<any>}
     * @memberof DashboardPermalinkStateSchema
     */
    urlParams?: Array<any>;
}
/**
 * 
 * @export
 * @interface DashboardRestApiGet
 */
export interface DashboardRestApiGet {
    /**
     * 
     * @type {number}
     * @memberof DashboardRestApiGet
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DashboardRestApiGetList
 */
export interface DashboardRestApiGetList {
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetList
     */
    certificationDetails?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetList
     */
    certifiedBy?: string;
    /**
     * 
     * @type {DashboardRestApiGetListUser}
     * @memberof DashboardRestApiGetList
     */
    changedBy?: DashboardRestApiGetListUser;
    /**
     * 
     * @type {any}
     * @memberof DashboardRestApiGetList
     */
    changedByName?: any;
    /**
     * 
     * @type {any}
     * @memberof DashboardRestApiGetList
     */
    changedByUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof DashboardRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {any}
     * @memberof DashboardRestApiGetList
     */
    changedOnUtc?: any;
    /**
     * 
     * @type {DashboardRestApiGetListUser2}
     * @memberof DashboardRestApiGetList
     */
    createdBy?: DashboardRestApiGetListUser2;
    /**
     * 
     * @type {any}
     * @memberof DashboardRestApiGetList
     */
    createdOnDeltaHumanized?: any;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetList
     */
    css?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetList
     */
    dashboardTitle?: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardRestApiGetList
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetList
     */
    jsonMetadata?: string;
    /**
     * 
     * @type {DashboardRestApiGetListUser1}
     * @memberof DashboardRestApiGetList
     */
    owners?: DashboardRestApiGetListUser1;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetList
     */
    positionJson?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardRestApiGetList
     */
    published?: boolean;
    /**
     * 
     * @type {DashboardRestApiGetListRole}
     * @memberof DashboardRestApiGetList
     */
    roles?: DashboardRestApiGetListRole;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetList
     */
    slug?: string;
    /**
     * 
     * @type {any}
     * @memberof DashboardRestApiGetList
     */
    status?: any;
    /**
     * 
     * @type {DashboardRestApiGetListTag}
     * @memberof DashboardRestApiGetList
     */
    tags?: DashboardRestApiGetListTag;
    /**
     * 
     * @type {any}
     * @memberof DashboardRestApiGetList
     */
    thumbnailUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof DashboardRestApiGetList
     */
    url?: any;
}
/**
 * 
 * @export
 * @interface DashboardRestApiGetListRole
 */
export interface DashboardRestApiGetListRole {
    /**
     * 
     * @type {number}
     * @memberof DashboardRestApiGetListRole
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetListRole
     */
    name: string;
}
/**
 * 
 * @export
 * @interface DashboardRestApiGetListTag
 */
export interface DashboardRestApiGetListTag {
    /**
     * 
     * @type {number}
     * @memberof DashboardRestApiGetListTag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetListTag
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof DashboardRestApiGetListTag
     */
    type?: any;
}
/**
 * 
 * @export
 * @interface DashboardRestApiGetListUser
 */
export interface DashboardRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetListUser
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardRestApiGetListUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetListUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface DashboardRestApiGetListUser1
 */
export interface DashboardRestApiGetListUser1 {
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetListUser1
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardRestApiGetListUser1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetListUser1
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface DashboardRestApiGetListUser2
 */
export interface DashboardRestApiGetListUser2 {
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetListUser2
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardRestApiGetListUser2
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiGetListUser2
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface DashboardRestApiPost
 */
export interface DashboardRestApiPost {
    /**
     * Details of the certification
     * @type {string}
     * @memberof DashboardRestApiPost
     */
    certificationDetails?: string;
    /**
     * Person or group that has certified this dashboard
     * @type {string}
     * @memberof DashboardRestApiPost
     */
    certifiedBy?: string;
    /**
     * Override CSS for the dashboard.
     * @type {string}
     * @memberof DashboardRestApiPost
     */
    css?: string;
    /**
     * A title for the dashboard.
     * @type {string}
     * @memberof DashboardRestApiPost
     */
    dashboardTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiPost
     */
    externalUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardRestApiPost
     */
    isManagedExternally?: boolean;
    /**
     * This JSON object is generated dynamically when clicking the save or overwrite button in the dashboard view. It is exposed here for reference and for power users who may want to alter  specific parameters.
     * @type {string}
     * @memberof DashboardRestApiPost
     */
    jsonMetadata?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof DashboardRestApiPost
     */
    owners?: Array<number>;
    /**
     * This json object describes the positioning of the widgets in the dashboard. It is dynamically generated when adjusting the widgets size and positions by using drag & drop in the dashboard view
     * @type {string}
     * @memberof DashboardRestApiPost
     */
    positionJson?: string;
    /**
     * Determines whether or not this dashboard is visible in the list of all dashboards.
     * @type {boolean}
     * @memberof DashboardRestApiPost
     */
    published?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof DashboardRestApiPost
     */
    roles?: Array<number>;
    /**
     * Unique identifying part for the web address of the dashboard.
     * @type {string}
     * @memberof DashboardRestApiPost
     */
    slug?: string;
}
/**
 * 
 * @export
 * @interface DashboardRestApiPut
 */
export interface DashboardRestApiPut {
    /**
     * Details of the certification
     * @type {string}
     * @memberof DashboardRestApiPut
     */
    certificationDetails?: string;
    /**
     * Person or group that has certified this dashboard
     * @type {string}
     * @memberof DashboardRestApiPut
     */
    certifiedBy?: string;
    /**
     * Override CSS for the dashboard.
     * @type {string}
     * @memberof DashboardRestApiPut
     */
    css?: string;
    /**
     * A title for the dashboard.
     * @type {string}
     * @memberof DashboardRestApiPut
     */
    dashboardTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardRestApiPut
     */
    externalUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardRestApiPut
     */
    isManagedExternally?: boolean;
    /**
     * This JSON object is generated dynamically when clicking the save or overwrite button in the dashboard view. It is exposed here for reference and for power users who may want to alter  specific parameters.
     * @type {string}
     * @memberof DashboardRestApiPut
     */
    jsonMetadata?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof DashboardRestApiPut
     */
    owners?: Array<number>;
    /**
     * This json object describes the positioning of the widgets in the dashboard. It is dynamically generated when adjusting the widgets size and positions by using drag & drop in the dashboard view
     * @type {string}
     * @memberof DashboardRestApiPut
     */
    positionJson?: string;
    /**
     * Determines whether or not this dashboard is visible in the list of all dashboards.
     * @type {boolean}
     * @memberof DashboardRestApiPut
     */
    published?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof DashboardRestApiPut
     */
    roles?: Array<number>;
    /**
     * Unique identifying part for the web address of the dashboard.
     * @type {string}
     * @memberof DashboardRestApiPut
     */
    slug?: string;
}
/**
 * 
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * 
     * @type {boolean}
     * @memberof Database
     */
    allowsCostEstimate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Database
     */
    allowsSubquery?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Database
     */
    allowsVirtualTableExplore?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    backend?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Database
     */
    disableDataPreview?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Database
     */
    exploreDatabaseId?: number;
    /**
     * 
     * @type {number}
     * @memberof Database
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Database1
 */
export interface Database1 {
    /**
     * 
     * @type {string}
     * @memberof Database1
     */
    databaseName?: string;
}
/**
 * 
 * @export
 * @interface DatabaseConnectionSchema
 */
export interface DatabaseConnectionSchema {
    /**
     * Allow CREATE TABLE AS option in SQL Lab
     * @type {boolean}
     * @memberof DatabaseConnectionSchema
     */
    allowCtas?: boolean;
    /**
     * Allow CREATE VIEW AS option in SQL Lab
     * @type {boolean}
     * @memberof DatabaseConnectionSchema
     */
    allowCvas?: boolean;
    /**
     * Allow users to run non-SELECT statements (UPDATE, DELETE, CREATE, ...) in SQL Lab
     * @type {boolean}
     * @memberof DatabaseConnectionSchema
     */
    allowDml?: boolean;
    /**
     * Allow to upload CSV file data into this databaseIf selected, please set the schemas allowed for csv upload in Extra.
     * @type {boolean}
     * @memberof DatabaseConnectionSchema
     */
    allowFileUpload?: boolean;
    /**
     * Operate the database in asynchronous mode, meaning that the queries are executed on remote workers as opposed to on the web server itself. This assumes that you have a Celery worker setup as well as a results backend. Refer to the installation docs for more information.
     * @type {boolean}
     * @memberof DatabaseConnectionSchema
     */
    allowRunAsync?: boolean;
    /**
     * SQLAlchemy engine to use
     * @type {string}
     * @memberof DatabaseConnectionSchema
     */
    backend?: string;
    /**
     * Duration (in seconds) of the caching timeout for charts of this database. A timeout of 0 indicates that the cache never expires. Note this defaults to the global timeout if undefined.
     * @type {number}
     * @memberof DatabaseConnectionSchema
     */
    cacheTimeout?: number;
    /**
     * Configuration_method is used on the frontend to inform the backend whether to explode parameters or to provide only a sqlalchemy_uri.
     * @type {string}
     * @memberof DatabaseConnectionSchema
     */
    configurationMethod?: string;
    /**
     * A database name to identify this connection.
     * @type {string}
     * @memberof DatabaseConnectionSchema
     */
    databaseName?: string;
    /**
     * SQLAlchemy driver to use
     * @type {string}
     * @memberof DatabaseConnectionSchema
     */
    driver?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DatabaseConnectionSchema
     */
    engineInformation?: { [key: string]: any; };
    /**
     * Expose this database to SQLLab
     * @type {boolean}
     * @memberof DatabaseConnectionSchema
     */
    exposeInSqllab?: boolean;
    /**
     * <p>JSON string containing extra configuration elements.<br>1. The <code>engine_params</code> object gets unpacked into the <a href=\"https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine\" rel=\"noopener noreferrer\">sqlalchemy.create_engine</a> call, while the <code>metadata_params</code> gets unpacked into the <a href=\"https://docs.sqlalchemy.org/en/rel_1_0/core/metadata.html#sqlalchemy.schema.MetaData\" rel=\"noopener noreferrer\">sqlalchemy.MetaData</a> call.<br>2. The <code>metadata_cache_timeout</code> is a cache timeout setting in seconds for metadata fetch of this database. Specify it as <strong>\"metadata_cache_timeout\": {\"schema_cache_timeout\": 600, \"table_cache_timeout\": 600}</strong>. If unset, cache will not be enabled for the functionality. A timeout of 0 indicates that the cache never expires.<br>3. The <code>schemas_allowed_for_file_upload</code> is a comma separated list of schemas that CSVs are allowed to upload to. Specify it as <strong>\"schemas_allowed_for_file_upload\": [\"public\", \"csv_upload\"]</strong>. If database flavor does not support schema or any schema is allowed to be accessed, just leave the list empty<br>4. The <code>version</code> field is a string specifying the this db's version. This should be used with Presto DBs so that the syntax is correct<br>5. The <code>allows_virtual_table_explore</code> field is a boolean specifying whether or not the Explore button in SQL Lab results is shown.<br>6. The <code>disable_data_preview</code> field is a boolean specifying whether or not data preview queries will be run when fetching table metadata in SQL Lab.</p>
     * @type {string}
     * @memberof DatabaseConnectionSchema
     */
    extra?: string;
    /**
     * When allowing CREATE TABLE AS option in SQL Lab, this option forces the table to be created in this schema
     * @type {string}
     * @memberof DatabaseConnectionSchema
     */
    forceCtasSchema?: string;
    /**
     * Database ID (for updates)
     * @type {number}
     * @memberof DatabaseConnectionSchema
     */
    id?: number;
    /**
     * If Presto, all the queries in SQL Lab are going to be executed as the currently logged on user who must have permission to run them.<br/>If Hive and hive.server2.enable.doAs is enabled, will run the queries as service account, but impersonate the currently logged on user via hive.server2.proxy.user property.
     * @type {boolean}
     * @memberof DatabaseConnectionSchema
     */
    impersonateUser?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseConnectionSchema
     */
    isManagedExternally?: boolean;
    /**
     * <p>JSON string containing additional connection configuration.<br>This is used to provide connection information for systems like Hive, Presto, and BigQuery, which do not conform to the username:password syntax normally used by SQLAlchemy.</p>
     * @type {string}
     * @memberof DatabaseConnectionSchema
     */
    maskedEncryptedExtra?: string;
    /**
     * DB-specific parameters for configuration
     * @type {{ [key: string]: any; }}
     * @memberof DatabaseConnectionSchema
     */
    parameters?: { [key: string]: any; };
    /**
     * JSONSchema for configuring the database by parameters instead of SQLAlchemy URI
     * @type {{ [key: string]: any; }}
     * @memberof DatabaseConnectionSchema
     */
    parametersSchema?: { [key: string]: any; };
    /**
     * <p>Optional CA_BUNDLE contents to validate HTTPS requests. Only available on certain database engines.</p>
     * @type {string}
     * @memberof DatabaseConnectionSchema
     */
    serverCert?: string;
    /**
     * <p>Refer to the <a href=\"https://docs.sqlalchemy.org/en/rel_1_2/core/engines.html#database-urls\" rel=\"noopener noreferrer\">SqlAlchemy docs</a> for more information on how to structure your URI.</p>
     * @type {string}
     * @memberof DatabaseConnectionSchema
     */
    sqlalchemyUri?: string;
    /**
     * 
     * @type {DatabaseSSHTunnel}
     * @memberof DatabaseConnectionSchema
     */
    sshTunnel?: DatabaseSSHTunnel;
    /**
     * 
     * @type {string}
     * @memberof DatabaseConnectionSchema
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface DatabaseFunctionNamesResponse
 */
export interface DatabaseFunctionNamesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof DatabaseFunctionNamesResponse
     */
    functionNames?: Array<string>;
}
/**
 * 
 * @export
 * @interface DatabaseImportBody
 */
export interface DatabaseImportBody {
    /**
     * upload file (ZIP)
     * @type {Blob}
     * @memberof DatabaseImportBody
     */
    formData?: Blob;
    /**
     * overwrite existing databases?
     * @type {boolean}
     * @memberof DatabaseImportBody
     */
    overwrite?: boolean;
    /**
     * JSON map of passwords for each featured database in the ZIP file. If the ZIP includes a database config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof DatabaseImportBody
     */
    passwords?: string;
    /**
     * JSON map of passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof DatabaseImportBody
     */
    sshTunnelPasswords?: string;
    /**
     * JSON map of private_key_passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key_password\"}`.
     * @type {string}
     * @memberof DatabaseImportBody
     */
    sshTunnelPrivateKeyPasswords?: string;
    /**
     * JSON map of private_keys for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key\"}`.
     * @type {string}
     * @memberof DatabaseImportBody
     */
    sshTunnelPrivateKeys?: string;
}
/**
 * 
 * @export
 * @interface DatabaseRelatedChart
 */
export interface DatabaseRelatedChart {
    /**
     * 
     * @type {number}
     * @memberof DatabaseRelatedChart
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRelatedChart
     */
    sliceName?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRelatedChart
     */
    vizType?: string;
}
/**
 * 
 * @export
 * @interface DatabaseRelatedCharts
 */
export interface DatabaseRelatedCharts {
    /**
     * Chart count
     * @type {number}
     * @memberof DatabaseRelatedCharts
     */
    count?: number;
    /**
     * A list of dashboards
     * @type {Array<DatabaseRelatedChart>}
     * @memberof DatabaseRelatedCharts
     */
    result?: Array<DatabaseRelatedChart>;
}
/**
 * 
 * @export
 * @interface DatabaseRelatedDashboard
 */
export interface DatabaseRelatedDashboard {
    /**
     * 
     * @type {number}
     * @memberof DatabaseRelatedDashboard
     */
    id?: number;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRelatedDashboard
     */
    jsonMetadata?: any;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRelatedDashboard
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRelatedDashboard
     */
    title?: string;
}
/**
 * 
 * @export
 * @interface DatabaseRelatedDashboards
 */
export interface DatabaseRelatedDashboards {
    /**
     * Dashboard count
     * @type {number}
     * @memberof DatabaseRelatedDashboards
     */
    count?: number;
    /**
     * A list of dashboards
     * @type {Array<DatabaseRelatedDashboard>}
     * @memberof DatabaseRelatedDashboards
     */
    result?: Array<DatabaseRelatedDashboard>;
}
/**
 * 
 * @export
 * @interface DatabaseRelatedObjectsResponse
 */
export interface DatabaseRelatedObjectsResponse {
    /**
     * 
     * @type {DatabaseRelatedCharts}
     * @memberof DatabaseRelatedObjectsResponse
     */
    charts?: DatabaseRelatedCharts;
    /**
     * 
     * @type {DatabaseRelatedDashboards}
     * @memberof DatabaseRelatedObjectsResponse
     */
    dashboards?: DatabaseRelatedDashboards;
}
/**
 * 
 * @export
 * @interface DatabaseRestApiGet
 */
export interface DatabaseRestApiGet {
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGet
     */
    allowCtas?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGet
     */
    allowCvas?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGet
     */
    allowDml?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGet
     */
    allowFileUpload?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGet
     */
    allowRunAsync?: boolean;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRestApiGet
     */
    backend?: any;
    /**
     * 
     * @type {number}
     * @memberof DatabaseRestApiGet
     */
    cacheTimeout?: number;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiGet
     */
    configurationMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiGet
     */
    databaseName: string;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRestApiGet
     */
    driver?: any;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRestApiGet
     */
    engineInformation?: any;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGet
     */
    exposeInSqllab?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiGet
     */
    forceCtasSchema?: string;
    /**
     * 
     * @type {number}
     * @memberof DatabaseRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGet
     */
    impersonateUser?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGet
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiGet
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface DatabaseRestApiGetList
 */
export interface DatabaseRestApiGetList {
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGetList
     */
    allowCtas?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGetList
     */
    allowCvas?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGetList
     */
    allowDml?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGetList
     */
    allowFileUpload?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGetList
     */
    allowRunAsync?: boolean;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRestApiGetList
     */
    allowsCostEstimate?: any;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRestApiGetList
     */
    allowsSubquery?: any;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRestApiGetList
     */
    allowsVirtualTableExplore?: any;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRestApiGetList
     */
    backend?: any;
    /**
     * 
     * @type {Date}
     * @memberof DatabaseRestApiGetList
     */
    changedOn?: Date;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {DatabaseRestApiGetListUser}
     * @memberof DatabaseRestApiGetList
     */
    createdBy?: DatabaseRestApiGetListUser;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiGetList
     */
    databaseName: string;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRestApiGetList
     */
    disableDataPreview?: any;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRestApiGetList
     */
    engineInformation?: any;
    /**
     * 
     * @type {any}
     * @memberof DatabaseRestApiGetList
     */
    exploreDatabaseId?: any;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiGetList
     */
    exposeInSqllab?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiGetList
     */
    extra?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiGetList
     */
    forceCtasSchema?: string;
    /**
     * 
     * @type {number}
     * @memberof DatabaseRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiGetList
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface DatabaseRestApiGetListUser
 */
export interface DatabaseRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiGetListUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiGetListUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface DatabaseRestApiPost
 */
export interface DatabaseRestApiPost {
    /**
     * Allow CREATE TABLE AS option in SQL Lab
     * @type {boolean}
     * @memberof DatabaseRestApiPost
     */
    allowCtas?: boolean;
    /**
     * Allow CREATE VIEW AS option in SQL Lab
     * @type {boolean}
     * @memberof DatabaseRestApiPost
     */
    allowCvas?: boolean;
    /**
     * Allow users to run non-SELECT statements (UPDATE, DELETE, CREATE, ...) in SQL Lab
     * @type {boolean}
     * @memberof DatabaseRestApiPost
     */
    allowDml?: boolean;
    /**
     * Allow to upload CSV file data into this databaseIf selected, please set the schemas allowed for csv upload in Extra.
     * @type {boolean}
     * @memberof DatabaseRestApiPost
     */
    allowFileUpload?: boolean;
    /**
     * Operate the database in asynchronous mode, meaning that the queries are executed on remote workers as opposed to on the web server itself. This assumes that you have a Celery worker setup as well as a results backend. Refer to the installation docs for more information.
     * @type {boolean}
     * @memberof DatabaseRestApiPost
     */
    allowRunAsync?: boolean;
    /**
     * Duration (in seconds) of the caching timeout for charts of this database. A timeout of 0 indicates that the cache never expires. Note this defaults to the global timeout if undefined.
     * @type {number}
     * @memberof DatabaseRestApiPost
     */
    cacheTimeout?: number;
    /**
     * Configuration_method is used on the frontend to inform the backend whether to explode parameters or to provide only a sqlalchemy_uri.
     * @type {any}
     * @memberof DatabaseRestApiPost
     */
    configurationMethod?: any;
    /**
     * A database name to identify this connection.
     * @type {string}
     * @memberof DatabaseRestApiPost
     */
    databaseName: string;
    /**
     * SQLAlchemy driver to use
     * @type {string}
     * @memberof DatabaseRestApiPost
     */
    driver?: string;
    /**
     * SQLAlchemy engine to use
     * @type {string}
     * @memberof DatabaseRestApiPost
     */
    engine?: string;
    /**
     * Expose this database to SQLLab
     * @type {boolean}
     * @memberof DatabaseRestApiPost
     */
    exposeInSqllab?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiPost
     */
    externalUrl?: string;
    /**
     * <p>JSON string containing extra configuration elements.<br>1. The <code>engine_params</code> object gets unpacked into the <a href=\"https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine\" rel=\"noopener noreferrer\">sqlalchemy.create_engine</a> call, while the <code>metadata_params</code> gets unpacked into the <a href=\"https://docs.sqlalchemy.org/en/rel_1_0/core/metadata.html#sqlalchemy.schema.MetaData\" rel=\"noopener noreferrer\">sqlalchemy.MetaData</a> call.<br>2. The <code>metadata_cache_timeout</code> is a cache timeout setting in seconds for metadata fetch of this database. Specify it as <strong>\"metadata_cache_timeout\": {\"schema_cache_timeout\": 600, \"table_cache_timeout\": 600}</strong>. If unset, cache will not be enabled for the functionality. A timeout of 0 indicates that the cache never expires.<br>3. The <code>schemas_allowed_for_file_upload</code> is a comma separated list of schemas that CSVs are allowed to upload to. Specify it as <strong>\"schemas_allowed_for_file_upload\": [\"public\", \"csv_upload\"]</strong>. If database flavor does not support schema or any schema is allowed to be accessed, just leave the list empty<br>4. The <code>version</code> field is a string specifying the this db's version. This should be used with Presto DBs so that the syntax is correct<br>5. The <code>allows_virtual_table_explore</code> field is a boolean specifying whether or not the Explore button in SQL Lab results is shown.<br>6. The <code>disable_data_preview</code> field is a boolean specifying whether or not data preview queries will be run when fetching table metadata in SQL Lab.</p>
     * @type {string}
     * @memberof DatabaseRestApiPost
     */
    extra?: string;
    /**
     * When allowing CREATE TABLE AS option in SQL Lab, this option forces the table to be created in this schema
     * @type {string}
     * @memberof DatabaseRestApiPost
     */
    forceCtasSchema?: string;
    /**
     * If Presto, all the queries in SQL Lab are going to be executed as the currently logged on user who must have permission to run them.<br/>If Hive and hive.server2.enable.doAs is enabled, will run the queries as service account, but impersonate the currently logged on user via hive.server2.proxy.user property.
     * @type {boolean}
     * @memberof DatabaseRestApiPost
     */
    impersonateUser?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiPost
     */
    isManagedExternally?: boolean;
    /**
     * <p>JSON string containing additional connection configuration.<br>This is used to provide connection information for systems like Hive, Presto, and BigQuery, which do not conform to the username:password syntax normally used by SQLAlchemy.</p>
     * @type {string}
     * @memberof DatabaseRestApiPost
     */
    maskedEncryptedExtra?: string;
    /**
     * DB-specific parameters for configuration
     * @type {{ [key: string]: any; }}
     * @memberof DatabaseRestApiPost
     */
    parameters?: { [key: string]: any; };
    /**
     * <p>Optional CA_BUNDLE contents to validate HTTPS requests. Only available on certain database engines.</p>
     * @type {string}
     * @memberof DatabaseRestApiPost
     */
    serverCert?: string;
    /**
     * <p>Refer to the <a href=\"https://docs.sqlalchemy.org/en/rel_1_2/core/engines.html#database-urls\" rel=\"noopener noreferrer\">SqlAlchemy docs</a> for more information on how to structure your URI.</p>
     * @type {string}
     * @memberof DatabaseRestApiPost
     */
    sqlalchemyUri?: string;
    /**
     * 
     * @type {DatabaseSSHTunnel}
     * @memberof DatabaseRestApiPost
     */
    sshTunnel?: DatabaseSSHTunnel;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiPost
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface DatabaseRestApiPut
 */
export interface DatabaseRestApiPut {
    /**
     * Allow CREATE TABLE AS option in SQL Lab
     * @type {boolean}
     * @memberof DatabaseRestApiPut
     */
    allowCtas?: boolean;
    /**
     * Allow CREATE VIEW AS option in SQL Lab
     * @type {boolean}
     * @memberof DatabaseRestApiPut
     */
    allowCvas?: boolean;
    /**
     * Allow users to run non-SELECT statements (UPDATE, DELETE, CREATE, ...) in SQL Lab
     * @type {boolean}
     * @memberof DatabaseRestApiPut
     */
    allowDml?: boolean;
    /**
     * Allow to upload CSV file data into this databaseIf selected, please set the schemas allowed for csv upload in Extra.
     * @type {boolean}
     * @memberof DatabaseRestApiPut
     */
    allowFileUpload?: boolean;
    /**
     * Operate the database in asynchronous mode, meaning that the queries are executed on remote workers as opposed to on the web server itself. This assumes that you have a Celery worker setup as well as a results backend. Refer to the installation docs for more information.
     * @type {boolean}
     * @memberof DatabaseRestApiPut
     */
    allowRunAsync?: boolean;
    /**
     * Duration (in seconds) of the caching timeout for charts of this database. A timeout of 0 indicates that the cache never expires. Note this defaults to the global timeout if undefined.
     * @type {number}
     * @memberof DatabaseRestApiPut
     */
    cacheTimeout?: number;
    /**
     * Configuration_method is used on the frontend to inform the backend whether to explode parameters or to provide only a sqlalchemy_uri.
     * @type {any}
     * @memberof DatabaseRestApiPut
     */
    configurationMethod?: any;
    /**
     * A database name to identify this connection.
     * @type {string}
     * @memberof DatabaseRestApiPut
     */
    databaseName?: string;
    /**
     * SQLAlchemy driver to use
     * @type {string}
     * @memberof DatabaseRestApiPut
     */
    driver?: string;
    /**
     * SQLAlchemy engine to use
     * @type {string}
     * @memberof DatabaseRestApiPut
     */
    engine?: string;
    /**
     * Expose this database to SQLLab
     * @type {boolean}
     * @memberof DatabaseRestApiPut
     */
    exposeInSqllab?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiPut
     */
    externalUrl?: string;
    /**
     * <p>JSON string containing extra configuration elements.<br>1. The <code>engine_params</code> object gets unpacked into the <a href=\"https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine\" rel=\"noopener noreferrer\">sqlalchemy.create_engine</a> call, while the <code>metadata_params</code> gets unpacked into the <a href=\"https://docs.sqlalchemy.org/en/rel_1_0/core/metadata.html#sqlalchemy.schema.MetaData\" rel=\"noopener noreferrer\">sqlalchemy.MetaData</a> call.<br>2. The <code>metadata_cache_timeout</code> is a cache timeout setting in seconds for metadata fetch of this database. Specify it as <strong>\"metadata_cache_timeout\": {\"schema_cache_timeout\": 600, \"table_cache_timeout\": 600}</strong>. If unset, cache will not be enabled for the functionality. A timeout of 0 indicates that the cache never expires.<br>3. The <code>schemas_allowed_for_file_upload</code> is a comma separated list of schemas that CSVs are allowed to upload to. Specify it as <strong>\"schemas_allowed_for_file_upload\": [\"public\", \"csv_upload\"]</strong>. If database flavor does not support schema or any schema is allowed to be accessed, just leave the list empty<br>4. The <code>version</code> field is a string specifying the this db's version. This should be used with Presto DBs so that the syntax is correct<br>5. The <code>allows_virtual_table_explore</code> field is a boolean specifying whether or not the Explore button in SQL Lab results is shown.<br>6. The <code>disable_data_preview</code> field is a boolean specifying whether or not data preview queries will be run when fetching table metadata in SQL Lab.</p>
     * @type {string}
     * @memberof DatabaseRestApiPut
     */
    extra?: string;
    /**
     * When allowing CREATE TABLE AS option in SQL Lab, this option forces the table to be created in this schema
     * @type {string}
     * @memberof DatabaseRestApiPut
     */
    forceCtasSchema?: string;
    /**
     * If Presto, all the queries in SQL Lab are going to be executed as the currently logged on user who must have permission to run them.<br/>If Hive and hive.server2.enable.doAs is enabled, will run the queries as service account, but impersonate the currently logged on user via hive.server2.proxy.user property.
     * @type {boolean}
     * @memberof DatabaseRestApiPut
     */
    impersonateUser?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseRestApiPut
     */
    isManagedExternally?: boolean;
    /**
     * <p>JSON string containing additional connection configuration.<br>This is used to provide connection information for systems like Hive, Presto, and BigQuery, which do not conform to the username:password syntax normally used by SQLAlchemy.</p>
     * @type {string}
     * @memberof DatabaseRestApiPut
     */
    maskedEncryptedExtra?: string;
    /**
     * DB-specific parameters for configuration
     * @type {{ [key: string]: any; }}
     * @memberof DatabaseRestApiPut
     */
    parameters?: { [key: string]: any; };
    /**
     * <p>Optional CA_BUNDLE contents to validate HTTPS requests. Only available on certain database engines.</p>
     * @type {string}
     * @memberof DatabaseRestApiPut
     */
    serverCert?: string;
    /**
     * <p>Refer to the <a href=\"https://docs.sqlalchemy.org/en/rel_1_2/core/engines.html#database-urls\" rel=\"noopener noreferrer\">SqlAlchemy docs</a> for more information on how to structure your URI.</p>
     * @type {string}
     * @memberof DatabaseRestApiPut
     */
    sqlalchemyUri?: string;
    /**
     * 
     * @type {DatabaseSSHTunnel}
     * @memberof DatabaseRestApiPut
     */
    sshTunnel?: DatabaseSSHTunnel;
    /**
     * 
     * @type {string}
     * @memberof DatabaseRestApiPut
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface DatabaseSSHTunnel
 */
export interface DatabaseSSHTunnel {
    /**
     * SSH Tunnel ID (for updates)
     * @type {number}
     * @memberof DatabaseSSHTunnel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DatabaseSSHTunnel
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseSSHTunnel
     */
    privateKey?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseSSHTunnel
     */
    privateKeyPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseSSHTunnel
     */
    serverAddress?: string;
    /**
     * 
     * @type {number}
     * @memberof DatabaseSSHTunnel
     */
    serverPort?: number;
    /**
     * 
     * @type {string}
     * @memberof DatabaseSSHTunnel
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface DatabaseSchemaAccessForFileUploadResponse
 */
export interface DatabaseSchemaAccessForFileUploadResponse {
    /**
     * The list of schemas allowed for the database to upload information
     * @type {Array<string>}
     * @memberof DatabaseSchemaAccessForFileUploadResponse
     */
    schemas?: Array<string>;
}
/**
 * 
 * @export
 * @interface DatabaseSchemasQuerySchema
 */
export interface DatabaseSchemasQuerySchema {
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseSchemasQuerySchema
     */
    force?: boolean;
}
/**
 * 
 * @export
 * @interface DatabaseTablesQuerySchema
 */
export interface DatabaseTablesQuerySchema {
    /**
     * 
     * @type {boolean}
     * @memberof DatabaseTablesQuerySchema
     */
    force?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DatabaseTablesQuerySchema
     */
    schemaName: string;
}
/**
 * 
 * @export
 * @interface DatabaseTablesResponse
 */
export interface DatabaseTablesResponse {
    /**
     * Extra data used to specify column metadata
     * @type {any}
     * @memberof DatabaseTablesResponse
     */
    extra?: any;
    /**
     * table or view
     * @type {string}
     * @memberof DatabaseTablesResponse
     */
    type?: string;
    /**
     * The table or view name
     * @type {string}
     * @memberof DatabaseTablesResponse
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface DatabaseTestConnectionSchema
 */
export interface DatabaseTestConnectionSchema {
    /**
     * Configuration_method is used on the frontend to inform the backend whether to explode parameters or to provide only a sqlalchemy_uri.
     * @type {any}
     * @memberof DatabaseTestConnectionSchema
     */
    configurationMethod?: any;
    /**
     * A database name to identify this connection.
     * @type {string}
     * @memberof DatabaseTestConnectionSchema
     */
    databaseName?: string;
    /**
     * SQLAlchemy driver to use
     * @type {string}
     * @memberof DatabaseTestConnectionSchema
     */
    driver?: string;
    /**
     * SQLAlchemy engine to use
     * @type {string}
     * @memberof DatabaseTestConnectionSchema
     */
    engine?: string;
    /**
     * <p>JSON string containing extra configuration elements.<br>1. The <code>engine_params</code> object gets unpacked into the <a href=\"https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine\" rel=\"noopener noreferrer\">sqlalchemy.create_engine</a> call, while the <code>metadata_params</code> gets unpacked into the <a href=\"https://docs.sqlalchemy.org/en/rel_1_0/core/metadata.html#sqlalchemy.schema.MetaData\" rel=\"noopener noreferrer\">sqlalchemy.MetaData</a> call.<br>2. The <code>metadata_cache_timeout</code> is a cache timeout setting in seconds for metadata fetch of this database. Specify it as <strong>\"metadata_cache_timeout\": {\"schema_cache_timeout\": 600, \"table_cache_timeout\": 600}</strong>. If unset, cache will not be enabled for the functionality. A timeout of 0 indicates that the cache never expires.<br>3. The <code>schemas_allowed_for_file_upload</code> is a comma separated list of schemas that CSVs are allowed to upload to. Specify it as <strong>\"schemas_allowed_for_file_upload\": [\"public\", \"csv_upload\"]</strong>. If database flavor does not support schema or any schema is allowed to be accessed, just leave the list empty<br>4. The <code>version</code> field is a string specifying the this db's version. This should be used with Presto DBs so that the syntax is correct<br>5. The <code>allows_virtual_table_explore</code> field is a boolean specifying whether or not the Explore button in SQL Lab results is shown.<br>6. The <code>disable_data_preview</code> field is a boolean specifying whether or not data preview queries will be run when fetching table metadata in SQL Lab.</p>
     * @type {string}
     * @memberof DatabaseTestConnectionSchema
     */
    extra?: string;
    /**
     * If Presto, all the queries in SQL Lab are going to be executed as the currently logged on user who must have permission to run them.<br/>If Hive and hive.server2.enable.doAs is enabled, will run the queries as service account, but impersonate the currently logged on user via hive.server2.proxy.user property.
     * @type {boolean}
     * @memberof DatabaseTestConnectionSchema
     */
    impersonateUser?: boolean;
    /**
     * <p>JSON string containing additional connection configuration.<br>This is used to provide connection information for systems like Hive, Presto, and BigQuery, which do not conform to the username:password syntax normally used by SQLAlchemy.</p>
     * @type {string}
     * @memberof DatabaseTestConnectionSchema
     */
    maskedEncryptedExtra?: string;
    /**
     * DB-specific parameters for configuration
     * @type {{ [key: string]: any; }}
     * @memberof DatabaseTestConnectionSchema
     */
    parameters?: { [key: string]: any; };
    /**
     * <p>Optional CA_BUNDLE contents to validate HTTPS requests. Only available on certain database engines.</p>
     * @type {string}
     * @memberof DatabaseTestConnectionSchema
     */
    serverCert?: string;
    /**
     * <p>Refer to the <a href=\"https://docs.sqlalchemy.org/en/rel_1_2/core/engines.html#database-urls\" rel=\"noopener noreferrer\">SqlAlchemy docs</a> for more information on how to structure your URI.</p>
     * @type {string}
     * @memberof DatabaseTestConnectionSchema
     */
    sqlalchemyUri?: string;
    /**
     * 
     * @type {DatabaseSSHTunnel}
     * @memberof DatabaseTestConnectionSchema
     */
    sshTunnel?: DatabaseSSHTunnel;
}
/**
 * 
 * @export
 * @interface DatabaseValidateParametersSchema
 */
export interface DatabaseValidateParametersSchema {
    /**
     * Gsheets specific column for managing label to sheet urls
     * @type {{ [key: string]: any; }}
     * @memberof DatabaseValidateParametersSchema
     */
    catalog?: { [key: string]: any; };
    /**
     * Configuration_method is used on the frontend to inform the backend whether to explode parameters or to provide only a sqlalchemy_uri.
     * @type {any}
     * @memberof DatabaseValidateParametersSchema
     */
    configurationMethod: any;
    /**
     * A database name to identify this connection.
     * @type {string}
     * @memberof DatabaseValidateParametersSchema
     */
    databaseName?: string;
    /**
     * SQLAlchemy driver to use
     * @type {string}
     * @memberof DatabaseValidateParametersSchema
     */
    driver?: string;
    /**
     * SQLAlchemy engine to use
     * @type {string}
     * @memberof DatabaseValidateParametersSchema
     */
    engine: string;
    /**
     * <p>JSON string containing extra configuration elements.<br>1. The <code>engine_params</code> object gets unpacked into the <a href=\"https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine\" rel=\"noopener noreferrer\">sqlalchemy.create_engine</a> call, while the <code>metadata_params</code> gets unpacked into the <a href=\"https://docs.sqlalchemy.org/en/rel_1_0/core/metadata.html#sqlalchemy.schema.MetaData\" rel=\"noopener noreferrer\">sqlalchemy.MetaData</a> call.<br>2. The <code>metadata_cache_timeout</code> is a cache timeout setting in seconds for metadata fetch of this database. Specify it as <strong>\"metadata_cache_timeout\": {\"schema_cache_timeout\": 600, \"table_cache_timeout\": 600}</strong>. If unset, cache will not be enabled for the functionality. A timeout of 0 indicates that the cache never expires.<br>3. The <code>schemas_allowed_for_file_upload</code> is a comma separated list of schemas that CSVs are allowed to upload to. Specify it as <strong>\"schemas_allowed_for_file_upload\": [\"public\", \"csv_upload\"]</strong>. If database flavor does not support schema or any schema is allowed to be accessed, just leave the list empty<br>4. The <code>version</code> field is a string specifying the this db's version. This should be used with Presto DBs so that the syntax is correct<br>5. The <code>allows_virtual_table_explore</code> field is a boolean specifying whether or not the Explore button in SQL Lab results is shown.<br>6. The <code>disable_data_preview</code> field is a boolean specifying whether or not data preview queries will be run when fetching table metadata in SQL Lab.</p>
     * @type {string}
     * @memberof DatabaseValidateParametersSchema
     */
    extra?: string;
    /**
     * Database ID (for updates)
     * @type {number}
     * @memberof DatabaseValidateParametersSchema
     */
    id?: number;
    /**
     * If Presto, all the queries in SQL Lab are going to be executed as the currently logged on user who must have permission to run them.<br/>If Hive and hive.server2.enable.doAs is enabled, will run the queries as service account, but impersonate the currently logged on user via hive.server2.proxy.user property.
     * @type {boolean}
     * @memberof DatabaseValidateParametersSchema
     */
    impersonateUser?: boolean;
    /**
     * <p>JSON string containing additional connection configuration.<br>This is used to provide connection information for systems like Hive, Presto, and BigQuery, which do not conform to the username:password syntax normally used by SQLAlchemy.</p>
     * @type {string}
     * @memberof DatabaseValidateParametersSchema
     */
    maskedEncryptedExtra?: string;
    /**
     * DB-specific parameters for configuration
     * @type {{ [key: string]: any; }}
     * @memberof DatabaseValidateParametersSchema
     */
    parameters?: { [key: string]: any; };
    /**
     * <p>Optional CA_BUNDLE contents to validate HTTPS requests. Only available on certain database engines.</p>
     * @type {string}
     * @memberof DatabaseValidateParametersSchema
     */
    serverCert?: string;
}
/**
 * 
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * Duration (in seconds) of the caching timeout for this dataset.
     * @type {number}
     * @memberof Dataset
     */
    cacheTimeout?: number;
    /**
     * Column formats.
     * @type {any}
     * @memberof Dataset
     */
    columnFormats?: any;
    /**
     * Columns metadata.
     * @type {Array<any>}
     * @memberof Dataset
     */
    columns?: Array<any>;
    /**
     * Database associated with the dataset.
     * @type {any}
     * @memberof Dataset
     */
    database?: any;
    /**
     * Dataset name.
     * @type {string}
     * @memberof Dataset
     */
    datasourceName?: string;
    /**
     * Default endpoint for the dataset.
     * @type {string}
     * @memberof Dataset
     */
    defaultEndpoint?: string;
    /**
     * Dataset description.
     * @type {string}
     * @memberof Dataset
     */
    description?: string;
    /**
     * The URL for editing the dataset.
     * @type {string}
     * @memberof Dataset
     */
    editUrl?: string;
    /**
     * JSON string containing extra configuration elements.
     * @type {any}
     * @memberof Dataset
     */
    extra?: any;
    /**
     * Predicate used when fetching values from the dataset.
     * @type {string}
     * @memberof Dataset
     */
    fetchValuesPredicate?: string;
    /**
     * SELECT filter applied to the dataset.
     * @type {boolean}
     * @memberof Dataset
     */
    filterSelect?: boolean;
    /**
     * If the SELECT filter is enabled.
     * @type {boolean}
     * @memberof Dataset
     */
    filterSelectEnabled?: boolean;
    /**
     * Name of temporal column used for time filtering for SQL datasources. This field is deprecated, use `granularity` instead.
     * @type {Array<Array<any>>}
     * @memberof Dataset
     */
    granularitySqla?: Array<Array<any>>;
    /**
     * Health check message.
     * @type {string}
     * @memberof Dataset
     */
    healthCheckMessage?: string;
    /**
     * Dataset ID.
     * @type {number}
     * @memberof Dataset
     */
    id?: number;
    /**
     * If the dataset is a SQL Lab view.
     * @type {boolean}
     * @memberof Dataset
     */
    isSqllabView?: boolean;
    /**
     * The main temporal column.
     * @type {string}
     * @memberof Dataset
     */
    mainDttmCol?: string;
    /**
     * Dataset metrics.
     * @type {Array<any>}
     * @memberof Dataset
     */
    metrics?: Array<any>;
    /**
     * Dataset name.
     * @type {string}
     * @memberof Dataset
     */
    name?: string;
    /**
     * Dataset offset.
     * @type {number}
     * @memberof Dataset
     */
    offset?: number;
    /**
     * List of order by columns.
     * @type {Array<Array<string>>}
     * @memberof Dataset
     */
    orderByChoices?: Array<Array<string>>;
    /**
     * List of owners identifiers
     * @type {Array<number>}
     * @memberof Dataset
     */
    owners?: Array<number>;
    /**
     * Extra params for the dataset.
     * @type {any}
     * @memberof Dataset
     */
    params?: any;
    /**
     * Permission expression.
     * @type {string}
     * @memberof Dataset
     */
    perm?: string;
    /**
     * Dataset schema.
     * @type {string}
     * @memberof Dataset
     */
    schema?: string;
    /**
     * Select all clause.
     * @type {string}
     * @memberof Dataset
     */
    selectStar?: string;
    /**
     * A SQL statement that defines the dataset.
     * @type {string}
     * @memberof Dataset
     */
    sql?: string;
    /**
     * The name of the table associated with the dataset.
     * @type {string}
     * @memberof Dataset
     */
    tableName?: string;
    /**
     * Table template params.
     * @type {any}
     * @memberof Dataset
     */
    templateParams?: any;
    /**
     * List of temporal granularities supported by the dataset.
     * @type {Array<Array<string>>}
     * @memberof Dataset
     */
    timeGrainSqla?: Array<Array<string>>;
    /**
     * Dataset type.
     * @type {string}
     * @memberof Dataset
     */
    type?: string;
    /**
     * Dataset unique identifier.
     * @type {string}
     * @memberof Dataset
     */
    uid?: string;
    /**
     * Mapping from raw name to verbose name.
     * @type {any}
     * @memberof Dataset
     */
    verboseMap?: any;
}
/**
 * 
 * @export
 * @interface DatasetColumnsPut
 */
export interface DatasetColumnsPut {
    /**
     * 
     * @type {string}
     * @memberof DatasetColumnsPut
     */
    advancedDataType?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetColumnsPut
     */
    columnName: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetColumnsPut
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetColumnsPut
     */
    expression?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetColumnsPut
     */
    extra?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetColumnsPut
     */
    filterable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetColumnsPut
     */
    groupby?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DatasetColumnsPut
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetColumnsPut
     */
    isActive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetColumnsPut
     */
    isDttm?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DatasetColumnsPut
     */
    pythonDateFormat?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetColumnsPut
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetColumnsPut
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetColumnsPut
     */
    verboseName?: string;
}
/**
 * 
 * @export
 * @interface DatasetColumnsRestApiGet
 */
export interface DatasetColumnsRestApiGet {
    /**
     * 
     * @type {number}
     * @memberof DatasetColumnsRestApiGet
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DatasetColumnsRestApiGetList
 */
export interface DatasetColumnsRestApiGetList {
    /**
     * 
     * @type {number}
     * @memberof DatasetColumnsRestApiGetList
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DatasetColumnsRestApiPost
 */
export interface DatasetColumnsRestApiPost {
    /**
     * 
     * @type {number}
     * @memberof DatasetColumnsRestApiPost
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DatasetColumnsRestApiPut
 */
export interface DatasetColumnsRestApiPut {
    /**
     * 
     * @type {number}
     * @memberof DatasetColumnsRestApiPut
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DatasetDuplicateSchema
 */
export interface DatasetDuplicateSchema {
    /**
     * 
     * @type {number}
     * @memberof DatasetDuplicateSchema
     */
    baseModelId: number;
    /**
     * 
     * @type {string}
     * @memberof DatasetDuplicateSchema
     */
    tableName: string;
}
/**
 * 
 * @export
 * @interface DatasetImportBody
 */
export interface DatasetImportBody {
    /**
     * upload file (ZIP or YAML)
     * @type {Blob}
     * @memberof DatasetImportBody
     */
    formData?: Blob;
    /**
     * overwrite existing datasets?
     * @type {boolean}
     * @memberof DatasetImportBody
     */
    overwrite?: boolean;
    /**
     * JSON map of passwords for each featured database in the ZIP file. If the ZIP includes a database config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof DatasetImportBody
     */
    passwords?: string;
    /**
     * JSON map of passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof DatasetImportBody
     */
    sshTunnelPasswords?: string;
    /**
     * JSON map of private_key_passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key_password\"}`.
     * @type {string}
     * @memberof DatasetImportBody
     */
    sshTunnelPrivateKeyPasswords?: string;
    /**
     * JSON map of private_keys for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key\"}`.
     * @type {string}
     * @memberof DatasetImportBody
     */
    sshTunnelPrivateKeys?: string;
    /**
     * sync columns?
     * @type {boolean}
     * @memberof DatasetImportBody
     */
    syncColumns?: boolean;
    /**
     * sync metrics?
     * @type {boolean}
     * @memberof DatasetImportBody
     */
    syncMetrics?: boolean;
}
/**
 * 
 * @export
 * @interface DatasetMetricRestApiGet
 */
export interface DatasetMetricRestApiGet {
    /**
     * 
     * @type {number}
     * @memberof DatasetMetricRestApiGet
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DatasetMetricRestApiGetList
 */
export interface DatasetMetricRestApiGetList {
    /**
     * 
     * @type {number}
     * @memberof DatasetMetricRestApiGetList
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DatasetMetricRestApiPost
 */
export interface DatasetMetricRestApiPost {
    /**
     * 
     * @type {number}
     * @memberof DatasetMetricRestApiPost
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DatasetMetricRestApiPut
 */
export interface DatasetMetricRestApiPut {
    /**
     * 
     * @type {number}
     * @memberof DatasetMetricRestApiPut
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DatasetMetricsPut
 */
export interface DatasetMetricsPut {
    /**
     * 
     * @type {string}
     * @memberof DatasetMetricsPut
     */
    d3format?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetMetricsPut
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetMetricsPut
     */
    expression: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetMetricsPut
     */
    extra?: string;
    /**
     * 
     * @type {number}
     * @memberof DatasetMetricsPut
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DatasetMetricsPut
     */
    metricName: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetMetricsPut
     */
    metricType?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetMetricsPut
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetMetricsPut
     */
    verboseName?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetMetricsPut
     */
    warningText?: string;
}
/**
 * 
 * @export
 * @interface DatasetRelatedChart
 */
export interface DatasetRelatedChart {
    /**
     * 
     * @type {number}
     * @memberof DatasetRelatedChart
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DatasetRelatedChart
     */
    sliceName?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRelatedChart
     */
    vizType?: string;
}
/**
 * 
 * @export
 * @interface DatasetRelatedCharts
 */
export interface DatasetRelatedCharts {
    /**
     * Chart count
     * @type {number}
     * @memberof DatasetRelatedCharts
     */
    count?: number;
    /**
     * A list of dashboards
     * @type {Array<DatasetRelatedChart>}
     * @memberof DatasetRelatedCharts
     */
    result?: Array<DatasetRelatedChart>;
}
/**
 * 
 * @export
 * @interface DatasetRelatedDashboard
 */
export interface DatasetRelatedDashboard {
    /**
     * 
     * @type {number}
     * @memberof DatasetRelatedDashboard
     */
    id?: number;
    /**
     * 
     * @type {any}
     * @memberof DatasetRelatedDashboard
     */
    jsonMetadata?: any;
    /**
     * 
     * @type {string}
     * @memberof DatasetRelatedDashboard
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRelatedDashboard
     */
    title?: string;
}
/**
 * 
 * @export
 * @interface DatasetRelatedDashboards
 */
export interface DatasetRelatedDashboards {
    /**
     * Dashboard count
     * @type {number}
     * @memberof DatasetRelatedDashboards
     */
    count?: number;
    /**
     * A list of dashboards
     * @type {Array<DatasetRelatedDashboard>}
     * @memberof DatasetRelatedDashboards
     */
    result?: Array<DatasetRelatedDashboard>;
}
/**
 * 
 * @export
 * @interface DatasetRelatedObjectsResponse
 */
export interface DatasetRelatedObjectsResponse {
    /**
     * 
     * @type {DatasetRelatedCharts}
     * @memberof DatasetRelatedObjectsResponse
     */
    charts?: DatasetRelatedCharts;
    /**
     * 
     * @type {DatasetRelatedDashboards}
     * @memberof DatasetRelatedObjectsResponse
     */
    dashboards?: DatasetRelatedDashboards;
}
/**
 * 
 * @export
 * @interface DatasetRestApiGet
 */
export interface DatasetRestApiGet {
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiGet
     */
    cacheTimeout?: number;
    /**
     * 
     * @type {DatasetRestApiGetUser}
     * @memberof DatasetRestApiGet
     */
    changedBy?: DatasetRestApiGetUser;
    /**
     * 
     * @type {Date}
     * @memberof DatasetRestApiGet
     */
    changedOn?: Date;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    changedOnHumanized?: any;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    columnFormats?: any;
    /**
     * 
     * @type {DatasetRestApiGetTableColumn}
     * @memberof DatasetRestApiGet
     */
    columns: DatasetRestApiGetTableColumn;
    /**
     * 
     * @type {DatasetRestApiGetUser2}
     * @memberof DatasetRestApiGet
     */
    createdBy?: DatasetRestApiGetUser2;
    /**
     * 
     * @type {Date}
     * @memberof DatasetRestApiGet
     */
    createdOn?: Date;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    createdOnHumanized?: any;
    /**
     * 
     * @type {DatasetRestApiGetDatabase}
     * @memberof DatasetRestApiGet
     */
    database: DatasetRestApiGetDatabase;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    datasourceName?: any;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    datasourceType?: any;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGet
     */
    defaultEndpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGet
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGet
     */
    extra?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGet
     */
    fetchValuesPredicate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetRestApiGet
     */
    filterSelectEnabled?: boolean;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    granularitySqla?: any;
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetRestApiGet
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetRestApiGet
     */
    isSqllabView?: boolean;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    kind?: any;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGet
     */
    mainDttmCol?: string;
    /**
     * 
     * @type {DatasetRestApiGetSqlMetric}
     * @memberof DatasetRestApiGet
     */
    metrics: DatasetRestApiGetSqlMetric;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    name?: any;
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiGet
     */
    offset?: number;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    orderByChoices?: any;
    /**
     * 
     * @type {DatasetRestApiGetUser1}
     * @memberof DatasetRestApiGet
     */
    owners?: DatasetRestApiGetUser1;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGet
     */
    schema?: string;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    selectStar?: any;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGet
     */
    sql?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGet
     */
    tableName: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGet
     */
    templateParams?: string;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    timeGrainSqla?: any;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    uid?: any;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    url?: any;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGet
     */
    verboseMap?: any;
}
/**
 * 
 * @export
 * @interface DatasetRestApiGetDatabase
 */
export interface DatasetRestApiGetDatabase {
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGetDatabase
     */
    backend?: any;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetDatabase
     */
    databaseName: string;
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiGetDatabase
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DatasetRestApiGetList
 */
export interface DatasetRestApiGetList {
    /**
     * 
     * @type {DatasetRestApiGetListUser}
     * @memberof DatasetRestApiGetList
     */
    changedBy?: DatasetRestApiGetListUser;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGetList
     */
    changedByName?: any;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGetList
     */
    changedByUrl?: any;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGetList
     */
    changedOnUtc?: any;
    /**
     * 
     * @type {DatasetRestApiGetListDatabase}
     * @memberof DatasetRestApiGetList
     */
    database: DatasetRestApiGetListDatabase;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGetList
     */
    datasourceType?: any;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetList
     */
    defaultEndpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetList
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGetList
     */
    exploreUrl?: any;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetList
     */
    extra?: string;
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGetList
     */
    kind?: any;
    /**
     * 
     * @type {DatasetRestApiGetListUser1}
     * @memberof DatasetRestApiGetList
     */
    owners?: DatasetRestApiGetListUser1;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetList
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetList
     */
    sql?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetList
     */
    tableName: string;
}
/**
 * 
 * @export
 * @interface DatasetRestApiGetListDatabase
 */
export interface DatasetRestApiGetListDatabase {
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetListDatabase
     */
    databaseName: string;
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiGetListDatabase
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DatasetRestApiGetListUser
 */
export interface DatasetRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetListUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetListUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface DatasetRestApiGetListUser1
 */
export interface DatasetRestApiGetListUser1 {
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetListUser1
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiGetListUser1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetListUser1
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface DatasetRestApiGetSqlMetric
 */
export interface DatasetRestApiGetSqlMetric {
    /**
     * 
     * @type {Date}
     * @memberof DatasetRestApiGetSqlMetric
     */
    changedOn?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DatasetRestApiGetSqlMetric
     */
    createdOn?: Date;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetSqlMetric
     */
    d3format?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetSqlMetric
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetSqlMetric
     */
    expression: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetSqlMetric
     */
    extra?: string;
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiGetSqlMetric
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetSqlMetric
     */
    metricName: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetSqlMetric
     */
    metricType?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetSqlMetric
     */
    verboseName?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetSqlMetric
     */
    warningText?: string;
}
/**
 * 
 * @export
 * @interface DatasetRestApiGetTableColumn
 */
export interface DatasetRestApiGetTableColumn {
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetTableColumn
     */
    advancedDataType?: string;
    /**
     * 
     * @type {Date}
     * @memberof DatasetRestApiGetTableColumn
     */
    changedOn?: Date;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetTableColumn
     */
    columnName: string;
    /**
     * 
     * @type {Date}
     * @memberof DatasetRestApiGetTableColumn
     */
    createdOn?: Date;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetTableColumn
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetTableColumn
     */
    expression?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetTableColumn
     */
    extra?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetRestApiGetTableColumn
     */
    filterable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetRestApiGetTableColumn
     */
    groupby?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiGetTableColumn
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetRestApiGetTableColumn
     */
    isActive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetRestApiGetTableColumn
     */
    isDttm?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetTableColumn
     */
    pythonDateFormat?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetTableColumn
     */
    type?: string;
    /**
     * 
     * @type {any}
     * @memberof DatasetRestApiGetTableColumn
     */
    typeGeneric?: any;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetTableColumn
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetTableColumn
     */
    verboseName?: string;
}
/**
 * 
 * @export
 * @interface DatasetRestApiGetUser
 */
export interface DatasetRestApiGetUser {
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface DatasetRestApiGetUser1
 */
export interface DatasetRestApiGetUser1 {
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetUser1
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiGetUser1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetUser1
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface DatasetRestApiGetUser2
 */
export interface DatasetRestApiGetUser2 {
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetUser2
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiGetUser2
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface DatasetRestApiPost
 */
export interface DatasetRestApiPost {
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiPost
     */
    database: number;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPost
     */
    externalUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetRestApiPost
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof DatasetRestApiPost
     */
    owners?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPost
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPost
     */
    sql?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPost
     */
    tableName: string;
}
/**
 * 
 * @export
 * @interface DatasetRestApiPut
 */
export interface DatasetRestApiPut {
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiPut
     */
    cacheTimeout?: number;
    /**
     * 
     * @type {Array<DatasetColumnsPut>}
     * @memberof DatasetRestApiPut
     */
    columns?: Array<DatasetColumnsPut>;
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiPut
     */
    databaseId?: number;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPut
     */
    defaultEndpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPut
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPut
     */
    externalUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPut
     */
    extra?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPut
     */
    fetchValuesPredicate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetRestApiPut
     */
    filterSelectEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetRestApiPut
     */
    isManagedExternally?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetRestApiPut
     */
    isSqllabView?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPut
     */
    mainDttmCol?: string;
    /**
     * 
     * @type {Array<DatasetMetricsPut>}
     * @memberof DatasetRestApiPut
     */
    metrics?: Array<DatasetMetricsPut>;
    /**
     * 
     * @type {number}
     * @memberof DatasetRestApiPut
     */
    offset?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DatasetRestApiPut
     */
    owners?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPut
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPut
     */
    sql?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPut
     */
    tableName?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRestApiPut
     */
    templateParams?: string;
}
/**
 * 
 * @export
 * @interface Datasource
 */
export interface Datasource {
    /**
     * Datasource name
     * @type {string}
     * @memberof Datasource
     */
    databaseName?: string;
    /**
     * The datasource name.
     * @type {string}
     * @memberof Datasource
     */
    datasourceName?: string;
    /**
     * The type of dataset/datasource identified on `datasource_id`.
     * @type {string}
     * @memberof Datasource
     */
    datasourceType: Datasource.DatasourceTypeEnum;
    /**
     * Datasource schema
     * @type {string}
     * @memberof Datasource
     */
    schema?: string;
}

/**
 * @export
 * @namespace Datasource
 */
export namespace Datasource {
    /**
     * @export
     * @enum {string}
     */
    export enum DatasourceTypeEnum {
        SlTable = <any> 'sl_table',
        Table = <any> 'table',
        Dataset = <any> 'dataset',
        Query = <any> 'query',
        SavedQuery = <any> 'saved_query',
        View = <any> 'view'
    }
}
/**
 * 
 * @export
 */
export type DeleteTagsSchema = Array<string>
/**
 * 
 * @export
 * @interface DistincResponseSchema
 */
export interface DistincResponseSchema {
    /**
     * The total number of distinct values
     * @type {number}
     * @memberof DistincResponseSchema
     */
    count?: number;
    /**
     * 
     * @type {Array<DistinctResultResponse>}
     * @memberof DistincResponseSchema
     */
    result?: Array<DistinctResultResponse>;
}
/**
 * 
 * @export
 * @interface DistinctResultResponse
 */
export interface DistinctResultResponse {
    /**
     * The distinct item
     * @type {string}
     * @memberof DistinctResultResponse
     */
    text?: string;
}
/**
 * 
 * @export
 * @interface EmbeddedDashboardConfig
 */
export interface EmbeddedDashboardConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmbeddedDashboardConfig
     */
    allowedDomains: Array<string>;
}
/**
 * 
 * @export
 * @interface EmbeddedDashboardResponseSchema
 */
export interface EmbeddedDashboardResponseSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmbeddedDashboardResponseSchema
     */
    allowedDomains?: Array<string>;
    /**
     * 
     * @type {User1}
     * @memberof EmbeddedDashboardResponseSchema
     */
    changedBy?: User1;
    /**
     * 
     * @type {Date}
     * @memberof EmbeddedDashboardResponseSchema
     */
    changedOn?: Date;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedDashboardResponseSchema
     */
    dashboardId?: string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedDashboardResponseSchema
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface EmbeddedDashboardRestApiGet
 */
export interface EmbeddedDashboardRestApiGet {
    /**
     * 
     * @type {string}
     * @memberof EmbeddedDashboardRestApiGet
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface EmbeddedDashboardRestApiGetList
 */
export interface EmbeddedDashboardRestApiGetList {
    /**
     * 
     * @type {string}
     * @memberof EmbeddedDashboardRestApiGetList
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface EmbeddedDashboardRestApiPost
 */
export interface EmbeddedDashboardRestApiPost {
    /**
     * 
     * @type {string}
     * @memberof EmbeddedDashboardRestApiPost
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface EmbeddedDashboardRestApiPut
 */
export interface EmbeddedDashboardRestApiPut {
    /**
     * 
     * @type {string}
     * @memberof EmbeddedDashboardRestApiPut
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface EstimateQueryCostSchema
 */
export interface EstimateQueryCostSchema {
    /**
     * The database id
     * @type {number}
     * @memberof EstimateQueryCostSchema
     */
    databaseId: number;
    /**
     * The database schema
     * @type {string}
     * @memberof EstimateQueryCostSchema
     */
    schema?: string;
    /**
     * The SQL query to estimate
     * @type {string}
     * @memberof EstimateQueryCostSchema
     */
    sql: string;
    /**
     * The SQL query template params
     * @type {any}
     * @memberof EstimateQueryCostSchema
     */
    templateParams?: any;
}
/**
 * 
 * @export
 * @interface ExecutePayloadSchema
 */
export interface ExecutePayloadSchema {
    /**
     * 
     * @type {string}
     * @memberof ExecutePayloadSchema
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutePayloadSchema
     */
    ctasMethod?: string;
    /**
     * 
     * @type {number}
     * @memberof ExecutePayloadSchema
     */
    databaseId: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExecutePayloadSchema
     */
    expandData?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExecutePayloadSchema
     */
    json?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExecutePayloadSchema
     */
    queryLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExecutePayloadSchema
     */
    runAsync?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExecutePayloadSchema
     */
    schema?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExecutePayloadSchema
     */
    selectAsCta?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExecutePayloadSchema
     */
    sql: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutePayloadSchema
     */
    sqlEditorId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutePayloadSchema
     */
    tab?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutePayloadSchema
     */
    templateParams?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutePayloadSchema
     */
    tmpTableName?: string;
}
/**
 * 
 * @export
 * @interface ExploreContextSchema
 */
export interface ExploreContextSchema {
    /**
     * 
     * @type {Dataset}
     * @memberof ExploreContextSchema
     */
    dataset?: Dataset;
    /**
     * Form data from the Explore controls used to form the chart's data query.
     * @type {any}
     * @memberof ExploreContextSchema
     */
    formData?: any;
    /**
     * Any message related to the processed request.
     * @type {string}
     * @memberof ExploreContextSchema
     */
    message?: string;
    /**
     * 
     * @type {Slice}
     * @memberof ExploreContextSchema
     */
    slice?: Slice;
}
/**
 * 
 * @export
 * @interface ExplorePermalinkStateSchema
 */
export interface ExplorePermalinkStateSchema {
    /**
     * Chart form data
     * @type {any}
     * @memberof ExplorePermalinkStateSchema
     */
    formData: any;
    /**
     * URL Parameters
     * @type {Array<any>}
     * @memberof ExplorePermalinkStateSchema
     */
    urlParams?: Array<any>;
}
/**
 * 
 * @export
 * @interface FilterSetRestApiGet
 */
export interface FilterSetRestApiGet {
    /**
     * 
     * @type {number}
     * @memberof FilterSetRestApiGet
     */
    dashboardId?: number;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiGet
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof FilterSetRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiGet
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof FilterSetRestApiGet
     */
    ownerId: number;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiGet
     */
    ownerType: string;
    /**
     * 
     * @type {any}
     * @memberof FilterSetRestApiGet
     */
    params?: any;
}
/**
 * 
 * @export
 * @interface FilterSetRestApiGetList
 */
export interface FilterSetRestApiGetList {
    /**
     * 
     * @type {number}
     * @memberof FilterSetRestApiGetList
     */
    changedByFk?: number;
    /**
     * 
     * @type {Date}
     * @memberof FilterSetRestApiGetList
     */
    changedOn?: Date;
    /**
     * 
     * @type {number}
     * @memberof FilterSetRestApiGetList
     */
    createdByFk?: number;
    /**
     * 
     * @type {Date}
     * @memberof FilterSetRestApiGetList
     */
    createdOn?: Date;
    /**
     * 
     * @type {number}
     * @memberof FilterSetRestApiGetList
     */
    dashboardId?: number;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiGetList
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof FilterSetRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiGetList
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof FilterSetRestApiGetList
     */
    ownerId: number;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiGetList
     */
    ownerType: string;
    /**
     * 
     * @type {any}
     * @memberof FilterSetRestApiGetList
     */
    params?: any;
}
/**
 * 
 * @export
 * @interface FilterSetRestApiPost
 */
export interface FilterSetRestApiPost {
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiPost
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiPost
     */
    jsonMetadata: string;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiPost
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof FilterSetRestApiPost
     */
    ownerId?: number;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiPost
     */
    ownerType: FilterSetRestApiPost.OwnerTypeEnum;
}

/**
 * @export
 * @namespace FilterSetRestApiPost
 */
export namespace FilterSetRestApiPost {
    /**
     * @export
     * @enum {string}
     */
    export enum OwnerTypeEnum {
        User = <any> 'User',
        Dashboard = <any> 'Dashboard'
    }
}
/**
 * 
 * @export
 * @interface FilterSetRestApiPut
 */
export interface FilterSetRestApiPut {
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiPut
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiPut
     */
    jsonMetadata?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiPut
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterSetRestApiPut
     */
    ownerType?: FilterSetRestApiPut.OwnerTypeEnum;
}

/**
 * @export
 * @namespace FilterSetRestApiPut
 */
export namespace FilterSetRestApiPut {
    /**
     * @export
     * @enum {string}
     */
    export enum OwnerTypeEnum {
        Dashboard = <any> 'Dashboard'
    }
}
/**
 * 
 * @export
 * @interface FormDataPostSchema
 */
export interface FormDataPostSchema {
    /**
     * The chart ID
     * @type {number}
     * @memberof FormDataPostSchema
     */
    chartId?: number;
    /**
     * The datasource ID
     * @type {number}
     * @memberof FormDataPostSchema
     */
    datasourceId: number;
    /**
     * The datasource type
     * @type {string}
     * @memberof FormDataPostSchema
     */
    datasourceType: FormDataPostSchema.DatasourceTypeEnum;
    /**
     * Any type of JSON supported text.
     * @type {string}
     * @memberof FormDataPostSchema
     */
    formData: string;
}

/**
 * @export
 * @namespace FormDataPostSchema
 */
export namespace FormDataPostSchema {
    /**
     * @export
     * @enum {string}
     */
    export enum DatasourceTypeEnum {
        SlTable = <any> 'sl_table',
        Table = <any> 'table',
        Dataset = <any> 'dataset',
        Query = <any> 'query',
        SavedQuery = <any> 'saved_query',
        View = <any> 'view'
    }
}
/**
 * 
 * @export
 * @interface FormDataPutSchema
 */
export interface FormDataPutSchema {
    /**
     * The chart ID
     * @type {number}
     * @memberof FormDataPutSchema
     */
    chartId?: number;
    /**
     * The datasource ID
     * @type {number}
     * @memberof FormDataPutSchema
     */
    datasourceId: number;
    /**
     * The datasource type
     * @type {string}
     * @memberof FormDataPutSchema
     */
    datasourceType: FormDataPutSchema.DatasourceTypeEnum;
    /**
     * Any type of JSON supported text.
     * @type {string}
     * @memberof FormDataPutSchema
     */
    formData: string;
}

/**
 * @export
 * @namespace FormDataPutSchema
 */
export namespace FormDataPutSchema {
    /**
     * @export
     * @enum {string}
     */
    export enum DatasourceTypeEnum {
        SlTable = <any> 'sl_table',
        Table = <any> 'table',
        Dataset = <any> 'dataset',
        Query = <any> 'query',
        SavedQuery = <any> 'saved_query',
        View = <any> 'view'
    }
}
/**
 * 
 * @export
 */
export type GetDeleteIdsSchema = Array<number>
/**
 * 
 * @export
 */
export type GetExportIdsSchema = Array<number>
/**
 * 
 * @export
 */
export type GetFavStarIdsSchema = Array<number>
/**
 * 
 * @export
 * @interface GetInfoSchema
 */
export interface GetInfoSchema {
    /**
     * 
     * @type {{ [key: string]: GetInfoSchemaAddColumns; }}
     * @memberof GetInfoSchema
     */
    addColumns?: { [key: string]: GetInfoSchemaAddColumns; };
    /**
     * 
     * @type {{ [key: string]: GetInfoSchemaAddColumns; }}
     * @memberof GetInfoSchema
     */
    editColumns?: { [key: string]: GetInfoSchemaAddColumns; };
    /**
     * 
     * @type {Array<string>}
     * @memberof GetInfoSchema
     */
    keys?: Array<GetInfoSchema.KeysEnum>;
}

/**
 * @export
 * @namespace GetInfoSchema
 */
export namespace GetInfoSchema {
    /**
     * @export
     * @enum {string}
     */
    export enum KeysEnum {
        AddColumns = <any> 'add_columns',
        EditColumns = <any> 'edit_columns',
        Filters = <any> 'filters',
        Permissions = <any> 'permissions',
        AddTitle = <any> 'add_title',
        EditTitle = <any> 'edit_title',
        None = <any> 'none'
    }
}
/**
 * 
 * @export
 * @interface GetInfoSchemaAddColumns
 */
export interface GetInfoSchemaAddColumns {
    /**
     * 
     * @type {number}
     * @memberof GetInfoSchemaAddColumns
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof GetInfoSchemaAddColumns
     */
    pageSize?: number;
}
/**
 * 
 * @export
 * @interface GetItemSchema
 */
export interface GetItemSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetItemSchema
     */
    columns?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetItemSchema
     */
    keys?: Array<GetItemSchema.KeysEnum>;
}

/**
 * @export
 * @namespace GetItemSchema
 */
export namespace GetItemSchema {
    /**
     * @export
     * @enum {string}
     */
    export enum KeysEnum {
        ShowColumns = <any> 'show_columns',
        DescriptionColumns = <any> 'description_columns',
        LabelColumns = <any> 'label_columns',
        ShowTitle = <any> 'show_title',
        None = <any> 'none'
    }
}
/**
 * 
 * @export
 * @interface GetListSchema
 */
export interface GetListSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetListSchema
     */
    columns?: Array<string>;
    /**
     * 
     * @type {Array<GetListSchemaFilters>}
     * @memberof GetListSchema
     */
    filters?: Array<GetListSchemaFilters>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetListSchema
     */
    keys?: Array<GetListSchema.KeysEnum>;
    /**
     * 
     * @type {string}
     * @memberof GetListSchema
     */
    orderColumn?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListSchema
     */
    orderDirection?: GetListSchema.OrderDirectionEnum;
    /**
     * 
     * @type {number}
     * @memberof GetListSchema
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof GetListSchema
     */
    pageSize?: number;
}

/**
 * @export
 * @namespace GetListSchema
 */
export namespace GetListSchema {
    /**
     * @export
     * @enum {string}
     */
    export enum KeysEnum {
        ListColumns = <any> 'list_columns',
        OrderColumns = <any> 'order_columns',
        LabelColumns = <any> 'label_columns',
        DescriptionColumns = <any> 'description_columns',
        ListTitle = <any> 'list_title',
        None = <any> 'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OrderDirectionEnum {
        Asc = <any> 'asc',
        Desc = <any> 'desc'
    }
}
/**
 * 
 * @export
 * @interface GetListSchemaFilters
 */
export interface GetListSchemaFilters {
    /**
     * 
     * @type {string}
     * @memberof GetListSchemaFilters
     */
    col: string;
    /**
     * 
     * @type {string}
     * @memberof GetListSchemaFilters
     */
    opr: string;
    /**
     * 
     * @type {number | string | boolean | Array}
     * @memberof GetListSchemaFilters
     */
    value: number | string | boolean | Array<any>;
}
/**
 * 
 * @export
 * @interface GetOrCreateDatasetSchema
 */
export interface GetOrCreateDatasetSchema {
    /**
     * ID of database table belongs to
     * @type {number}
     * @memberof GetOrCreateDatasetSchema
     */
    databaseId: number;
    /**
     * The schema the table belongs to
     * @type {string}
     * @memberof GetOrCreateDatasetSchema
     */
    schema?: string;
    /**
     * Name of table
     * @type {string}
     * @memberof GetOrCreateDatasetSchema
     */
    tableName: string;
    /**
     * Template params for the table
     * @type {string}
     * @memberof GetOrCreateDatasetSchema
     */
    templateParams?: string;
}
/**
 * 
 * @export
 * @interface GetRecentActivitySchema
 */
export interface GetRecentActivitySchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetRecentActivitySchema
     */
    actions?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof GetRecentActivitySchema
     */
    distinct?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetRecentActivitySchema
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof GetRecentActivitySchema
     */
    pageSize?: number;
}
/**
 * 
 * @export
 * @interface GetRelatedSchema
 */
export interface GetRelatedSchema {
    /**
     * 
     * @type {string}
     * @memberof GetRelatedSchema
     */
    filter?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof GetRelatedSchema
     */
    includeIds?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof GetRelatedSchema
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof GetRelatedSchema
     */
    pageSize?: number;
}
/**
 * 
 * @export
 * @interface GuestTokenCreate
 */
export interface GuestTokenCreate {
    /**
     * 
     * @type {Array<Resource>}
     * @memberof GuestTokenCreate
     */
    resources: Array<Resource>;
    /**
     * 
     * @type {Array<RlsRule>}
     * @memberof GuestTokenCreate
     */
    rls: Array<RlsRule>;
    /**
     * 
     * @type {User2}
     * @memberof GuestTokenCreate
     */
    user?: User2;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse200
     */
    result?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse2001
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse2001
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse2001
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse2001
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse2001
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse2001
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse2001
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<AnnotationLayerRestApiGetList>}
     * @memberof InlineResponse2001
     */
    result?: Array<AnnotationLayerRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20010
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20010
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse20010
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20010
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20010
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20010
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse20010
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<ChartRestApiGetList>}
     * @memberof InlineResponse20010
     */
    result?: Array<ChartRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20011
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * The item id
     * @type {string}
     * @memberof InlineResponse20011
     */
    id?: string;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20011
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * 
     * @type {ChartRestApiGet}
     * @memberof InlineResponse20011
     */
    result?: ChartRestApiGet;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20011
     */
    showColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20011
     */
    showTitle?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012
     */
    id?: number;
    /**
     * 
     * @type {ChartRestApiPut}
     * @memberof InlineResponse20012
     */
    result?: ChartRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20013
     */
    result?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20014
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20014
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse20014
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20014
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20014
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20014
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse20014
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<CssTemplateRestApiGetList>}
     * @memberof InlineResponse20014
     */
    result?: Array<CssTemplateRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20015
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * The item id
     * @type {string}
     * @memberof InlineResponse20015
     */
    id?: string;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20015
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * 
     * @type {CssTemplateRestApiGet}
     * @memberof InlineResponse20015
     */
    result?: CssTemplateRestApiGet;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20015
     */
    showColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20015
     */
    showTitle?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * 
     * @type {CssTemplateRestApiPut}
     * @memberof InlineResponse20016
     */
    result?: CssTemplateRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20017
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20017
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse20017
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20017
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20017
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20017
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse20017
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<DashboardRestApiGetList>}
     * @memberof InlineResponse20017
     */
    result?: Array<DashboardRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * The stored state
     * @type {any}
     * @memberof InlineResponse20018
     */
    state?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * A description field of the filter set
     * @type {string}
     * @memberof InlineResponse20019
     */
    description?: string;
    /**
     * metadata of the filter set
     * @type {string}
     * @memberof InlineResponse20019
     */
    jsonMetadata?: string;
    /**
     * Name of the Filter set
     * @type {string}
     * @memberof InlineResponse20019
     */
    name?: string;
    /**
     * A description field of the filter set
     * @type {number}
     * @memberof InlineResponse20019
     */
    ownerId?: number;
    /**
     * the Type of the owner ( Dashboard/User)
     * @type {number}
     * @memberof InlineResponse20019
     */
    ownerType?: number;
    /**
     * JSON schema defining the needed parameters
     * @type {any}
     * @memberof InlineResponse20019
     */
    parameters?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse2001DescriptionColumns
 */
export interface InlineResponse2001DescriptionColumns {
    /**
     * The description for the column name. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse2001DescriptionColumns
     */
    columnName?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2001LabelColumns
 */
export interface InlineResponse2001LabelColumns {
    /**
     * The label for the column name. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse2001LabelColumns
     */
    columnName?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {any}
     * @memberof InlineResponse2002
     */
    addColumns?: any;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse2002
     */
    editColumns?: any;
    /**
     * 
     * @type {InlineResponse2002Filters}
     * @memberof InlineResponse2002
     */
    filters?: InlineResponse2002Filters;
    /**
     * The user permissions for this API resource
     * @type {Array<string>}
     * @memberof InlineResponse2002
     */
    permissions?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20020
     */
    id?: number;
    /**
     * 
     * @type {FilterSetRestApiPut}
     * @memberof InlineResponse20020
     */
    result?: FilterSetRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * 
     * @type {DashboardGetResponseSchema}
     * @memberof InlineResponse20021
     */
    result?: DashboardGetResponseSchema;
}
/**
 * 
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * 
     * @type {Array<ChartEntityResponseSchema>}
     * @memberof InlineResponse20022
     */
    result?: Array<ChartEntityResponseSchema>;
}
/**
 * 
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20023
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20023
     */
    lastModifiedTime?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     * 
     * @type {Array<DashboardDatasetSchema>}
     * @memberof InlineResponse20024
     */
    result?: Array<DashboardDatasetSchema>;
}
/**
 * 
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * 
     * @type {EmbeddedDashboardResponseSchema}
     * @memberof InlineResponse20025
     */
    result?: EmbeddedDashboardResponseSchema;
}
/**
 * 
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20026
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20026
     */
    lastModifiedTime?: number;
    /**
     * 
     * @type {DashboardRestApiPut}
     * @memberof InlineResponse20026
     */
    result?: DashboardRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * The stored value
     * @type {string}
     * @memberof InlineResponse20027
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     * The result of the operation
     * @type {string}
     * @memberof InlineResponse20028
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20029
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20029
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse20029
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20029
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20029
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20029
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse20029
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<DatabaseRestApiGetList>}
     * @memberof InlineResponse20029
     */
    result?: Array<DatabaseRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Filters
 */
export interface InlineResponse2002Filters {
    /**
     * 
     * @type {Array<InlineResponse2002FiltersColumnName>}
     * @memberof InlineResponse2002Filters
     */
    columnName?: Array<InlineResponse2002FiltersColumnName>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002FiltersColumnName
 */
export interface InlineResponse2002FiltersColumnName {
    /**
     * The filter name. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse2002FiltersColumnName
     */
    name?: string;
    /**
     * The filter operation key to use on list filters
     * @type {string}
     * @memberof InlineResponse2002FiltersColumnName
     */
    operator?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse2003
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * The item id
     * @type {string}
     * @memberof InlineResponse2003
     */
    id?: string;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse2003
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * 
     * @type {AnnotationLayerRestApiGet}
     * @memberof InlineResponse2003
     */
    result?: AnnotationLayerRestApiGet;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse2003
     */
    showColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse2003
     */
    showTitle?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     * Installed drivers for the engine
     * @type {Array<string>}
     * @memberof InlineResponse20030
     */
    availableDrivers?: Array<string>;
    /**
     * Default driver for the engine
     * @type {string}
     * @memberof InlineResponse20030
     */
    defaultDriver?: string;
    /**
     * Name of the SQLAlchemy engine
     * @type {string}
     * @memberof InlineResponse20030
     */
    engine?: string;
    /**
     * 
     * @type {Apiv1databaseavailableEngineInformation}
     * @memberof InlineResponse20030
     */
    engineInformation?: Apiv1databaseavailableEngineInformation;
    /**
     * Name of the database
     * @type {string}
     * @memberof InlineResponse20030
     */
    name?: string;
    /**
     * JSON schema defining the needed parameters
     * @type {any}
     * @memberof InlineResponse20030
     */
    parameters?: any;
    /**
     * Is the database preferred?
     * @type {boolean}
     * @memberof InlineResponse20030
     */
    preferred?: boolean;
    /**
     * Example placeholder for the SQLAlchemy URI
     * @type {string}
     * @memberof InlineResponse20030
     */
    sqlalchemyUriPlaceholder?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20031
     */
    id?: number;
    /**
     * 
     * @type {DatabaseRestApiPut}
     * @memberof InlineResponse20031
     */
    result?: DatabaseRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20032
     */
    count?: number;
    /**
     * A List of tables for given database
     * @type {Array<DatabaseTablesResponse>}
     * @memberof InlineResponse20032
     */
    result?: Array<DatabaseTablesResponse>;
}
/**
 * 
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     * A List of SQL errors found on the statement
     * @type {Array<ValidateSQLResponse>}
     * @memberof InlineResponse20033
     */
    result?: Array<ValidateSQLResponse>;
}
/**
 * 
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20034
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20034
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse20034
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20034
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20034
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20034
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse20034
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<DatasetRestApiGetList>}
     * @memberof InlineResponse20034
     */
    result?: Array<DatasetRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     * 
     * @type {InlineResponse20035Result}
     * @memberof InlineResponse20035
     */
    result?: InlineResponse20035Result;
}
/**
 * 
 * @export
 * @interface InlineResponse20035Result
 */
export interface InlineResponse20035Result {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20035Result
     */
    tableId?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20036
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * The item id
     * @type {string}
     * @memberof InlineResponse20036
     */
    id?: string;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20036
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * 
     * @type {DatasetRestApiGet}
     * @memberof InlineResponse20036
     */
    result?: DatasetRestApiGet;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20036
     */
    showColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20036
     */
    showTitle?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20037
     */
    id?: number;
    /**
     * 
     * @type {DatasetRestApiPut}
     * @memberof InlineResponse20037
     */
    result?: DatasetRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     * 
     * @type {Array<string | number | boolean | any>}
     * @memberof InlineResponse20038
     */
    result?: Array<string | number | boolean | any>;
}
/**
 * 
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     * The stored form_data
     * @type {string}
     * @memberof InlineResponse20039
     */
    formData?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    id?: number;
    /**
     * 
     * @type {AnnotationLayerRestApiPut}
     * @memberof InlineResponse2004
     */
    result?: AnnotationLayerRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20040
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20040
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse20040
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20040
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20040
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20040
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse20040
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<LogRestApiGetList>}
     * @memberof InlineResponse20040
     */
    result?: Array<LogRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20041
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * The item id
     * @type {string}
     * @memberof InlineResponse20041
     */
    id?: string;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20041
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * 
     * @type {LogRestApiGet}
     * @memberof InlineResponse20041
     */
    result?: LogRestApiGet;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20041
     */
    showColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20041
     */
    showTitle?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20042
 */
export interface InlineResponse20042 {
    /**
     * 
     * @type {UserResponseSchema}
     * @memberof InlineResponse20042
     */
    result?: UserResponseSchema;
}
/**
 * 
 * @export
 * @interface InlineResponse20043
 */
export interface InlineResponse20043 {
    /**
     * Menu items in a forest like data structure
     * @type {Array<InlineResponse20043Result>}
     * @memberof InlineResponse20043
     */
    result?: Array<InlineResponse20043Result>;
}
/**
 * 
 * @export
 * @interface InlineResponse20043Result
 */
export interface InlineResponse20043Result {
    /**
     * 
     * @type {Array<any>}
     * @memberof InlineResponse20043Result
     */
    childs?: Array<any>;
    /**
     * Icon name to show for this menu item
     * @type {string}
     * @memberof InlineResponse20043Result
     */
    icon?: string;
    /**
     * Pretty name for the menu item
     * @type {string}
     * @memberof InlineResponse20043Result
     */
    label?: string;
    /**
     * The internal menu item name, maps to permission_name
     * @type {string}
     * @memberof InlineResponse20043Result
     */
    name?: string;
    /**
     * The URL for the menu item
     * @type {string}
     * @memberof InlineResponse20043Result
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20044
 */
export interface InlineResponse20044 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20044
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20044
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse20044
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20044
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20044
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20044
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse20044
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<QueryRestApiGetList>}
     * @memberof InlineResponse20044
     */
    result?: Array<QueryRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20045
 */
export interface InlineResponse20045 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20046
 */
export interface InlineResponse20046 {
    /**
     * A List of queries that changed after last_updated_ms
     * @type {Array<QueryRestApiGet>}
     * @memberof InlineResponse20046
     */
    result?: Array<QueryRestApiGet>;
}
/**
 * 
 * @export
 * @interface InlineResponse20047
 */
export interface InlineResponse20047 {
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20047
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * The item id
     * @type {string}
     * @memberof InlineResponse20047
     */
    id?: string;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20047
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * 
     * @type {QueryRestApiGet}
     * @memberof InlineResponse20047
     */
    result?: QueryRestApiGet;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20047
     */
    showColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20047
     */
    showTitle?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20048
 */
export interface InlineResponse20048 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20048
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20048
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse20048
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20048
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20048
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20048
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse20048
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<ReportScheduleRestApiGetList>}
     * @memberof InlineResponse20048
     */
    result?: Array<ReportScheduleRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20049
 */
export interface InlineResponse20049 {
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20049
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * The item id
     * @type {string}
     * @memberof InlineResponse20049
     */
    id?: string;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20049
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * 
     * @type {ReportScheduleRestApiGet}
     * @memberof InlineResponse20049
     */
    result?: ReportScheduleRestApiGet;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20049
     */
    showColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20049
     */
    showTitle?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse2005
     */
    count?: number;
    /**
     * A list of annotation ids
     * @type {Array<string>}
     * @memberof InlineResponse2005
     */
    ids?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<AnnotationRestApiGetList>}
     * @memberof InlineResponse2005
     */
    result?: Array<AnnotationRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20050
 */
export interface InlineResponse20050 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20050
     */
    id?: number;
    /**
     * 
     * @type {ReportScheduleRestApiPut}
     * @memberof InlineResponse20050
     */
    result?: ReportScheduleRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse20051
 */
export interface InlineResponse20051 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20051
     */
    count?: number;
    /**
     * A list of log ids
     * @type {Array<string>}
     * @memberof InlineResponse20051
     */
    ids?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<ReportExecutionLogRestApiGetList>}
     * @memberof InlineResponse20051
     */
    result?: Array<ReportExecutionLogRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20052
 */
export interface InlineResponse20052 {
    /**
     * The log id
     * @type {string}
     * @memberof InlineResponse20052
     */
    id?: string;
    /**
     * 
     * @type {ReportExecutionLogRestApiGet}
     * @memberof InlineResponse20052
     */
    result?: ReportExecutionLogRestApiGet;
}
/**
 * 
 * @export
 * @interface InlineResponse20053
 */
export interface InlineResponse20053 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20053
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20053
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse20053
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20053
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20053
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20053
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse20053
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<RLSRestApiGetList>}
     * @memberof InlineResponse20053
     */
    result?: Array<RLSRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20054
 */
export interface InlineResponse20054 {
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20054
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * The item id
     * @type {string}
     * @memberof InlineResponse20054
     */
    id?: string;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20054
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * 
     * @type {RLSRestApiGet}
     * @memberof InlineResponse20054
     */
    result?: RLSRestApiGet;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20054
     */
    showColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20054
     */
    showTitle?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20055
 */
export interface InlineResponse20055 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20055
     */
    id?: number;
    /**
     * 
     * @type {RLSRestApiPut}
     * @memberof InlineResponse20055
     */
    result?: RLSRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse20056
 */
export interface InlineResponse20056 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20056
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20056
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse20056
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20056
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20056
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20056
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse20056
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<SavedQueryRestApiGetList>}
     * @memberof InlineResponse20056
     */
    result?: Array<SavedQueryRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20057
 */
export interface InlineResponse20057 {
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20057
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * The item id
     * @type {string}
     * @memberof InlineResponse20057
     */
    id?: string;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20057
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * 
     * @type {SavedQueryRestApiGet}
     * @memberof InlineResponse20057
     */
    result?: SavedQueryRestApiGet;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20057
     */
    showColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20057
     */
    showTitle?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20058
 */
export interface InlineResponse20058 {
    /**
     * 
     * @type {SavedQueryRestApiPut}
     * @memberof InlineResponse20058
     */
    result?: SavedQueryRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse20059
 */
export interface InlineResponse20059 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20059
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * The item id
     * @type {string}
     * @memberof InlineResponse2006
     */
    id?: string;
    /**
     * 
     * @type {AnnotationRestApiGet}
     * @memberof InlineResponse2006
     */
    result?: AnnotationRestApiGet;
}
/**
 * 
 * @export
 * @interface InlineResponse20060
 */
export interface InlineResponse20060 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060
     */
    refreshToken?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20061
 */
export interface InlineResponse20061 {
    /**
     * A new refreshed access token
     * @type {string}
     * @memberof InlineResponse20061
     */
    accessToken?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20062
 */
export interface InlineResponse20062 {
    /**
     * The total record count on the backend
     * @type {number}
     * @memberof InlineResponse20062
     */
    count?: number;
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20062
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * A list of item ids, useful when you don't know the column id
     * @type {Array<string>}
     * @memberof InlineResponse20062
     */
    ids?: Array<string>;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20062
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20062
     */
    listColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20062
     */
    listTitle?: string;
    /**
     * A list of allowed columns to sort
     * @type {Array<string>}
     * @memberof InlineResponse20062
     */
    orderColumns?: Array<string>;
    /**
     * The result from the get list query
     * @type {Array<TagRestApiGetList>}
     * @memberof InlineResponse20062
     */
    result?: Array<TagRestApiGetList>;
}
/**
 * 
 * @export
 * @interface InlineResponse20063
 */
export interface InlineResponse20063 {
    /**
     * 
     * @type {Array<TaggedObjectEntityResponseSchema>}
     * @memberof InlineResponse20063
     */
    result?: Array<TaggedObjectEntityResponseSchema>;
}
/**
 * 
 * @export
 * @interface InlineResponse20064
 */
export interface InlineResponse20064 {
    /**
     * 
     * @type {InlineResponse2001DescriptionColumns}
     * @memberof InlineResponse20064
     */
    descriptionColumns?: InlineResponse2001DescriptionColumns;
    /**
     * The item id
     * @type {string}
     * @memberof InlineResponse20064
     */
    id?: string;
    /**
     * 
     * @type {InlineResponse2001LabelColumns}
     * @memberof InlineResponse20064
     */
    labelColumns?: InlineResponse2001LabelColumns;
    /**
     * 
     * @type {TagRestApiGet}
     * @memberof InlineResponse20064
     */
    result?: TagRestApiGet;
    /**
     * A list of columns
     * @type {Array<string>}
     * @memberof InlineResponse20064
     */
    showColumns?: Array<string>;
    /**
     * A title to render. Will be translated by babel
     * @type {string}
     * @memberof InlineResponse20064
     */
    showTitle?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20065
 */
export interface InlineResponse20065 {
    /**
     * 
     * @type {TagRestApiPut}
     * @memberof InlineResponse20065
     */
    result?: TagRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007
     */
    id?: number;
    /**
     * 
     * @type {AnnotationRestApiPut}
     * @memberof InlineResponse2007
     */
    result?: AnnotationRestApiPut;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {Array<InlineResponse2008Result>}
     * @memberof InlineResponse2008
     */
    result?: Array<InlineResponse2008Result>;
}
/**
 * 
 * @export
 * @interface InlineResponse2008Result
 */
export interface InlineResponse2008Result {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Result
     */
    channelId?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof InlineResponse2008Result
     */
    errors?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Result
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Result
     */
    jobId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Result
     */
    resultUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Result
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008Result
     */
    userId?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {AvailableDomainsSchema}
     * @memberof InlineResponse2009
     */
    result?: AvailableDomainsSchema;
}
/**
 * 
 * @export
 * @interface InlineResponse201
 */
export interface InlineResponse201 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse201
     */
    id?: number;
    /**
     * 
     * @type {AnnotationLayerRestApiPost}
     * @memberof InlineResponse201
     */
    result?: AnnotationLayerRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse2011
 */
export interface InlineResponse2011 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2011
     */
    id?: number;
    /**
     * 
     * @type {AnnotationRestApiPost}
     * @memberof InlineResponse2011
     */
    result?: AnnotationRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse20110
 */
export interface InlineResponse20110 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20110
     */
    id?: number;
    /**
     * 
     * @type {DatasetDuplicateSchema}
     * @memberof InlineResponse20110
     */
    result?: DatasetDuplicateSchema;
}
/**
 * 
 * @export
 * @interface InlineResponse20111
 */
export interface InlineResponse20111 {
    /**
     * The key to retrieve the form_data.
     * @type {string}
     * @memberof InlineResponse20111
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20112
 */
export interface InlineResponse20112 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20112
     */
    id?: string;
    /**
     * 
     * @type {LogRestApiPost}
     * @memberof InlineResponse20112
     */
    result?: LogRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse20113
 */
export interface InlineResponse20113 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20113
     */
    id?: number;
    /**
     * 
     * @type {ReportScheduleRestApiPost}
     * @memberof InlineResponse20113
     */
    result?: ReportScheduleRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse20114
 */
export interface InlineResponse20114 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20114
     */
    id?: number;
    /**
     * 
     * @type {RLSRestApiPost}
     * @memberof InlineResponse20114
     */
    result?: RLSRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse20115
 */
export interface InlineResponse20115 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20115
     */
    id?: string;
    /**
     * 
     * @type {SavedQueryRestApiPost}
     * @memberof InlineResponse20115
     */
    result?: SavedQueryRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse20116
 */
export interface InlineResponse20116 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20116
     */
    id?: string;
    /**
     * 
     * @type {TagRestApiPost}
     * @memberof InlineResponse20116
     */
    result?: TagRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse2012
 */
export interface InlineResponse2012 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2012
     */
    id?: number;
    /**
     * 
     * @type {ChartRestApiPost}
     * @memberof InlineResponse2012
     */
    result?: ChartRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse2013
 */
export interface InlineResponse2013 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2013
     */
    id?: string;
    /**
     * 
     * @type {CssTemplateRestApiPost}
     * @memberof InlineResponse2013
     */
    result?: CssTemplateRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse2014
 */
export interface InlineResponse2014 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2014
     */
    id?: number;
    /**
     * 
     * @type {DashboardRestApiPost}
     * @memberof InlineResponse2014
     */
    result?: DashboardRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse2015
 */
export interface InlineResponse2015 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2015
     */
    id?: number;
    /**
     * 
     * @type {FilterSetRestApiPost}
     * @memberof InlineResponse2015
     */
    result?: FilterSetRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse2016
 */
export interface InlineResponse2016 {
    /**
     * The key to retrieve the value.
     * @type {string}
     * @memberof InlineResponse2016
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2017
 */
export interface InlineResponse2017 {
    /**
     * The key to retrieve the permanent link data.
     * @type {string}
     * @memberof InlineResponse2017
     */
    key?: string;
    /**
     * permanent link.
     * @type {string}
     * @memberof InlineResponse2017
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2018
 */
export interface InlineResponse2018 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2018
     */
    id?: number;
    /**
     * 
     * @type {DatabaseRestApiPost}
     * @memberof InlineResponse2018
     */
    result?: DatabaseRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse2019
 */
export interface InlineResponse2019 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2019
     */
    id?: number;
    /**
     * 
     * @type {DatasetRestApiPost}
     * @memberof InlineResponse2019
     */
    result?: DatasetRestApiPost;
}
/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse410
 */
export interface InlineResponse410 {
    /**
     * 
     * @type {Array<InlineResponse410Errors>}
     * @memberof InlineResponse410
     */
    errors?: Array<InlineResponse410Errors>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse410
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse410Errors
 */
export interface InlineResponse410Errors {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse410Errors
     */
    errorType?: InlineResponse410Errors.ErrorTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse410Errors
     */
    extra?: any;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse410Errors
     */
    level?: InlineResponse410Errors.LevelEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse410Errors
     */
    message?: string;
}

/**
 * @export
 * @namespace InlineResponse410Errors
 */
export namespace InlineResponse410Errors {
    /**
     * @export
     * @enum {string}
     */
    export enum ErrorTypeEnum {
        FRONTENDCSRFERROR = <any> 'FRONTEND_CSRF_ERROR',
        FRONTENDNETWORKERROR = <any> 'FRONTEND_NETWORK_ERROR',
        FRONTENDTIMEOUTERROR = <any> 'FRONTEND_TIMEOUT_ERROR',
        GENERICDBENGINEERROR = <any> 'GENERIC_DB_ENGINE_ERROR',
        COLUMNDOESNOTEXISTERROR = <any> 'COLUMN_DOES_NOT_EXIST_ERROR',
        TABLEDOESNOTEXISTERROR = <any> 'TABLE_DOES_NOT_EXIST_ERROR',
        SCHEMADOESNOTEXISTERROR = <any> 'SCHEMA_DOES_NOT_EXIST_ERROR',
        CONNECTIONINVALIDUSERNAMEERROR = <any> 'CONNECTION_INVALID_USERNAME_ERROR',
        CONNECTIONINVALIDPASSWORDERROR = <any> 'CONNECTION_INVALID_PASSWORD_ERROR',
        CONNECTIONINVALIDHOSTNAMEERROR = <any> 'CONNECTION_INVALID_HOSTNAME_ERROR',
        CONNECTIONPORTCLOSEDERROR = <any> 'CONNECTION_PORT_CLOSED_ERROR',
        CONNECTIONINVALIDPORTERROR = <any> 'CONNECTION_INVALID_PORT_ERROR',
        CONNECTIONHOSTDOWNERROR = <any> 'CONNECTION_HOST_DOWN_ERROR',
        CONNECTIONACCESSDENIEDERROR = <any> 'CONNECTION_ACCESS_DENIED_ERROR',
        CONNECTIONUNKNOWNDATABASEERROR = <any> 'CONNECTION_UNKNOWN_DATABASE_ERROR',
        CONNECTIONDATABASEPERMISSIONSERROR = <any> 'CONNECTION_DATABASE_PERMISSIONS_ERROR',
        CONNECTIONMISSINGPARAMETERSERROR = <any> 'CONNECTION_MISSING_PARAMETERS_ERROR',
        OBJECTDOESNOTEXISTERROR = <any> 'OBJECT_DOES_NOT_EXIST_ERROR',
        SYNTAXERROR = <any> 'SYNTAX_ERROR',
        CONNECTIONDATABASETIMEOUT = <any> 'CONNECTION_DATABASE_TIMEOUT',
        VIZGETDFERROR = <any> 'VIZ_GET_DF_ERROR',
        UNKNOWNDATASOURCETYPEERROR = <any> 'UNKNOWN_DATASOURCE_TYPE_ERROR',
        FAILEDFETCHINGDATASOURCEINFOERROR = <any> 'FAILED_FETCHING_DATASOURCE_INFO_ERROR',
        TABLESECURITYACCESSERROR = <any> 'TABLE_SECURITY_ACCESS_ERROR',
        DATASOURCESECURITYACCESSERROR = <any> 'DATASOURCE_SECURITY_ACCESS_ERROR',
        DATABASESECURITYACCESSERROR = <any> 'DATABASE_SECURITY_ACCESS_ERROR',
        QUERYSECURITYACCESSERROR = <any> 'QUERY_SECURITY_ACCESS_ERROR',
        MISSINGOWNERSHIPERROR = <any> 'MISSING_OWNERSHIP_ERROR',
        USERACTIVITYSECURITYACCESSERROR = <any> 'USER_ACTIVITY_SECURITY_ACCESS_ERROR',
        BACKENDTIMEOUTERROR = <any> 'BACKEND_TIMEOUT_ERROR',
        DATABASENOTFOUNDERROR = <any> 'DATABASE_NOT_FOUND_ERROR',
        MISSINGTEMPLATEPARAMSERROR = <any> 'MISSING_TEMPLATE_PARAMS_ERROR',
        INVALIDTEMPLATEPARAMSERROR = <any> 'INVALID_TEMPLATE_PARAMS_ERROR',
        RESULTSBACKENDNOTCONFIGUREDERROR = <any> 'RESULTS_BACKEND_NOT_CONFIGURED_ERROR',
        DMLNOTALLOWEDERROR = <any> 'DML_NOT_ALLOWED_ERROR',
        INVALIDCTASQUERYERROR = <any> 'INVALID_CTAS_QUERY_ERROR',
        INVALIDCVASQUERYERROR = <any> 'INVALID_CVAS_QUERY_ERROR',
        SQLLABTIMEOUTERROR = <any> 'SQLLAB_TIMEOUT_ERROR',
        RESULTSBACKENDERROR = <any> 'RESULTS_BACKEND_ERROR',
        ASYNCWORKERSERROR = <any> 'ASYNC_WORKERS_ERROR',
        ADHOCSUBQUERYNOTALLOWEDERROR = <any> 'ADHOC_SUBQUERY_NOT_ALLOWED_ERROR',
        GENERICCOMMANDERROR = <any> 'GENERIC_COMMAND_ERROR',
        GENERICBACKENDERROR = <any> 'GENERIC_BACKEND_ERROR',
        INVALIDPAYLOADFORMATERROR = <any> 'INVALID_PAYLOAD_FORMAT_ERROR',
        INVALIDPAYLOADSCHEMAERROR = <any> 'INVALID_PAYLOAD_SCHEMA_ERROR',
        REPORTNOTIFICATIONERROR = <any> 'REPORT_NOTIFICATION_ERROR'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LevelEnum {
        Info = <any> 'info',
        Warning = <any> 'warning',
        Error = <any> 'error'
    }
}
/**
 * 
 * @export
 * @interface LogRestApiGet
 */
export interface LogRestApiGet {
    /**
     * 
     * @type {string}
     * @memberof LogRestApiGet
     */
    action?: string;
    /**
     * 
     * @type {number}
     * @memberof LogRestApiGet
     */
    dashboardId?: number;
    /**
     * 
     * @type {Date}
     * @memberof LogRestApiGet
     */
    dttm?: Date;
    /**
     * 
     * @type {number}
     * @memberof LogRestApiGet
     */
    durationMs?: number;
    /**
     * 
     * @type {string}
     * @memberof LogRestApiGet
     */
    json?: string;
    /**
     * 
     * @type {string}
     * @memberof LogRestApiGet
     */
    referrer?: string;
    /**
     * 
     * @type {number}
     * @memberof LogRestApiGet
     */
    sliceId?: number;
    /**
     * 
     * @type {LogRestApiGetUser}
     * @memberof LogRestApiGet
     */
    user?: LogRestApiGetUser;
    /**
     * 
     * @type {number}
     * @memberof LogRestApiGet
     */
    userId?: number;
}
/**
 * 
 * @export
 * @interface LogRestApiGetList
 */
export interface LogRestApiGetList {
    /**
     * 
     * @type {string}
     * @memberof LogRestApiGetList
     */
    action?: string;
    /**
     * 
     * @type {number}
     * @memberof LogRestApiGetList
     */
    dashboardId?: number;
    /**
     * 
     * @type {Date}
     * @memberof LogRestApiGetList
     */
    dttm?: Date;
    /**
     * 
     * @type {number}
     * @memberof LogRestApiGetList
     */
    durationMs?: number;
    /**
     * 
     * @type {string}
     * @memberof LogRestApiGetList
     */
    json?: string;
    /**
     * 
     * @type {string}
     * @memberof LogRestApiGetList
     */
    referrer?: string;
    /**
     * 
     * @type {number}
     * @memberof LogRestApiGetList
     */
    sliceId?: number;
    /**
     * 
     * @type {LogRestApiGetListUser}
     * @memberof LogRestApiGetList
     */
    user?: LogRestApiGetListUser;
    /**
     * 
     * @type {number}
     * @memberof LogRestApiGetList
     */
    userId?: number;
}
/**
 * 
 * @export
 * @interface LogRestApiGetListUser
 */
export interface LogRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof LogRestApiGetListUser
     */
    username: string;
}
/**
 * 
 * @export
 * @interface LogRestApiGetUser
 */
export interface LogRestApiGetUser {
    /**
     * 
     * @type {string}
     * @memberof LogRestApiGetUser
     */
    username: string;
}
/**
 * 
 * @export
 * @interface LogRestApiPost
 */
export interface LogRestApiPost {
    /**
     * 
     * @type {number}
     * @memberof LogRestApiPost
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface LogRestApiPut
 */
export interface LogRestApiPut {
    /**
     * 
     * @type {string}
     * @memberof LogRestApiPut
     */
    action?: string;
    /**
     * 
     * @type {Date}
     * @memberof LogRestApiPut
     */
    dttm?: Date;
    /**
     * 
     * @type {string}
     * @memberof LogRestApiPut
     */
    json?: string;
    /**
     * 
     * @type {any}
     * @memberof LogRestApiPut
     */
    user?: any;
}
/**
 * 
 * @export
 * @interface ObjectTypeObjectIdBody
 */
export interface ObjectTypeObjectIdBody {
    /**
     * list of tag names to add to object
     * @type {Array<string>}
     * @memberof ObjectTypeObjectIdBody
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface QueriesGetUpdatedSinceSchema
 */
export interface QueriesGetUpdatedSinceSchema {
    /**
     * 
     * @type {number}
     * @memberof QueriesGetUpdatedSinceSchema
     */
    lastUpdatedMs: number;
}
/**
 * 
 * @export
 * @interface QueryExecutionResponseSchema
 */
export interface QueryExecutionResponseSchema {
    /**
     * 
     * @type {Array<any>}
     * @memberof QueryExecutionResponseSchema
     */
    columns?: Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof QueryExecutionResponseSchema
     */
    data?: Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof QueryExecutionResponseSchema
     */
    expandedColumns?: Array<any>;
    /**
     * 
     * @type {QueryResult}
     * @memberof QueryExecutionResponseSchema
     */
    query?: QueryResult;
    /**
     * 
     * @type {number}
     * @memberof QueryExecutionResponseSchema
     */
    queryId?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof QueryExecutionResponseSchema
     */
    selectedColumns?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof QueryExecutionResponseSchema
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface QueryRestApiGet
 */
export interface QueryRestApiGet {
    /**
     * 
     * @type {Date}
     * @memberof QueryRestApiGet
     */
    changedOn?: Date;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    clientId: string;
    /**
     * 
     * @type {QueryRestApiGetDatabase}
     * @memberof QueryRestApiGet
     */
    database: QueryRestApiGetDatabase;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGet
     */
    endResultBackendTime?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGet
     */
    endTime?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    errorMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    executedSql?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGet
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGet
     */
    progress?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    resultsKey?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGet
     */
    rows?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    schema?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QueryRestApiGet
     */
    selectAsCta?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueryRestApiGet
     */
    selectAsCtaUsed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    selectSql?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    sql?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    sqlEditorId?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGet
     */
    startRunningTime?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGet
     */
    startTime?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    tabName?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    tmpSchemaName?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGet
     */
    tmpTableName?: string;
    /**
     * 
     * @type {any}
     * @memberof QueryRestApiGet
     */
    trackingUrl?: any;
}
/**
 * 
 * @export
 * @interface QueryRestApiGetDatabase
 */
export interface QueryRestApiGetDatabase {
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGetDatabase
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface QueryRestApiGetList
 */
export interface QueryRestApiGetList {
    /**
     * 
     * @type {Date}
     * @memberof QueryRestApiGetList
     */
    changedOn?: Date;
    /**
     * 
     * @type {Database1}
     * @memberof QueryRestApiGetList
     */
    database?: Database1;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGetList
     */
    endTime?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGetList
     */
    executedSql?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGetList
     */
    rows?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGetList
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGetList
     */
    sql?: string;
    /**
     * 
     * @type {any}
     * @memberof QueryRestApiGetList
     */
    sqlTables?: any;
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiGetList
     */
    startTime?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGetList
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGetList
     */
    tabName?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGetList
     */
    tmpTableName?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryRestApiGetList
     */
    trackingUrl?: string;
    /**
     * 
     * @type {User}
     * @memberof QueryRestApiGetList
     */
    user?: User;
}
/**
 * 
 * @export
 * @interface QueryRestApiPost
 */
export interface QueryRestApiPost {
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiPost
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface QueryRestApiPut
 */
export interface QueryRestApiPut {
    /**
     * 
     * @type {number}
     * @memberof QueryRestApiPut
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface QueryResult
 */
export interface QueryResult {
    /**
     * 
     * @type {Date}
     * @memberof QueryResult
     */
    changedOn?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof QueryResult
     */
    ctas?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    db?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryResult
     */
    dbId?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryResult
     */
    endDttm?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    errorMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    executedSql?: string;
    /**
     * 
     * @type {any}
     * @memberof QueryResult
     */
    extra?: any;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryResult
     */
    limit?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    limitingFactor?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryResult
     */
    progress?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryResult
     */
    queryId?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    resultsKey?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryResult
     */
    rows?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    schema?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryResult
     */
    serverId?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    sql?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    sqlEditorId?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryResult
     */
    startDttm?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    tab?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    tempSchema?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    tempTable?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    trackingUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryResult
     */
    user?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryResult
     */
    userId?: number;
}
/**
 * 
 * @export
 * @interface RLSRestApiGet
 */
export interface RLSRestApiGet {
    /**
     * This is the condition that will be added to the WHERE clause. For example, to only return rows for a particular client, you might define a regular filter with the clause `client_id = 9`. To display no rows unless a user belongs to a RLS filter role, a base filter can be created with the clause `1 = 0` (always false).
     * @type {string}
     * @memberof RLSRestApiGet
     */
    clause?: string;
    /**
     * Detailed description
     * @type {string}
     * @memberof RLSRestApiGet
     */
    description?: string;
    /**
     * Regular filters add where clauses to queries if a user belongs to a role referenced in the filter, base filters apply filters to all queries except the roles defined in the filter, and can be used to define what users can see if no RLS filters within a filter group apply to them.
     * @type {string}
     * @memberof RLSRestApiGet
     */
    filterType?: RLSRestApiGet.FilterTypeEnum;
    /**
     * Filters with the same group key will be ORed together within the group, while different filter groups will be ANDed together. Undefined group keys are treated as unique groups, i.e. are not grouped together. For example, if a table has three filters, of which two are for departments Finance and Marketing (group key = 'department'), and one refers to the region Europe (group key = 'region'), the filter clause would apply the filter (department = 'Finance' OR department = 'Marketing') AND (region = 'Europe').
     * @type {string}
     * @memberof RLSRestApiGet
     */
    groupKey?: string;
    /**
     * Unique if of rls filter
     * @type {number}
     * @memberof RLSRestApiGet
     */
    id?: number;
    /**
     * Name of rls filter
     * @type {string}
     * @memberof RLSRestApiGet
     */
    name?: string;
    /**
     * 
     * @type {Array<Roles1>}
     * @memberof RLSRestApiGet
     */
    roles?: Array<Roles1>;
    /**
     * 
     * @type {Array<Tables>}
     * @memberof RLSRestApiGet
     */
    tables?: Array<Tables>;
}

/**
 * @export
 * @namespace RLSRestApiGet
 */
export namespace RLSRestApiGet {
    /**
     * @export
     * @enum {string}
     */
    export enum FilterTypeEnum {
        Regular = <any> 'Regular',
        Base = <any> 'Base'
    }
}
/**
 * 
 * @export
 * @interface RLSRestApiGetList
 */
export interface RLSRestApiGetList {
    /**
     * 
     * @type {any}
     * @memberof RLSRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * This is the condition that will be added to the WHERE clause. For example, to only return rows for a particular client, you might define a regular filter with the clause `client_id = 9`. To display no rows unless a user belongs to a RLS filter role, a base filter can be created with the clause `1 = 0` (always false).
     * @type {string}
     * @memberof RLSRestApiGetList
     */
    clause?: string;
    /**
     * Detailed description
     * @type {string}
     * @memberof RLSRestApiGetList
     */
    description?: string;
    /**
     * Regular filters add where clauses to queries if a user belongs to a role referenced in the filter, base filters apply filters to all queries except the roles defined in the filter, and can be used to define what users can see if no RLS filters within a filter group apply to them.
     * @type {string}
     * @memberof RLSRestApiGetList
     */
    filterType?: RLSRestApiGetList.FilterTypeEnum;
    /**
     * Filters with the same group key will be ORed together within the group, while different filter groups will be ANDed together. Undefined group keys are treated as unique groups, i.e. are not grouped together. For example, if a table has three filters, of which two are for departments Finance and Marketing (group key = 'department'), and one refers to the region Europe (group key = 'region'), the filter clause would apply the filter (department = 'Finance' OR department = 'Marketing') AND (region = 'Europe').
     * @type {string}
     * @memberof RLSRestApiGetList
     */
    groupKey?: string;
    /**
     * Unique if of rls filter
     * @type {number}
     * @memberof RLSRestApiGetList
     */
    id?: number;
    /**
     * Name of rls filter
     * @type {string}
     * @memberof RLSRestApiGetList
     */
    name?: string;
    /**
     * 
     * @type {Array<Roles1>}
     * @memberof RLSRestApiGetList
     */
    roles?: Array<Roles1>;
    /**
     * 
     * @type {Array<Tables>}
     * @memberof RLSRestApiGetList
     */
    tables?: Array<Tables>;
}

/**
 * @export
 * @namespace RLSRestApiGetList
 */
export namespace RLSRestApiGetList {
    /**
     * @export
     * @enum {string}
     */
    export enum FilterTypeEnum {
        Regular = <any> 'Regular',
        Base = <any> 'Base'
    }
}
/**
 * 
 * @export
 * @interface RLSRestApiPost
 */
export interface RLSRestApiPost {
    /**
     * This is the condition that will be added to the WHERE clause. For example, to only return rows for a particular client, you might define a regular filter with the clause `client_id = 9`. To display no rows unless a user belongs to a RLS filter role, a base filter can be created with the clause `1 = 0` (always false).
     * @type {string}
     * @memberof RLSRestApiPost
     */
    clause: string;
    /**
     * Detailed description
     * @type {string}
     * @memberof RLSRestApiPost
     */
    description?: string;
    /**
     * Regular filters add where clauses to queries if a user belongs to a role referenced in the filter, base filters apply filters to all queries except the roles defined in the filter, and can be used to define what users can see if no RLS filters within a filter group apply to them.
     * @type {string}
     * @memberof RLSRestApiPost
     */
    filterType: RLSRestApiPost.FilterTypeEnum;
    /**
     * Filters with the same group key will be ORed together within the group, while different filter groups will be ANDed together. Undefined group keys are treated as unique groups, i.e. are not grouped together. For example, if a table has three filters, of which two are for departments Finance and Marketing (group key = 'department'), and one refers to the region Europe (group key = 'region'), the filter clause would apply the filter (department = 'Finance' OR department = 'Marketing') AND (region = 'Europe').
     * @type {string}
     * @memberof RLSRestApiPost
     */
    groupKey?: string;
    /**
     * Name of rls filter
     * @type {string}
     * @memberof RLSRestApiPost
     */
    name: string;
    /**
     * For regular filters, these are the roles this filter will be applied to. For base filters, these are the roles that the filter DOES NOT apply to, e.g. Admin if admin should see all data.
     * @type {Array<number>}
     * @memberof RLSRestApiPost
     */
    roles: Array<number>;
    /**
     * These are the tables this filter will be applied to.
     * @type {Array<number>}
     * @memberof RLSRestApiPost
     */
    tables: Array<number>;
}

/**
 * @export
 * @namespace RLSRestApiPost
 */
export namespace RLSRestApiPost {
    /**
     * @export
     * @enum {string}
     */
    export enum FilterTypeEnum {
        Regular = <any> 'Regular',
        Base = <any> 'Base'
    }
}
/**
 * 
 * @export
 * @interface RLSRestApiPut
 */
export interface RLSRestApiPut {
    /**
     * This is the condition that will be added to the WHERE clause. For example, to only return rows for a particular client, you might define a regular filter with the clause `client_id = 9`. To display no rows unless a user belongs to a RLS filter role, a base filter can be created with the clause `1 = 0` (always false).
     * @type {string}
     * @memberof RLSRestApiPut
     */
    clause?: string;
    /**
     * Detailed description
     * @type {string}
     * @memberof RLSRestApiPut
     */
    description?: string;
    /**
     * Regular filters add where clauses to queries if a user belongs to a role referenced in the filter, base filters apply filters to all queries except the roles defined in the filter, and can be used to define what users can see if no RLS filters within a filter group apply to them.
     * @type {string}
     * @memberof RLSRestApiPut
     */
    filterType?: RLSRestApiPut.FilterTypeEnum;
    /**
     * Filters with the same group key will be ORed together within the group, while different filter groups will be ANDed together. Undefined group keys are treated as unique groups, i.e. are not grouped together. For example, if a table has three filters, of which two are for departments Finance and Marketing (group key = 'department'), and one refers to the region Europe (group key = 'region'), the filter clause would apply the filter (department = 'Finance' OR department = 'Marketing') AND (region = 'Europe').
     * @type {string}
     * @memberof RLSRestApiPut
     */
    groupKey?: string;
    /**
     * Name of rls filter
     * @type {string}
     * @memberof RLSRestApiPut
     */
    name?: string;
    /**
     * For regular filters, these are the roles this filter will be applied to. For base filters, these are the roles that the filter DOES NOT apply to, e.g. Admin if admin should see all data.
     * @type {Array<number>}
     * @memberof RLSRestApiPut
     */
    roles?: Array<number>;
    /**
     * These are the tables this filter will be applied to.
     * @type {Array<number>}
     * @memberof RLSRestApiPut
     */
    tables?: Array<number>;
}

/**
 * @export
 * @namespace RLSRestApiPut
 */
export namespace RLSRestApiPut {
    /**
     * @export
     * @enum {string}
     */
    export enum FilterTypeEnum {
        Regular = <any> 'Regular',
        Base = <any> 'Base'
    }
}
/**
 * 
 * @export
 * @interface RecentActivity
 */
export interface RecentActivity {
    /**
     * Action taken describing type of activity
     * @type {string}
     * @memberof RecentActivity
     */
    action?: string;
    /**
     * Title of item
     * @type {string}
     * @memberof RecentActivity
     */
    itemTitle?: string;
    /**
     * Type of item, e.g. slice or dashboard
     * @type {string}
     * @memberof RecentActivity
     */
    itemType?: string;
    /**
     * URL to item
     * @type {string}
     * @memberof RecentActivity
     */
    itemUrl?: string;
    /**
     * Time of activity, in epoch milliseconds
     * @type {number}
     * @memberof RecentActivity
     */
    time?: number;
    /**
     * Human-readable description of how long ago activity took place.
     * @type {string}
     * @memberof RecentActivity
     */
    timeDeltaHumanized?: string;
}
/**
 * 
 * @export
 * @interface RecentActivityResponseSchema
 */
export interface RecentActivityResponseSchema {
    /**
     * A list of recent activity objects
     * @type {Array<RecentActivity>}
     * @memberof RecentActivityResponseSchema
     */
    result?: Array<RecentActivity>;
}
/**
 * 
 * @export
 * @interface RecentActivitySchema
 */
export interface RecentActivitySchema {
    /**
     * Action taken describing type of activity
     * @type {string}
     * @memberof RecentActivitySchema
     */
    action?: string;
    /**
     * Title of item
     * @type {string}
     * @memberof RecentActivitySchema
     */
    itemTitle?: string;
    /**
     * Type of item, e.g. slice or dashboard
     * @type {string}
     * @memberof RecentActivitySchema
     */
    itemType?: string;
    /**
     * URL to item
     * @type {string}
     * @memberof RecentActivitySchema
     */
    itemUrl?: string;
    /**
     * Time of activity, in epoch milliseconds
     * @type {number}
     * @memberof RecentActivitySchema
     */
    time?: number;
    /**
     * Human-readable description of how long ago activity took place.
     * @type {string}
     * @memberof RecentActivitySchema
     */
    timeDeltaHumanized?: string;
}
/**
 * 
 * @export
 * @interface RelatedResponseSchema
 */
export interface RelatedResponseSchema {
    /**
     * The total number of related values
     * @type {number}
     * @memberof RelatedResponseSchema
     */
    count?: number;
    /**
     * 
     * @type {Array<RelatedResultResponse>}
     * @memberof RelatedResponseSchema
     */
    result?: Array<RelatedResultResponse>;
}
/**
 * 
 * @export
 * @interface RelatedResultResponse
 */
export interface RelatedResultResponse {
    /**
     * The extra metadata for related item
     * @type {any}
     * @memberof RelatedResultResponse
     */
    extra?: any;
    /**
     * The related item string representation
     * @type {string}
     * @memberof RelatedResultResponse
     */
    text?: string;
    /**
     * The related item identifier
     * @type {number}
     * @memberof RelatedResultResponse
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface ReportExecutionLogRestApiGet
 */
export interface ReportExecutionLogRestApiGet {
    /**
     * 
     * @type {Date}
     * @memberof ReportExecutionLogRestApiGet
     */
    endDttm?: Date;
    /**
     * 
     * @type {string}
     * @memberof ReportExecutionLogRestApiGet
     */
    errorMessage?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportExecutionLogRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof ReportExecutionLogRestApiGet
     */
    scheduledDttm: Date;
    /**
     * 
     * @type {Date}
     * @memberof ReportExecutionLogRestApiGet
     */
    startDttm?: Date;
    /**
     * 
     * @type {string}
     * @memberof ReportExecutionLogRestApiGet
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof ReportExecutionLogRestApiGet
     */
    uuid?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportExecutionLogRestApiGet
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportExecutionLogRestApiGet
     */
    valueRowJson?: string;
}
/**
 * 
 * @export
 * @interface ReportExecutionLogRestApiGetList
 */
export interface ReportExecutionLogRestApiGetList {
    /**
     * 
     * @type {Date}
     * @memberof ReportExecutionLogRestApiGetList
     */
    endDttm?: Date;
    /**
     * 
     * @type {string}
     * @memberof ReportExecutionLogRestApiGetList
     */
    errorMessage?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportExecutionLogRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof ReportExecutionLogRestApiGetList
     */
    scheduledDttm: Date;
    /**
     * 
     * @type {Date}
     * @memberof ReportExecutionLogRestApiGetList
     */
    startDttm?: Date;
    /**
     * 
     * @type {string}
     * @memberof ReportExecutionLogRestApiGetList
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof ReportExecutionLogRestApiGetList
     */
    uuid?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportExecutionLogRestApiGetList
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportExecutionLogRestApiGetList
     */
    valueRowJson?: string;
}
/**
 * 
 * @export
 * @interface ReportExecutionLogRestApiPost
 */
export interface ReportExecutionLogRestApiPost {
    /**
     * 
     * @type {number}
     * @memberof ReportExecutionLogRestApiPost
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ReportExecutionLogRestApiPut
 */
export interface ReportExecutionLogRestApiPut {
    /**
     * 
     * @type {number}
     * @memberof ReportExecutionLogRestApiPut
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ReportRecipient
 */
export interface ReportRecipient {
    /**
     * 
     * @type {ReportRecipientConfigJSON}
     * @memberof ReportRecipient
     */
    recipientConfigJson?: ReportRecipientConfigJSON;
    /**
     * The recipient type, check spec for valid options
     * @type {string}
     * @memberof ReportRecipient
     */
    type: ReportRecipient.TypeEnum;
}

/**
 * @export
 * @namespace ReportRecipient
 */
export namespace ReportRecipient {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Email = <any> 'Email',
        Slack = <any> 'Slack'
    }
}
/**
 * 
 * @export
 * @interface ReportRecipientConfigJSON
 */
export interface ReportRecipientConfigJSON {
    /**
     * 
     * @type {string}
     * @memberof ReportRecipientConfigJSON
     */
    target?: string;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiGet
 */
export interface ReportScheduleRestApiGet {
    /**
     * 
     * @type {boolean}
     * @memberof ReportScheduleRestApiGet
     */
    active?: boolean;
    /**
     * 
     * @type {ReportScheduleRestApiGetSlice}
     * @memberof ReportScheduleRestApiGet
     */
    chart?: ReportScheduleRestApiGetSlice;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    contextMarkdown?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    creationMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    crontab: string;
    /**
     * 
     * @type {ReportScheduleRestApiGetDashboard}
     * @memberof ReportScheduleRestApiGet
     */
    dashboard?: ReportScheduleRestApiGetDashboard;
    /**
     * 
     * @type {ReportScheduleRestApiGetDatabase}
     * @memberof ReportScheduleRestApiGet
     */
    database?: ReportScheduleRestApiGetDatabase;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof ReportScheduleRestApiGet
     */
    extra?: any;
    /**
     * 
     * @type {boolean}
     * @memberof ReportScheduleRestApiGet
     */
    forceScreenshot?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGet
     */
    gracePeriod?: number;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof ReportScheduleRestApiGet
     */
    lastEvalDttm?: Date;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    lastState?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGet
     */
    lastValue?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    lastValueRowJson?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGet
     */
    logRetention?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    name: string;
    /**
     * 
     * @type {ReportScheduleRestApiGetUser}
     * @memberof ReportScheduleRestApiGet
     */
    owners?: ReportScheduleRestApiGetUser;
    /**
     * 
     * @type {ReportScheduleRestApiGetReportRecipients}
     * @memberof ReportScheduleRestApiGet
     */
    recipients: ReportScheduleRestApiGetReportRecipients;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    reportFormat?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    sql?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    validatorConfigJson?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGet
     */
    validatorType?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGet
     */
    workingTimeout?: number;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiGetDashboard
 */
export interface ReportScheduleRestApiGetDashboard {
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetDashboard
     */
    dashboardTitle?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGetDashboard
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiGetDatabase
 */
export interface ReportScheduleRestApiGetDatabase {
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetDatabase
     */
    databaseName: string;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGetDatabase
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiGetList
 */
export interface ReportScheduleRestApiGetList {
    /**
     * 
     * @type {boolean}
     * @memberof ReportScheduleRestApiGetList
     */
    active?: boolean;
    /**
     * 
     * @type {ReportScheduleRestApiGetListUser}
     * @memberof ReportScheduleRestApiGetList
     */
    changedBy?: ReportScheduleRestApiGetListUser;
    /**
     * 
     * @type {Date}
     * @memberof ReportScheduleRestApiGetList
     */
    changedOn?: Date;
    /**
     * 
     * @type {any}
     * @memberof ReportScheduleRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGetList
     */
    chartId?: number;
    /**
     * 
     * @type {ReportScheduleRestApiGetListUser2}
     * @memberof ReportScheduleRestApiGetList
     */
    createdBy?: ReportScheduleRestApiGetListUser2;
    /**
     * 
     * @type {Date}
     * @memberof ReportScheduleRestApiGetList
     */
    createdOn?: Date;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetList
     */
    creationMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetList
     */
    crontab: string;
    /**
     * 
     * @type {any}
     * @memberof ReportScheduleRestApiGetList
     */
    crontabHumanized?: any;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGetList
     */
    dashboardId?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetList
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof ReportScheduleRestApiGetList
     */
    extra?: any;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof ReportScheduleRestApiGetList
     */
    lastEvalDttm?: Date;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetList
     */
    lastState?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetList
     */
    name: string;
    /**
     * 
     * @type {ReportScheduleRestApiGetListUser1}
     * @memberof ReportScheduleRestApiGetList
     */
    owners?: ReportScheduleRestApiGetListUser1;
    /**
     * 
     * @type {ReportScheduleRestApiGetListReportRecipients}
     * @memberof ReportScheduleRestApiGetList
     */
    recipients: ReportScheduleRestApiGetListReportRecipients;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetList
     */
    timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetList
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiGetListReportRecipients
 */
export interface ReportScheduleRestApiGetListReportRecipients {
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGetListReportRecipients
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetListReportRecipients
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiGetListUser
 */
export interface ReportScheduleRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetListUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetListUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiGetListUser1
 */
export interface ReportScheduleRestApiGetListUser1 {
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetListUser1
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGetListUser1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetListUser1
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiGetListUser2
 */
export interface ReportScheduleRestApiGetListUser2 {
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetListUser2
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetListUser2
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiGetReportRecipients
 */
export interface ReportScheduleRestApiGetReportRecipients {
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGetReportRecipients
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetReportRecipients
     */
    recipientConfigJson?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetReportRecipients
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiGetSlice
 */
export interface ReportScheduleRestApiGetSlice {
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGetSlice
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetSlice
     */
    sliceName?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetSlice
     */
    vizType?: string;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiGetUser
 */
export interface ReportScheduleRestApiGetUser {
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetUser
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiGetUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiGetUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiPost
 */
export interface ReportScheduleRestApiPost {
    /**
     * 
     * @type {boolean}
     * @memberof ReportScheduleRestApiPost
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiPost
     */
    chart?: number;
    /**
     * Markdown description
     * @type {string}
     * @memberof ReportScheduleRestApiPost
     */
    contextMarkdown?: string;
    /**
     * Creation method is used to inform the frontend whether the report/alert was created in the dashboard, chart, or alerts and reports UI.
     * @type {any}
     * @memberof ReportScheduleRestApiPost
     */
    creationMethod?: any;
    /**
     * A CRON expression.[Crontab Guru](https://crontab.guru/) is a helpful resource that can help you craft a CRON expression.
     * @type {string}
     * @memberof ReportScheduleRestApiPost
     */
    crontab: string;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiPost
     */
    dashboard?: number;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiPost
     */
    database?: number;
    /**
     * Use a nice description to give context to this Alert/Report
     * @type {string}
     * @memberof ReportScheduleRestApiPost
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof ReportScheduleRestApiPost
     */
    extra?: any;
    /**
     * 
     * @type {boolean}
     * @memberof ReportScheduleRestApiPost
     */
    forceScreenshot?: boolean;
    /**
     * Once an alert is triggered, how long, in seconds, before Superset nags you again. (in seconds)
     * @type {number}
     * @memberof ReportScheduleRestApiPost
     */
    gracePeriod?: number;
    /**
     * How long to keep the logs around for this report (in days)
     * @type {number}
     * @memberof ReportScheduleRestApiPost
     */
    logRetention?: number;
    /**
     * The report schedule name.
     * @type {string}
     * @memberof ReportScheduleRestApiPost
     */
    name: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ReportScheduleRestApiPost
     */
    owners?: Array<number>;
    /**
     * 
     * @type {Array<ReportRecipient>}
     * @memberof ReportScheduleRestApiPost
     */
    recipients?: Array<ReportRecipient>;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiPost
     */
    reportFormat?: ReportScheduleRestApiPost.ReportFormatEnum;
    /**
     * 
     * @type {Array<number>}
     * @memberof ReportScheduleRestApiPost
     */
    selectedTabs?: Array<number>;
    /**
     * A SQL statement that defines whether the alert should get triggered or not. The query is expected to return either NULL or a number value.
     * @type {string}
     * @memberof ReportScheduleRestApiPost
     */
    sql?: string;
    /**
     * A timezone string that represents the location of the timezone.
     * @type {string}
     * @memberof ReportScheduleRestApiPost
     */
    timezone?: ReportScheduleRestApiPost.TimezoneEnum;
    /**
     * The report schedule type
     * @type {string}
     * @memberof ReportScheduleRestApiPost
     */
    type: ReportScheduleRestApiPost.TypeEnum;
    /**
     * 
     * @type {ValidatorConfigJSON}
     * @memberof ReportScheduleRestApiPost
     */
    validatorConfigJson?: ValidatorConfigJSON;
    /**
     * Determines when to trigger alert based off value from alert query. Alerts will be triggered with these validator types: - Not Null - When the return value is Not NULL, Empty, or 0 - Operator - When `sql_return_value comparison_operator threshold` is True e.g. `50 <= 75`<br>Supports the comparison operators <, <=, >, >=, ==, and !=
     * @type {string}
     * @memberof ReportScheduleRestApiPost
     */
    validatorType?: ReportScheduleRestApiPost.ValidatorTypeEnum;
    /**
     * If an alert is staled at a working state, how long until it's state is reseted to error
     * @type {number}
     * @memberof ReportScheduleRestApiPost
     */
    workingTimeout?: number;
}

/**
 * @export
 * @namespace ReportScheduleRestApiPost
 */
export namespace ReportScheduleRestApiPost {
    /**
     * @export
     * @enum {string}
     */
    export enum ReportFormatEnum {
        PNG = <any> 'PNG',
        CSV = <any> 'CSV',
        TEXT = <any> 'TEXT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TimezoneEnum {
        AfricaAbidjan = <any> 'Africa/Abidjan',
        AfricaAccra = <any> 'Africa/Accra',
        AfricaAddisAbaba = <any> 'Africa/Addis_Ababa',
        AfricaAlgiers = <any> 'Africa/Algiers',
        AfricaAsmara = <any> 'Africa/Asmara',
        AfricaAsmera = <any> 'Africa/Asmera',
        AfricaBamako = <any> 'Africa/Bamako',
        AfricaBangui = <any> 'Africa/Bangui',
        AfricaBanjul = <any> 'Africa/Banjul',
        AfricaBissau = <any> 'Africa/Bissau',
        AfricaBlantyre = <any> 'Africa/Blantyre',
        AfricaBrazzaville = <any> 'Africa/Brazzaville',
        AfricaBujumbura = <any> 'Africa/Bujumbura',
        AfricaCairo = <any> 'Africa/Cairo',
        AfricaCasablanca = <any> 'Africa/Casablanca',
        AfricaCeuta = <any> 'Africa/Ceuta',
        AfricaConakry = <any> 'Africa/Conakry',
        AfricaDakar = <any> 'Africa/Dakar',
        AfricaDarEsSalaam = <any> 'Africa/Dar_es_Salaam',
        AfricaDjibouti = <any> 'Africa/Djibouti',
        AfricaDouala = <any> 'Africa/Douala',
        AfricaElAaiun = <any> 'Africa/El_Aaiun',
        AfricaFreetown = <any> 'Africa/Freetown',
        AfricaGaborone = <any> 'Africa/Gaborone',
        AfricaHarare = <any> 'Africa/Harare',
        AfricaJohannesburg = <any> 'Africa/Johannesburg',
        AfricaJuba = <any> 'Africa/Juba',
        AfricaKampala = <any> 'Africa/Kampala',
        AfricaKhartoum = <any> 'Africa/Khartoum',
        AfricaKigali = <any> 'Africa/Kigali',
        AfricaKinshasa = <any> 'Africa/Kinshasa',
        AfricaLagos = <any> 'Africa/Lagos',
        AfricaLibreville = <any> 'Africa/Libreville',
        AfricaLome = <any> 'Africa/Lome',
        AfricaLuanda = <any> 'Africa/Luanda',
        AfricaLubumbashi = <any> 'Africa/Lubumbashi',
        AfricaLusaka = <any> 'Africa/Lusaka',
        AfricaMalabo = <any> 'Africa/Malabo',
        AfricaMaputo = <any> 'Africa/Maputo',
        AfricaMaseru = <any> 'Africa/Maseru',
        AfricaMbabane = <any> 'Africa/Mbabane',
        AfricaMogadishu = <any> 'Africa/Mogadishu',
        AfricaMonrovia = <any> 'Africa/Monrovia',
        AfricaNairobi = <any> 'Africa/Nairobi',
        AfricaNdjamena = <any> 'Africa/Ndjamena',
        AfricaNiamey = <any> 'Africa/Niamey',
        AfricaNouakchott = <any> 'Africa/Nouakchott',
        AfricaOuagadougou = <any> 'Africa/Ouagadougou',
        AfricaPortoNovo = <any> 'Africa/Porto-Novo',
        AfricaSaoTome = <any> 'Africa/Sao_Tome',
        AfricaTimbuktu = <any> 'Africa/Timbuktu',
        AfricaTripoli = <any> 'Africa/Tripoli',
        AfricaTunis = <any> 'Africa/Tunis',
        AfricaWindhoek = <any> 'Africa/Windhoek',
        AmericaAdak = <any> 'America/Adak',
        AmericaAnchorage = <any> 'America/Anchorage',
        AmericaAnguilla = <any> 'America/Anguilla',
        AmericaAntigua = <any> 'America/Antigua',
        AmericaAraguaina = <any> 'America/Araguaina',
        AmericaArgentinaBuenosAires = <any> 'America/Argentina/Buenos_Aires',
        AmericaArgentinaCatamarca = <any> 'America/Argentina/Catamarca',
        AmericaArgentinaComodRivadavia = <any> 'America/Argentina/ComodRivadavia',
        AmericaArgentinaCordoba = <any> 'America/Argentina/Cordoba',
        AmericaArgentinaJujuy = <any> 'America/Argentina/Jujuy',
        AmericaArgentinaLaRioja = <any> 'America/Argentina/La_Rioja',
        AmericaArgentinaMendoza = <any> 'America/Argentina/Mendoza',
        AmericaArgentinaRioGallegos = <any> 'America/Argentina/Rio_Gallegos',
        AmericaArgentinaSalta = <any> 'America/Argentina/Salta',
        AmericaArgentinaSanJuan = <any> 'America/Argentina/San_Juan',
        AmericaArgentinaSanLuis = <any> 'America/Argentina/San_Luis',
        AmericaArgentinaTucuman = <any> 'America/Argentina/Tucuman',
        AmericaArgentinaUshuaia = <any> 'America/Argentina/Ushuaia',
        AmericaAruba = <any> 'America/Aruba',
        AmericaAsuncion = <any> 'America/Asuncion',
        AmericaAtikokan = <any> 'America/Atikokan',
        AmericaAtka = <any> 'America/Atka',
        AmericaBahia = <any> 'America/Bahia',
        AmericaBahiaBanderas = <any> 'America/Bahia_Banderas',
        AmericaBarbados = <any> 'America/Barbados',
        AmericaBelem = <any> 'America/Belem',
        AmericaBelize = <any> 'America/Belize',
        AmericaBlancSablon = <any> 'America/Blanc-Sablon',
        AmericaBoaVista = <any> 'America/Boa_Vista',
        AmericaBogota = <any> 'America/Bogota',
        AmericaBoise = <any> 'America/Boise',
        AmericaBuenosAires = <any> 'America/Buenos_Aires',
        AmericaCambridgeBay = <any> 'America/Cambridge_Bay',
        AmericaCampoGrande = <any> 'America/Campo_Grande',
        AmericaCancun = <any> 'America/Cancun',
        AmericaCaracas = <any> 'America/Caracas',
        AmericaCatamarca = <any> 'America/Catamarca',
        AmericaCayenne = <any> 'America/Cayenne',
        AmericaCayman = <any> 'America/Cayman',
        AmericaChicago = <any> 'America/Chicago',
        AmericaChihuahua = <any> 'America/Chihuahua',
        AmericaCoralHarbour = <any> 'America/Coral_Harbour',
        AmericaCordoba = <any> 'America/Cordoba',
        AmericaCostaRica = <any> 'America/Costa_Rica',
        AmericaCreston = <any> 'America/Creston',
        AmericaCuiaba = <any> 'America/Cuiaba',
        AmericaCuracao = <any> 'America/Curacao',
        AmericaDanmarkshavn = <any> 'America/Danmarkshavn',
        AmericaDawson = <any> 'America/Dawson',
        AmericaDawsonCreek = <any> 'America/Dawson_Creek',
        AmericaDenver = <any> 'America/Denver',
        AmericaDetroit = <any> 'America/Detroit',
        AmericaDominica = <any> 'America/Dominica',
        AmericaEdmonton = <any> 'America/Edmonton',
        AmericaEirunepe = <any> 'America/Eirunepe',
        AmericaElSalvador = <any> 'America/El_Salvador',
        AmericaEnsenada = <any> 'America/Ensenada',
        AmericaFortNelson = <any> 'America/Fort_Nelson',
        AmericaFortWayne = <any> 'America/Fort_Wayne',
        AmericaFortaleza = <any> 'America/Fortaleza',
        AmericaGlaceBay = <any> 'America/Glace_Bay',
        AmericaGodthab = <any> 'America/Godthab',
        AmericaGooseBay = <any> 'America/Goose_Bay',
        AmericaGrandTurk = <any> 'America/Grand_Turk',
        AmericaGrenada = <any> 'America/Grenada',
        AmericaGuadeloupe = <any> 'America/Guadeloupe',
        AmericaGuatemala = <any> 'America/Guatemala',
        AmericaGuayaquil = <any> 'America/Guayaquil',
        AmericaGuyana = <any> 'America/Guyana',
        AmericaHalifax = <any> 'America/Halifax',
        AmericaHavana = <any> 'America/Havana',
        AmericaHermosillo = <any> 'America/Hermosillo',
        AmericaIndianaIndianapolis = <any> 'America/Indiana/Indianapolis',
        AmericaIndianaKnox = <any> 'America/Indiana/Knox',
        AmericaIndianaMarengo = <any> 'America/Indiana/Marengo',
        AmericaIndianaPetersburg = <any> 'America/Indiana/Petersburg',
        AmericaIndianaTellCity = <any> 'America/Indiana/Tell_City',
        AmericaIndianaVevay = <any> 'America/Indiana/Vevay',
        AmericaIndianaVincennes = <any> 'America/Indiana/Vincennes',
        AmericaIndianaWinamac = <any> 'America/Indiana/Winamac',
        AmericaIndianapolis = <any> 'America/Indianapolis',
        AmericaInuvik = <any> 'America/Inuvik',
        AmericaIqaluit = <any> 'America/Iqaluit',
        AmericaJamaica = <any> 'America/Jamaica',
        AmericaJujuy = <any> 'America/Jujuy',
        AmericaJuneau = <any> 'America/Juneau',
        AmericaKentuckyLouisville = <any> 'America/Kentucky/Louisville',
        AmericaKentuckyMonticello = <any> 'America/Kentucky/Monticello',
        AmericaKnoxIN = <any> 'America/Knox_IN',
        AmericaKralendijk = <any> 'America/Kralendijk',
        AmericaLaPaz = <any> 'America/La_Paz',
        AmericaLima = <any> 'America/Lima',
        AmericaLosAngeles = <any> 'America/Los_Angeles',
        AmericaLouisville = <any> 'America/Louisville',
        AmericaLowerPrinces = <any> 'America/Lower_Princes',
        AmericaMaceio = <any> 'America/Maceio',
        AmericaManagua = <any> 'America/Managua',
        AmericaManaus = <any> 'America/Manaus',
        AmericaMarigot = <any> 'America/Marigot',
        AmericaMartinique = <any> 'America/Martinique',
        AmericaMatamoros = <any> 'America/Matamoros',
        AmericaMazatlan = <any> 'America/Mazatlan',
        AmericaMendoza = <any> 'America/Mendoza',
        AmericaMenominee = <any> 'America/Menominee',
        AmericaMerida = <any> 'America/Merida',
        AmericaMetlakatla = <any> 'America/Metlakatla',
        AmericaMexicoCity = <any> 'America/Mexico_City',
        AmericaMiquelon = <any> 'America/Miquelon',
        AmericaMoncton = <any> 'America/Moncton',
        AmericaMonterrey = <any> 'America/Monterrey',
        AmericaMontevideo = <any> 'America/Montevideo',
        AmericaMontreal = <any> 'America/Montreal',
        AmericaMontserrat = <any> 'America/Montserrat',
        AmericaNassau = <any> 'America/Nassau',
        AmericaNewYork = <any> 'America/New_York',
        AmericaNipigon = <any> 'America/Nipigon',
        AmericaNome = <any> 'America/Nome',
        AmericaNoronha = <any> 'America/Noronha',
        AmericaNorthDakotaBeulah = <any> 'America/North_Dakota/Beulah',
        AmericaNorthDakotaCenter = <any> 'America/North_Dakota/Center',
        AmericaNorthDakotaNewSalem = <any> 'America/North_Dakota/New_Salem',
        AmericaNuuk = <any> 'America/Nuuk',
        AmericaOjinaga = <any> 'America/Ojinaga',
        AmericaPanama = <any> 'America/Panama',
        AmericaPangnirtung = <any> 'America/Pangnirtung',
        AmericaParamaribo = <any> 'America/Paramaribo',
        AmericaPhoenix = <any> 'America/Phoenix',
        AmericaPortAuPrince = <any> 'America/Port-au-Prince',
        AmericaPortOfSpain = <any> 'America/Port_of_Spain',
        AmericaPortoAcre = <any> 'America/Porto_Acre',
        AmericaPortoVelho = <any> 'America/Porto_Velho',
        AmericaPuertoRico = <any> 'America/Puerto_Rico',
        AmericaPuntaArenas = <any> 'America/Punta_Arenas',
        AmericaRainyRiver = <any> 'America/Rainy_River',
        AmericaRankinInlet = <any> 'America/Rankin_Inlet',
        AmericaRecife = <any> 'America/Recife',
        AmericaRegina = <any> 'America/Regina',
        AmericaResolute = <any> 'America/Resolute',
        AmericaRioBranco = <any> 'America/Rio_Branco',
        AmericaRosario = <any> 'America/Rosario',
        AmericaSantaIsabel = <any> 'America/Santa_Isabel',
        AmericaSantarem = <any> 'America/Santarem',
        AmericaSantiago = <any> 'America/Santiago',
        AmericaSantoDomingo = <any> 'America/Santo_Domingo',
        AmericaSaoPaulo = <any> 'America/Sao_Paulo',
        AmericaScoresbysund = <any> 'America/Scoresbysund',
        AmericaShiprock = <any> 'America/Shiprock',
        AmericaSitka = <any> 'America/Sitka',
        AmericaStBarthelemy = <any> 'America/St_Barthelemy',
        AmericaStJohns = <any> 'America/St_Johns',
        AmericaStKitts = <any> 'America/St_Kitts',
        AmericaStLucia = <any> 'America/St_Lucia',
        AmericaStThomas = <any> 'America/St_Thomas',
        AmericaStVincent = <any> 'America/St_Vincent',
        AmericaSwiftCurrent = <any> 'America/Swift_Current',
        AmericaTegucigalpa = <any> 'America/Tegucigalpa',
        AmericaThule = <any> 'America/Thule',
        AmericaThunderBay = <any> 'America/Thunder_Bay',
        AmericaTijuana = <any> 'America/Tijuana',
        AmericaToronto = <any> 'America/Toronto',
        AmericaTortola = <any> 'America/Tortola',
        AmericaVancouver = <any> 'America/Vancouver',
        AmericaVirgin = <any> 'America/Virgin',
        AmericaWhitehorse = <any> 'America/Whitehorse',
        AmericaWinnipeg = <any> 'America/Winnipeg',
        AmericaYakutat = <any> 'America/Yakutat',
        AmericaYellowknife = <any> 'America/Yellowknife',
        AntarcticaCasey = <any> 'Antarctica/Casey',
        AntarcticaDavis = <any> 'Antarctica/Davis',
        AntarcticaDumontDUrville = <any> 'Antarctica/DumontDUrville',
        AntarcticaMacquarie = <any> 'Antarctica/Macquarie',
        AntarcticaMawson = <any> 'Antarctica/Mawson',
        AntarcticaMcMurdo = <any> 'Antarctica/McMurdo',
        AntarcticaPalmer = <any> 'Antarctica/Palmer',
        AntarcticaRothera = <any> 'Antarctica/Rothera',
        AntarcticaSouthPole = <any> 'Antarctica/South_Pole',
        AntarcticaSyowa = <any> 'Antarctica/Syowa',
        AntarcticaTroll = <any> 'Antarctica/Troll',
        AntarcticaVostok = <any> 'Antarctica/Vostok',
        ArcticLongyearbyen = <any> 'Arctic/Longyearbyen',
        AsiaAden = <any> 'Asia/Aden',
        AsiaAlmaty = <any> 'Asia/Almaty',
        AsiaAmman = <any> 'Asia/Amman',
        AsiaAnadyr = <any> 'Asia/Anadyr',
        AsiaAqtau = <any> 'Asia/Aqtau',
        AsiaAqtobe = <any> 'Asia/Aqtobe',
        AsiaAshgabat = <any> 'Asia/Ashgabat',
        AsiaAshkhabad = <any> 'Asia/Ashkhabad',
        AsiaAtyrau = <any> 'Asia/Atyrau',
        AsiaBaghdad = <any> 'Asia/Baghdad',
        AsiaBahrain = <any> 'Asia/Bahrain',
        AsiaBaku = <any> 'Asia/Baku',
        AsiaBangkok = <any> 'Asia/Bangkok',
        AsiaBarnaul = <any> 'Asia/Barnaul',
        AsiaBeirut = <any> 'Asia/Beirut',
        AsiaBishkek = <any> 'Asia/Bishkek',
        AsiaBrunei = <any> 'Asia/Brunei',
        AsiaCalcutta = <any> 'Asia/Calcutta',
        AsiaChita = <any> 'Asia/Chita',
        AsiaChoibalsan = <any> 'Asia/Choibalsan',
        AsiaChongqing = <any> 'Asia/Chongqing',
        AsiaChungking = <any> 'Asia/Chungking',
        AsiaColombo = <any> 'Asia/Colombo',
        AsiaDacca = <any> 'Asia/Dacca',
        AsiaDamascus = <any> 'Asia/Damascus',
        AsiaDhaka = <any> 'Asia/Dhaka',
        AsiaDili = <any> 'Asia/Dili',
        AsiaDubai = <any> 'Asia/Dubai',
        AsiaDushanbe = <any> 'Asia/Dushanbe',
        AsiaFamagusta = <any> 'Asia/Famagusta',
        AsiaGaza = <any> 'Asia/Gaza',
        AsiaHarbin = <any> 'Asia/Harbin',
        AsiaHebron = <any> 'Asia/Hebron',
        AsiaHoChiMinh = <any> 'Asia/Ho_Chi_Minh',
        AsiaHongKong = <any> 'Asia/Hong_Kong',
        AsiaHovd = <any> 'Asia/Hovd',
        AsiaIrkutsk = <any> 'Asia/Irkutsk',
        AsiaIstanbul = <any> 'Asia/Istanbul',
        AsiaJakarta = <any> 'Asia/Jakarta',
        AsiaJayapura = <any> 'Asia/Jayapura',
        AsiaJerusalem = <any> 'Asia/Jerusalem',
        AsiaKabul = <any> 'Asia/Kabul',
        AsiaKamchatka = <any> 'Asia/Kamchatka',
        AsiaKarachi = <any> 'Asia/Karachi',
        AsiaKashgar = <any> 'Asia/Kashgar',
        AsiaKathmandu = <any> 'Asia/Kathmandu',
        AsiaKatmandu = <any> 'Asia/Katmandu',
        AsiaKhandyga = <any> 'Asia/Khandyga',
        AsiaKolkata = <any> 'Asia/Kolkata',
        AsiaKrasnoyarsk = <any> 'Asia/Krasnoyarsk',
        AsiaKualaLumpur = <any> 'Asia/Kuala_Lumpur',
        AsiaKuching = <any> 'Asia/Kuching',
        AsiaKuwait = <any> 'Asia/Kuwait',
        AsiaMacao = <any> 'Asia/Macao',
        AsiaMacau = <any> 'Asia/Macau',
        AsiaMagadan = <any> 'Asia/Magadan',
        AsiaMakassar = <any> 'Asia/Makassar',
        AsiaManila = <any> 'Asia/Manila',
        AsiaMuscat = <any> 'Asia/Muscat',
        AsiaNicosia = <any> 'Asia/Nicosia',
        AsiaNovokuznetsk = <any> 'Asia/Novokuznetsk',
        AsiaNovosibirsk = <any> 'Asia/Novosibirsk',
        AsiaOmsk = <any> 'Asia/Omsk',
        AsiaOral = <any> 'Asia/Oral',
        AsiaPhnomPenh = <any> 'Asia/Phnom_Penh',
        AsiaPontianak = <any> 'Asia/Pontianak',
        AsiaPyongyang = <any> 'Asia/Pyongyang',
        AsiaQatar = <any> 'Asia/Qatar',
        AsiaQostanay = <any> 'Asia/Qostanay',
        AsiaQyzylorda = <any> 'Asia/Qyzylorda',
        AsiaRangoon = <any> 'Asia/Rangoon',
        AsiaRiyadh = <any> 'Asia/Riyadh',
        AsiaSaigon = <any> 'Asia/Saigon',
        AsiaSakhalin = <any> 'Asia/Sakhalin',
        AsiaSamarkand = <any> 'Asia/Samarkand',
        AsiaSeoul = <any> 'Asia/Seoul',
        AsiaShanghai = <any> 'Asia/Shanghai',
        AsiaSingapore = <any> 'Asia/Singapore',
        AsiaSrednekolymsk = <any> 'Asia/Srednekolymsk',
        AsiaTaipei = <any> 'Asia/Taipei',
        AsiaTashkent = <any> 'Asia/Tashkent',
        AsiaTbilisi = <any> 'Asia/Tbilisi',
        AsiaTehran = <any> 'Asia/Tehran',
        AsiaTelAviv = <any> 'Asia/Tel_Aviv',
        AsiaThimbu = <any> 'Asia/Thimbu',
        AsiaThimphu = <any> 'Asia/Thimphu',
        AsiaTokyo = <any> 'Asia/Tokyo',
        AsiaTomsk = <any> 'Asia/Tomsk',
        AsiaUjungPandang = <any> 'Asia/Ujung_Pandang',
        AsiaUlaanbaatar = <any> 'Asia/Ulaanbaatar',
        AsiaUlanBator = <any> 'Asia/Ulan_Bator',
        AsiaUrumqi = <any> 'Asia/Urumqi',
        AsiaUstNera = <any> 'Asia/Ust-Nera',
        AsiaVientiane = <any> 'Asia/Vientiane',
        AsiaVladivostok = <any> 'Asia/Vladivostok',
        AsiaYakutsk = <any> 'Asia/Yakutsk',
        AsiaYangon = <any> 'Asia/Yangon',
        AsiaYekaterinburg = <any> 'Asia/Yekaterinburg',
        AsiaYerevan = <any> 'Asia/Yerevan',
        AtlanticAzores = <any> 'Atlantic/Azores',
        AtlanticBermuda = <any> 'Atlantic/Bermuda',
        AtlanticCanary = <any> 'Atlantic/Canary',
        AtlanticCapeVerde = <any> 'Atlantic/Cape_Verde',
        AtlanticFaeroe = <any> 'Atlantic/Faeroe',
        AtlanticFaroe = <any> 'Atlantic/Faroe',
        AtlanticJanMayen = <any> 'Atlantic/Jan_Mayen',
        AtlanticMadeira = <any> 'Atlantic/Madeira',
        AtlanticReykjavik = <any> 'Atlantic/Reykjavik',
        AtlanticSouthGeorgia = <any> 'Atlantic/South_Georgia',
        AtlanticStHelena = <any> 'Atlantic/St_Helena',
        AtlanticStanley = <any> 'Atlantic/Stanley',
        AustraliaACT = <any> 'Australia/ACT',
        AustraliaAdelaide = <any> 'Australia/Adelaide',
        AustraliaBrisbane = <any> 'Australia/Brisbane',
        AustraliaBrokenHill = <any> 'Australia/Broken_Hill',
        AustraliaCanberra = <any> 'Australia/Canberra',
        AustraliaCurrie = <any> 'Australia/Currie',
        AustraliaDarwin = <any> 'Australia/Darwin',
        AustraliaEucla = <any> 'Australia/Eucla',
        AustraliaHobart = <any> 'Australia/Hobart',
        AustraliaLHI = <any> 'Australia/LHI',
        AustraliaLindeman = <any> 'Australia/Lindeman',
        AustraliaLordHowe = <any> 'Australia/Lord_Howe',
        AustraliaMelbourne = <any> 'Australia/Melbourne',
        AustraliaNSW = <any> 'Australia/NSW',
        AustraliaNorth = <any> 'Australia/North',
        AustraliaPerth = <any> 'Australia/Perth',
        AustraliaQueensland = <any> 'Australia/Queensland',
        AustraliaSouth = <any> 'Australia/South',
        AustraliaSydney = <any> 'Australia/Sydney',
        AustraliaTasmania = <any> 'Australia/Tasmania',
        AustraliaVictoria = <any> 'Australia/Victoria',
        AustraliaWest = <any> 'Australia/West',
        AustraliaYancowinna = <any> 'Australia/Yancowinna',
        BrazilAcre = <any> 'Brazil/Acre',
        BrazilDeNoronha = <any> 'Brazil/DeNoronha',
        BrazilEast = <any> 'Brazil/East',
        BrazilWest = <any> 'Brazil/West',
        CET = <any> 'CET',
        CST6CDT = <any> 'CST6CDT',
        CanadaAtlantic = <any> 'Canada/Atlantic',
        CanadaCentral = <any> 'Canada/Central',
        CanadaEastern = <any> 'Canada/Eastern',
        CanadaMountain = <any> 'Canada/Mountain',
        CanadaNewfoundland = <any> 'Canada/Newfoundland',
        CanadaPacific = <any> 'Canada/Pacific',
        CanadaSaskatchewan = <any> 'Canada/Saskatchewan',
        CanadaYukon = <any> 'Canada/Yukon',
        ChileContinental = <any> 'Chile/Continental',
        ChileEasterIsland = <any> 'Chile/EasterIsland',
        Cuba = <any> 'Cuba',
        EET = <any> 'EET',
        EST = <any> 'EST',
        EST5EDT = <any> 'EST5EDT',
        Egypt = <any> 'Egypt',
        Eire = <any> 'Eire',
        EtcGMT = <any> 'Etc/GMT',
        EtcGMT0 = <any> 'Etc/GMT+0',
        EtcGMT1 = <any> 'Etc/GMT+1',
        EtcGMT10 = <any> 'Etc/GMT+10',
        EtcGMT11 = <any> 'Etc/GMT+11',
        EtcGMT12 = <any> 'Etc/GMT+12',
        EtcGMT2 = <any> 'Etc/GMT+2',
        EtcGMT3 = <any> 'Etc/GMT+3',
        EtcGMT4 = <any> 'Etc/GMT+4',
        EtcGMT5 = <any> 'Etc/GMT+5',
        EtcGMT6 = <any> 'Etc/GMT+6',
        EtcGMT7 = <any> 'Etc/GMT+7',
        EtcGMT8 = <any> 'Etc/GMT+8',
        EtcGMT9 = <any> 'Etc/GMT+9',
        EtcGMT0_404 = <any> 'Etc/GMT-0',
        EtcGMT1_405 = <any> 'Etc/GMT-1',
        EtcGMT10_406 = <any> 'Etc/GMT-10',
        EtcGMT11_407 = <any> 'Etc/GMT-11',
        EtcGMT12_408 = <any> 'Etc/GMT-12',
        EtcGMT13 = <any> 'Etc/GMT-13',
        EtcGMT14 = <any> 'Etc/GMT-14',
        EtcGMT2_411 = <any> 'Etc/GMT-2',
        EtcGMT3_412 = <any> 'Etc/GMT-3',
        EtcGMT4_413 = <any> 'Etc/GMT-4',
        EtcGMT5_414 = <any> 'Etc/GMT-5',
        EtcGMT6_415 = <any> 'Etc/GMT-6',
        EtcGMT7_416 = <any> 'Etc/GMT-7',
        EtcGMT8_417 = <any> 'Etc/GMT-8',
        EtcGMT9_418 = <any> 'Etc/GMT-9',
        EtcGMT0_419 = <any> 'Etc/GMT0',
        EtcGreenwich = <any> 'Etc/Greenwich',
        EtcUCT = <any> 'Etc/UCT',
        EtcUTC = <any> 'Etc/UTC',
        EtcUniversal = <any> 'Etc/Universal',
        EtcZulu = <any> 'Etc/Zulu',
        EuropeAmsterdam = <any> 'Europe/Amsterdam',
        EuropeAndorra = <any> 'Europe/Andorra',
        EuropeAstrakhan = <any> 'Europe/Astrakhan',
        EuropeAthens = <any> 'Europe/Athens',
        EuropeBelfast = <any> 'Europe/Belfast',
        EuropeBelgrade = <any> 'Europe/Belgrade',
        EuropeBerlin = <any> 'Europe/Berlin',
        EuropeBratislava = <any> 'Europe/Bratislava',
        EuropeBrussels = <any> 'Europe/Brussels',
        EuropeBucharest = <any> 'Europe/Bucharest',
        EuropeBudapest = <any> 'Europe/Budapest',
        EuropeBusingen = <any> 'Europe/Busingen',
        EuropeChisinau = <any> 'Europe/Chisinau',
        EuropeCopenhagen = <any> 'Europe/Copenhagen',
        EuropeDublin = <any> 'Europe/Dublin',
        EuropeGibraltar = <any> 'Europe/Gibraltar',
        EuropeGuernsey = <any> 'Europe/Guernsey',
        EuropeHelsinki = <any> 'Europe/Helsinki',
        EuropeIsleOfMan = <any> 'Europe/Isle_of_Man',
        EuropeIstanbul = <any> 'Europe/Istanbul',
        EuropeJersey = <any> 'Europe/Jersey',
        EuropeKaliningrad = <any> 'Europe/Kaliningrad',
        EuropeKiev = <any> 'Europe/Kiev',
        EuropeKirov = <any> 'Europe/Kirov',
        EuropeLisbon = <any> 'Europe/Lisbon',
        EuropeLjubljana = <any> 'Europe/Ljubljana',
        EuropeLondon = <any> 'Europe/London',
        EuropeLuxembourg = <any> 'Europe/Luxembourg',
        EuropeMadrid = <any> 'Europe/Madrid',
        EuropeMalta = <any> 'Europe/Malta',
        EuropeMariehamn = <any> 'Europe/Mariehamn',
        EuropeMinsk = <any> 'Europe/Minsk',
        EuropeMonaco = <any> 'Europe/Monaco',
        EuropeMoscow = <any> 'Europe/Moscow',
        EuropeNicosia = <any> 'Europe/Nicosia',
        EuropeOslo = <any> 'Europe/Oslo',
        EuropeParis = <any> 'Europe/Paris',
        EuropePodgorica = <any> 'Europe/Podgorica',
        EuropePrague = <any> 'Europe/Prague',
        EuropeRiga = <any> 'Europe/Riga',
        EuropeRome = <any> 'Europe/Rome',
        EuropeSamara = <any> 'Europe/Samara',
        EuropeSanMarino = <any> 'Europe/San_Marino',
        EuropeSarajevo = <any> 'Europe/Sarajevo',
        EuropeSaratov = <any> 'Europe/Saratov',
        EuropeSimferopol = <any> 'Europe/Simferopol',
        EuropeSkopje = <any> 'Europe/Skopje',
        EuropeSofia = <any> 'Europe/Sofia',
        EuropeStockholm = <any> 'Europe/Stockholm',
        EuropeTallinn = <any> 'Europe/Tallinn',
        EuropeTirane = <any> 'Europe/Tirane',
        EuropeTiraspol = <any> 'Europe/Tiraspol',
        EuropeUlyanovsk = <any> 'Europe/Ulyanovsk',
        EuropeUzhgorod = <any> 'Europe/Uzhgorod',
        EuropeVaduz = <any> 'Europe/Vaduz',
        EuropeVatican = <any> 'Europe/Vatican',
        EuropeVienna = <any> 'Europe/Vienna',
        EuropeVilnius = <any> 'Europe/Vilnius',
        EuropeVolgograd = <any> 'Europe/Volgograd',
        EuropeWarsaw = <any> 'Europe/Warsaw',
        EuropeZagreb = <any> 'Europe/Zagreb',
        EuropeZaporozhye = <any> 'Europe/Zaporozhye',
        EuropeZurich = <any> 'Europe/Zurich',
        GB = <any> 'GB',
        GBEire = <any> 'GB-Eire',
        GMT = <any> 'GMT',
        GMT0 = <any> 'GMT+0',
        GMT0_492 = <any> 'GMT-0',
        GMT0_493 = <any> 'GMT0',
        Greenwich = <any> 'Greenwich',
        HST = <any> 'HST',
        Hongkong = <any> 'Hongkong',
        Iceland = <any> 'Iceland',
        IndianAntananarivo = <any> 'Indian/Antananarivo',
        IndianChagos = <any> 'Indian/Chagos',
        IndianChristmas = <any> 'Indian/Christmas',
        IndianCocos = <any> 'Indian/Cocos',
        IndianComoro = <any> 'Indian/Comoro',
        IndianKerguelen = <any> 'Indian/Kerguelen',
        IndianMahe = <any> 'Indian/Mahe',
        IndianMaldives = <any> 'Indian/Maldives',
        IndianMauritius = <any> 'Indian/Mauritius',
        IndianMayotte = <any> 'Indian/Mayotte',
        IndianReunion = <any> 'Indian/Reunion',
        Iran = <any> 'Iran',
        Israel = <any> 'Israel',
        Jamaica = <any> 'Jamaica',
        Japan = <any> 'Japan',
        Kwajalein = <any> 'Kwajalein',
        Libya = <any> 'Libya',
        MET = <any> 'MET',
        MST = <any> 'MST',
        MST7MDT = <any> 'MST7MDT',
        MexicoBajaNorte = <any> 'Mexico/BajaNorte',
        MexicoBajaSur = <any> 'Mexico/BajaSur',
        MexicoGeneral = <any> 'Mexico/General',
        NZ = <any> 'NZ',
        NZCHAT = <any> 'NZ-CHAT',
        Navajo = <any> 'Navajo',
        PRC = <any> 'PRC',
        PST8PDT = <any> 'PST8PDT',
        PacificApia = <any> 'Pacific/Apia',
        PacificAuckland = <any> 'Pacific/Auckland',
        PacificBougainville = <any> 'Pacific/Bougainville',
        PacificChatham = <any> 'Pacific/Chatham',
        PacificChuuk = <any> 'Pacific/Chuuk',
        PacificEaster = <any> 'Pacific/Easter',
        PacificEfate = <any> 'Pacific/Efate',
        PacificEnderbury = <any> 'Pacific/Enderbury',
        PacificFakaofo = <any> 'Pacific/Fakaofo',
        PacificFiji = <any> 'Pacific/Fiji',
        PacificFunafuti = <any> 'Pacific/Funafuti',
        PacificGalapagos = <any> 'Pacific/Galapagos',
        PacificGambier = <any> 'Pacific/Gambier',
        PacificGuadalcanal = <any> 'Pacific/Guadalcanal',
        PacificGuam = <any> 'Pacific/Guam',
        PacificHonolulu = <any> 'Pacific/Honolulu',
        PacificJohnston = <any> 'Pacific/Johnston',
        PacificKanton = <any> 'Pacific/Kanton',
        PacificKiritimati = <any> 'Pacific/Kiritimati',
        PacificKosrae = <any> 'Pacific/Kosrae',
        PacificKwajalein = <any> 'Pacific/Kwajalein',
        PacificMajuro = <any> 'Pacific/Majuro',
        PacificMarquesas = <any> 'Pacific/Marquesas',
        PacificMidway = <any> 'Pacific/Midway',
        PacificNauru = <any> 'Pacific/Nauru',
        PacificNiue = <any> 'Pacific/Niue',
        PacificNorfolk = <any> 'Pacific/Norfolk',
        PacificNoumea = <any> 'Pacific/Noumea',
        PacificPagoPago = <any> 'Pacific/Pago_Pago',
        PacificPalau = <any> 'Pacific/Palau',
        PacificPitcairn = <any> 'Pacific/Pitcairn',
        PacificPohnpei = <any> 'Pacific/Pohnpei',
        PacificPonape = <any> 'Pacific/Ponape',
        PacificPortMoresby = <any> 'Pacific/Port_Moresby',
        PacificRarotonga = <any> 'Pacific/Rarotonga',
        PacificSaipan = <any> 'Pacific/Saipan',
        PacificSamoa = <any> 'Pacific/Samoa',
        PacificTahiti = <any> 'Pacific/Tahiti',
        PacificTarawa = <any> 'Pacific/Tarawa',
        PacificTongatapu = <any> 'Pacific/Tongatapu',
        PacificTruk = <any> 'Pacific/Truk',
        PacificWake = <any> 'Pacific/Wake',
        PacificWallis = <any> 'Pacific/Wallis',
        PacificYap = <any> 'Pacific/Yap',
        Poland = <any> 'Poland',
        Portugal = <any> 'Portugal',
        ROC = <any> 'ROC',
        ROK = <any> 'ROK',
        Singapore = <any> 'Singapore',
        Turkey = <any> 'Turkey',
        UCT = <any> 'UCT',
        USAlaska = <any> 'US/Alaska',
        USAleutian = <any> 'US/Aleutian',
        USArizona = <any> 'US/Arizona',
        USCentral = <any> 'US/Central',
        USEastIndiana = <any> 'US/East-Indiana',
        USEastern = <any> 'US/Eastern',
        USHawaii = <any> 'US/Hawaii',
        USIndianaStarke = <any> 'US/Indiana-Starke',
        USMichigan = <any> 'US/Michigan',
        USMountain = <any> 'US/Mountain',
        USPacific = <any> 'US/Pacific',
        USSamoa = <any> 'US/Samoa',
        UTC = <any> 'UTC',
        Universal = <any> 'Universal',
        WSU = <any> 'W-SU',
        WET = <any> 'WET',
        Zulu = <any> 'Zulu'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Alert = <any> 'Alert',
        Report = <any> 'Report'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ValidatorTypeEnum {
        NotNull = <any> 'not null',
        Operator = <any> 'operator'
    }
}
/**
 * 
 * @export
 * @interface ReportScheduleRestApiPut
 */
export interface ReportScheduleRestApiPut {
    /**
     * 
     * @type {boolean}
     * @memberof ReportScheduleRestApiPut
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiPut
     */
    chart?: number;
    /**
     * Markdown description
     * @type {string}
     * @memberof ReportScheduleRestApiPut
     */
    contextMarkdown?: string;
    /**
     * Creation method is used to inform the frontend whether the report/alert was created in the dashboard, chart, or alerts and reports UI.
     * @type {any}
     * @memberof ReportScheduleRestApiPut
     */
    creationMethod?: any;
    /**
     * A CRON expression.[Crontab Guru](https://crontab.guru/) is a helpful resource that can help you craft a CRON expression.
     * @type {string}
     * @memberof ReportScheduleRestApiPut
     */
    crontab?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiPut
     */
    dashboard?: number;
    /**
     * 
     * @type {number}
     * @memberof ReportScheduleRestApiPut
     */
    database?: number;
    /**
     * Use a nice description to give context to this Alert/Report
     * @type {string}
     * @memberof ReportScheduleRestApiPut
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof ReportScheduleRestApiPut
     */
    extra?: any;
    /**
     * 
     * @type {boolean}
     * @memberof ReportScheduleRestApiPut
     */
    forceScreenshot?: boolean;
    /**
     * Once an alert is triggered, how long, in seconds, before Superset nags you again. (in seconds)
     * @type {number}
     * @memberof ReportScheduleRestApiPut
     */
    gracePeriod?: number;
    /**
     * How long to keep the logs around for this report (in days)
     * @type {number}
     * @memberof ReportScheduleRestApiPut
     */
    logRetention?: number;
    /**
     * The report schedule name.
     * @type {string}
     * @memberof ReportScheduleRestApiPut
     */
    name?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ReportScheduleRestApiPut
     */
    owners?: Array<number>;
    /**
     * 
     * @type {Array<ReportRecipient>}
     * @memberof ReportScheduleRestApiPut
     */
    recipients?: Array<ReportRecipient>;
    /**
     * 
     * @type {string}
     * @memberof ReportScheduleRestApiPut
     */
    reportFormat?: ReportScheduleRestApiPut.ReportFormatEnum;
    /**
     * A SQL statement that defines whether the alert should get triggered or not. The query is expected to return either NULL or a number value.
     * @type {string}
     * @memberof ReportScheduleRestApiPut
     */
    sql?: string;
    /**
     * A timezone string that represents the location of the timezone.
     * @type {string}
     * @memberof ReportScheduleRestApiPut
     */
    timezone?: ReportScheduleRestApiPut.TimezoneEnum;
    /**
     * The report schedule type
     * @type {string}
     * @memberof ReportScheduleRestApiPut
     */
    type?: ReportScheduleRestApiPut.TypeEnum;
    /**
     * 
     * @type {ValidatorConfigJSON}
     * @memberof ReportScheduleRestApiPut
     */
    validatorConfigJson?: ValidatorConfigJSON;
    /**
     * Determines when to trigger alert based off value from alert query. Alerts will be triggered with these validator types: - Not Null - When the return value is Not NULL, Empty, or 0 - Operator - When `sql_return_value comparison_operator threshold` is True e.g. `50 <= 75`<br>Supports the comparison operators <, <=, >, >=, ==, and !=
     * @type {string}
     * @memberof ReportScheduleRestApiPut
     */
    validatorType?: ReportScheduleRestApiPut.ValidatorTypeEnum;
    /**
     * If an alert is staled at a working state, how long until it's state is reseted to error
     * @type {number}
     * @memberof ReportScheduleRestApiPut
     */
    workingTimeout?: number;
}

/**
 * @export
 * @namespace ReportScheduleRestApiPut
 */
export namespace ReportScheduleRestApiPut {
    /**
     * @export
     * @enum {string}
     */
    export enum ReportFormatEnum {
        PNG = <any> 'PNG',
        CSV = <any> 'CSV',
        TEXT = <any> 'TEXT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TimezoneEnum {
        AfricaAbidjan = <any> 'Africa/Abidjan',
        AfricaAccra = <any> 'Africa/Accra',
        AfricaAddisAbaba = <any> 'Africa/Addis_Ababa',
        AfricaAlgiers = <any> 'Africa/Algiers',
        AfricaAsmara = <any> 'Africa/Asmara',
        AfricaAsmera = <any> 'Africa/Asmera',
        AfricaBamako = <any> 'Africa/Bamako',
        AfricaBangui = <any> 'Africa/Bangui',
        AfricaBanjul = <any> 'Africa/Banjul',
        AfricaBissau = <any> 'Africa/Bissau',
        AfricaBlantyre = <any> 'Africa/Blantyre',
        AfricaBrazzaville = <any> 'Africa/Brazzaville',
        AfricaBujumbura = <any> 'Africa/Bujumbura',
        AfricaCairo = <any> 'Africa/Cairo',
        AfricaCasablanca = <any> 'Africa/Casablanca',
        AfricaCeuta = <any> 'Africa/Ceuta',
        AfricaConakry = <any> 'Africa/Conakry',
        AfricaDakar = <any> 'Africa/Dakar',
        AfricaDarEsSalaam = <any> 'Africa/Dar_es_Salaam',
        AfricaDjibouti = <any> 'Africa/Djibouti',
        AfricaDouala = <any> 'Africa/Douala',
        AfricaElAaiun = <any> 'Africa/El_Aaiun',
        AfricaFreetown = <any> 'Africa/Freetown',
        AfricaGaborone = <any> 'Africa/Gaborone',
        AfricaHarare = <any> 'Africa/Harare',
        AfricaJohannesburg = <any> 'Africa/Johannesburg',
        AfricaJuba = <any> 'Africa/Juba',
        AfricaKampala = <any> 'Africa/Kampala',
        AfricaKhartoum = <any> 'Africa/Khartoum',
        AfricaKigali = <any> 'Africa/Kigali',
        AfricaKinshasa = <any> 'Africa/Kinshasa',
        AfricaLagos = <any> 'Africa/Lagos',
        AfricaLibreville = <any> 'Africa/Libreville',
        AfricaLome = <any> 'Africa/Lome',
        AfricaLuanda = <any> 'Africa/Luanda',
        AfricaLubumbashi = <any> 'Africa/Lubumbashi',
        AfricaLusaka = <any> 'Africa/Lusaka',
        AfricaMalabo = <any> 'Africa/Malabo',
        AfricaMaputo = <any> 'Africa/Maputo',
        AfricaMaseru = <any> 'Africa/Maseru',
        AfricaMbabane = <any> 'Africa/Mbabane',
        AfricaMogadishu = <any> 'Africa/Mogadishu',
        AfricaMonrovia = <any> 'Africa/Monrovia',
        AfricaNairobi = <any> 'Africa/Nairobi',
        AfricaNdjamena = <any> 'Africa/Ndjamena',
        AfricaNiamey = <any> 'Africa/Niamey',
        AfricaNouakchott = <any> 'Africa/Nouakchott',
        AfricaOuagadougou = <any> 'Africa/Ouagadougou',
        AfricaPortoNovo = <any> 'Africa/Porto-Novo',
        AfricaSaoTome = <any> 'Africa/Sao_Tome',
        AfricaTimbuktu = <any> 'Africa/Timbuktu',
        AfricaTripoli = <any> 'Africa/Tripoli',
        AfricaTunis = <any> 'Africa/Tunis',
        AfricaWindhoek = <any> 'Africa/Windhoek',
        AmericaAdak = <any> 'America/Adak',
        AmericaAnchorage = <any> 'America/Anchorage',
        AmericaAnguilla = <any> 'America/Anguilla',
        AmericaAntigua = <any> 'America/Antigua',
        AmericaAraguaina = <any> 'America/Araguaina',
        AmericaArgentinaBuenosAires = <any> 'America/Argentina/Buenos_Aires',
        AmericaArgentinaCatamarca = <any> 'America/Argentina/Catamarca',
        AmericaArgentinaComodRivadavia = <any> 'America/Argentina/ComodRivadavia',
        AmericaArgentinaCordoba = <any> 'America/Argentina/Cordoba',
        AmericaArgentinaJujuy = <any> 'America/Argentina/Jujuy',
        AmericaArgentinaLaRioja = <any> 'America/Argentina/La_Rioja',
        AmericaArgentinaMendoza = <any> 'America/Argentina/Mendoza',
        AmericaArgentinaRioGallegos = <any> 'America/Argentina/Rio_Gallegos',
        AmericaArgentinaSalta = <any> 'America/Argentina/Salta',
        AmericaArgentinaSanJuan = <any> 'America/Argentina/San_Juan',
        AmericaArgentinaSanLuis = <any> 'America/Argentina/San_Luis',
        AmericaArgentinaTucuman = <any> 'America/Argentina/Tucuman',
        AmericaArgentinaUshuaia = <any> 'America/Argentina/Ushuaia',
        AmericaAruba = <any> 'America/Aruba',
        AmericaAsuncion = <any> 'America/Asuncion',
        AmericaAtikokan = <any> 'America/Atikokan',
        AmericaAtka = <any> 'America/Atka',
        AmericaBahia = <any> 'America/Bahia',
        AmericaBahiaBanderas = <any> 'America/Bahia_Banderas',
        AmericaBarbados = <any> 'America/Barbados',
        AmericaBelem = <any> 'America/Belem',
        AmericaBelize = <any> 'America/Belize',
        AmericaBlancSablon = <any> 'America/Blanc-Sablon',
        AmericaBoaVista = <any> 'America/Boa_Vista',
        AmericaBogota = <any> 'America/Bogota',
        AmericaBoise = <any> 'America/Boise',
        AmericaBuenosAires = <any> 'America/Buenos_Aires',
        AmericaCambridgeBay = <any> 'America/Cambridge_Bay',
        AmericaCampoGrande = <any> 'America/Campo_Grande',
        AmericaCancun = <any> 'America/Cancun',
        AmericaCaracas = <any> 'America/Caracas',
        AmericaCatamarca = <any> 'America/Catamarca',
        AmericaCayenne = <any> 'America/Cayenne',
        AmericaCayman = <any> 'America/Cayman',
        AmericaChicago = <any> 'America/Chicago',
        AmericaChihuahua = <any> 'America/Chihuahua',
        AmericaCoralHarbour = <any> 'America/Coral_Harbour',
        AmericaCordoba = <any> 'America/Cordoba',
        AmericaCostaRica = <any> 'America/Costa_Rica',
        AmericaCreston = <any> 'America/Creston',
        AmericaCuiaba = <any> 'America/Cuiaba',
        AmericaCuracao = <any> 'America/Curacao',
        AmericaDanmarkshavn = <any> 'America/Danmarkshavn',
        AmericaDawson = <any> 'America/Dawson',
        AmericaDawsonCreek = <any> 'America/Dawson_Creek',
        AmericaDenver = <any> 'America/Denver',
        AmericaDetroit = <any> 'America/Detroit',
        AmericaDominica = <any> 'America/Dominica',
        AmericaEdmonton = <any> 'America/Edmonton',
        AmericaEirunepe = <any> 'America/Eirunepe',
        AmericaElSalvador = <any> 'America/El_Salvador',
        AmericaEnsenada = <any> 'America/Ensenada',
        AmericaFortNelson = <any> 'America/Fort_Nelson',
        AmericaFortWayne = <any> 'America/Fort_Wayne',
        AmericaFortaleza = <any> 'America/Fortaleza',
        AmericaGlaceBay = <any> 'America/Glace_Bay',
        AmericaGodthab = <any> 'America/Godthab',
        AmericaGooseBay = <any> 'America/Goose_Bay',
        AmericaGrandTurk = <any> 'America/Grand_Turk',
        AmericaGrenada = <any> 'America/Grenada',
        AmericaGuadeloupe = <any> 'America/Guadeloupe',
        AmericaGuatemala = <any> 'America/Guatemala',
        AmericaGuayaquil = <any> 'America/Guayaquil',
        AmericaGuyana = <any> 'America/Guyana',
        AmericaHalifax = <any> 'America/Halifax',
        AmericaHavana = <any> 'America/Havana',
        AmericaHermosillo = <any> 'America/Hermosillo',
        AmericaIndianaIndianapolis = <any> 'America/Indiana/Indianapolis',
        AmericaIndianaKnox = <any> 'America/Indiana/Knox',
        AmericaIndianaMarengo = <any> 'America/Indiana/Marengo',
        AmericaIndianaPetersburg = <any> 'America/Indiana/Petersburg',
        AmericaIndianaTellCity = <any> 'America/Indiana/Tell_City',
        AmericaIndianaVevay = <any> 'America/Indiana/Vevay',
        AmericaIndianaVincennes = <any> 'America/Indiana/Vincennes',
        AmericaIndianaWinamac = <any> 'America/Indiana/Winamac',
        AmericaIndianapolis = <any> 'America/Indianapolis',
        AmericaInuvik = <any> 'America/Inuvik',
        AmericaIqaluit = <any> 'America/Iqaluit',
        AmericaJamaica = <any> 'America/Jamaica',
        AmericaJujuy = <any> 'America/Jujuy',
        AmericaJuneau = <any> 'America/Juneau',
        AmericaKentuckyLouisville = <any> 'America/Kentucky/Louisville',
        AmericaKentuckyMonticello = <any> 'America/Kentucky/Monticello',
        AmericaKnoxIN = <any> 'America/Knox_IN',
        AmericaKralendijk = <any> 'America/Kralendijk',
        AmericaLaPaz = <any> 'America/La_Paz',
        AmericaLima = <any> 'America/Lima',
        AmericaLosAngeles = <any> 'America/Los_Angeles',
        AmericaLouisville = <any> 'America/Louisville',
        AmericaLowerPrinces = <any> 'America/Lower_Princes',
        AmericaMaceio = <any> 'America/Maceio',
        AmericaManagua = <any> 'America/Managua',
        AmericaManaus = <any> 'America/Manaus',
        AmericaMarigot = <any> 'America/Marigot',
        AmericaMartinique = <any> 'America/Martinique',
        AmericaMatamoros = <any> 'America/Matamoros',
        AmericaMazatlan = <any> 'America/Mazatlan',
        AmericaMendoza = <any> 'America/Mendoza',
        AmericaMenominee = <any> 'America/Menominee',
        AmericaMerida = <any> 'America/Merida',
        AmericaMetlakatla = <any> 'America/Metlakatla',
        AmericaMexicoCity = <any> 'America/Mexico_City',
        AmericaMiquelon = <any> 'America/Miquelon',
        AmericaMoncton = <any> 'America/Moncton',
        AmericaMonterrey = <any> 'America/Monterrey',
        AmericaMontevideo = <any> 'America/Montevideo',
        AmericaMontreal = <any> 'America/Montreal',
        AmericaMontserrat = <any> 'America/Montserrat',
        AmericaNassau = <any> 'America/Nassau',
        AmericaNewYork = <any> 'America/New_York',
        AmericaNipigon = <any> 'America/Nipigon',
        AmericaNome = <any> 'America/Nome',
        AmericaNoronha = <any> 'America/Noronha',
        AmericaNorthDakotaBeulah = <any> 'America/North_Dakota/Beulah',
        AmericaNorthDakotaCenter = <any> 'America/North_Dakota/Center',
        AmericaNorthDakotaNewSalem = <any> 'America/North_Dakota/New_Salem',
        AmericaNuuk = <any> 'America/Nuuk',
        AmericaOjinaga = <any> 'America/Ojinaga',
        AmericaPanama = <any> 'America/Panama',
        AmericaPangnirtung = <any> 'America/Pangnirtung',
        AmericaParamaribo = <any> 'America/Paramaribo',
        AmericaPhoenix = <any> 'America/Phoenix',
        AmericaPortAuPrince = <any> 'America/Port-au-Prince',
        AmericaPortOfSpain = <any> 'America/Port_of_Spain',
        AmericaPortoAcre = <any> 'America/Porto_Acre',
        AmericaPortoVelho = <any> 'America/Porto_Velho',
        AmericaPuertoRico = <any> 'America/Puerto_Rico',
        AmericaPuntaArenas = <any> 'America/Punta_Arenas',
        AmericaRainyRiver = <any> 'America/Rainy_River',
        AmericaRankinInlet = <any> 'America/Rankin_Inlet',
        AmericaRecife = <any> 'America/Recife',
        AmericaRegina = <any> 'America/Regina',
        AmericaResolute = <any> 'America/Resolute',
        AmericaRioBranco = <any> 'America/Rio_Branco',
        AmericaRosario = <any> 'America/Rosario',
        AmericaSantaIsabel = <any> 'America/Santa_Isabel',
        AmericaSantarem = <any> 'America/Santarem',
        AmericaSantiago = <any> 'America/Santiago',
        AmericaSantoDomingo = <any> 'America/Santo_Domingo',
        AmericaSaoPaulo = <any> 'America/Sao_Paulo',
        AmericaScoresbysund = <any> 'America/Scoresbysund',
        AmericaShiprock = <any> 'America/Shiprock',
        AmericaSitka = <any> 'America/Sitka',
        AmericaStBarthelemy = <any> 'America/St_Barthelemy',
        AmericaStJohns = <any> 'America/St_Johns',
        AmericaStKitts = <any> 'America/St_Kitts',
        AmericaStLucia = <any> 'America/St_Lucia',
        AmericaStThomas = <any> 'America/St_Thomas',
        AmericaStVincent = <any> 'America/St_Vincent',
        AmericaSwiftCurrent = <any> 'America/Swift_Current',
        AmericaTegucigalpa = <any> 'America/Tegucigalpa',
        AmericaThule = <any> 'America/Thule',
        AmericaThunderBay = <any> 'America/Thunder_Bay',
        AmericaTijuana = <any> 'America/Tijuana',
        AmericaToronto = <any> 'America/Toronto',
        AmericaTortola = <any> 'America/Tortola',
        AmericaVancouver = <any> 'America/Vancouver',
        AmericaVirgin = <any> 'America/Virgin',
        AmericaWhitehorse = <any> 'America/Whitehorse',
        AmericaWinnipeg = <any> 'America/Winnipeg',
        AmericaYakutat = <any> 'America/Yakutat',
        AmericaYellowknife = <any> 'America/Yellowknife',
        AntarcticaCasey = <any> 'Antarctica/Casey',
        AntarcticaDavis = <any> 'Antarctica/Davis',
        AntarcticaDumontDUrville = <any> 'Antarctica/DumontDUrville',
        AntarcticaMacquarie = <any> 'Antarctica/Macquarie',
        AntarcticaMawson = <any> 'Antarctica/Mawson',
        AntarcticaMcMurdo = <any> 'Antarctica/McMurdo',
        AntarcticaPalmer = <any> 'Antarctica/Palmer',
        AntarcticaRothera = <any> 'Antarctica/Rothera',
        AntarcticaSouthPole = <any> 'Antarctica/South_Pole',
        AntarcticaSyowa = <any> 'Antarctica/Syowa',
        AntarcticaTroll = <any> 'Antarctica/Troll',
        AntarcticaVostok = <any> 'Antarctica/Vostok',
        ArcticLongyearbyen = <any> 'Arctic/Longyearbyen',
        AsiaAden = <any> 'Asia/Aden',
        AsiaAlmaty = <any> 'Asia/Almaty',
        AsiaAmman = <any> 'Asia/Amman',
        AsiaAnadyr = <any> 'Asia/Anadyr',
        AsiaAqtau = <any> 'Asia/Aqtau',
        AsiaAqtobe = <any> 'Asia/Aqtobe',
        AsiaAshgabat = <any> 'Asia/Ashgabat',
        AsiaAshkhabad = <any> 'Asia/Ashkhabad',
        AsiaAtyrau = <any> 'Asia/Atyrau',
        AsiaBaghdad = <any> 'Asia/Baghdad',
        AsiaBahrain = <any> 'Asia/Bahrain',
        AsiaBaku = <any> 'Asia/Baku',
        AsiaBangkok = <any> 'Asia/Bangkok',
        AsiaBarnaul = <any> 'Asia/Barnaul',
        AsiaBeirut = <any> 'Asia/Beirut',
        AsiaBishkek = <any> 'Asia/Bishkek',
        AsiaBrunei = <any> 'Asia/Brunei',
        AsiaCalcutta = <any> 'Asia/Calcutta',
        AsiaChita = <any> 'Asia/Chita',
        AsiaChoibalsan = <any> 'Asia/Choibalsan',
        AsiaChongqing = <any> 'Asia/Chongqing',
        AsiaChungking = <any> 'Asia/Chungking',
        AsiaColombo = <any> 'Asia/Colombo',
        AsiaDacca = <any> 'Asia/Dacca',
        AsiaDamascus = <any> 'Asia/Damascus',
        AsiaDhaka = <any> 'Asia/Dhaka',
        AsiaDili = <any> 'Asia/Dili',
        AsiaDubai = <any> 'Asia/Dubai',
        AsiaDushanbe = <any> 'Asia/Dushanbe',
        AsiaFamagusta = <any> 'Asia/Famagusta',
        AsiaGaza = <any> 'Asia/Gaza',
        AsiaHarbin = <any> 'Asia/Harbin',
        AsiaHebron = <any> 'Asia/Hebron',
        AsiaHoChiMinh = <any> 'Asia/Ho_Chi_Minh',
        AsiaHongKong = <any> 'Asia/Hong_Kong',
        AsiaHovd = <any> 'Asia/Hovd',
        AsiaIrkutsk = <any> 'Asia/Irkutsk',
        AsiaIstanbul = <any> 'Asia/Istanbul',
        AsiaJakarta = <any> 'Asia/Jakarta',
        AsiaJayapura = <any> 'Asia/Jayapura',
        AsiaJerusalem = <any> 'Asia/Jerusalem',
        AsiaKabul = <any> 'Asia/Kabul',
        AsiaKamchatka = <any> 'Asia/Kamchatka',
        AsiaKarachi = <any> 'Asia/Karachi',
        AsiaKashgar = <any> 'Asia/Kashgar',
        AsiaKathmandu = <any> 'Asia/Kathmandu',
        AsiaKatmandu = <any> 'Asia/Katmandu',
        AsiaKhandyga = <any> 'Asia/Khandyga',
        AsiaKolkata = <any> 'Asia/Kolkata',
        AsiaKrasnoyarsk = <any> 'Asia/Krasnoyarsk',
        AsiaKualaLumpur = <any> 'Asia/Kuala_Lumpur',
        AsiaKuching = <any> 'Asia/Kuching',
        AsiaKuwait = <any> 'Asia/Kuwait',
        AsiaMacao = <any> 'Asia/Macao',
        AsiaMacau = <any> 'Asia/Macau',
        AsiaMagadan = <any> 'Asia/Magadan',
        AsiaMakassar = <any> 'Asia/Makassar',
        AsiaManila = <any> 'Asia/Manila',
        AsiaMuscat = <any> 'Asia/Muscat',
        AsiaNicosia = <any> 'Asia/Nicosia',
        AsiaNovokuznetsk = <any> 'Asia/Novokuznetsk',
        AsiaNovosibirsk = <any> 'Asia/Novosibirsk',
        AsiaOmsk = <any> 'Asia/Omsk',
        AsiaOral = <any> 'Asia/Oral',
        AsiaPhnomPenh = <any> 'Asia/Phnom_Penh',
        AsiaPontianak = <any> 'Asia/Pontianak',
        AsiaPyongyang = <any> 'Asia/Pyongyang',
        AsiaQatar = <any> 'Asia/Qatar',
        AsiaQostanay = <any> 'Asia/Qostanay',
        AsiaQyzylorda = <any> 'Asia/Qyzylorda',
        AsiaRangoon = <any> 'Asia/Rangoon',
        AsiaRiyadh = <any> 'Asia/Riyadh',
        AsiaSaigon = <any> 'Asia/Saigon',
        AsiaSakhalin = <any> 'Asia/Sakhalin',
        AsiaSamarkand = <any> 'Asia/Samarkand',
        AsiaSeoul = <any> 'Asia/Seoul',
        AsiaShanghai = <any> 'Asia/Shanghai',
        AsiaSingapore = <any> 'Asia/Singapore',
        AsiaSrednekolymsk = <any> 'Asia/Srednekolymsk',
        AsiaTaipei = <any> 'Asia/Taipei',
        AsiaTashkent = <any> 'Asia/Tashkent',
        AsiaTbilisi = <any> 'Asia/Tbilisi',
        AsiaTehran = <any> 'Asia/Tehran',
        AsiaTelAviv = <any> 'Asia/Tel_Aviv',
        AsiaThimbu = <any> 'Asia/Thimbu',
        AsiaThimphu = <any> 'Asia/Thimphu',
        AsiaTokyo = <any> 'Asia/Tokyo',
        AsiaTomsk = <any> 'Asia/Tomsk',
        AsiaUjungPandang = <any> 'Asia/Ujung_Pandang',
        AsiaUlaanbaatar = <any> 'Asia/Ulaanbaatar',
        AsiaUlanBator = <any> 'Asia/Ulan_Bator',
        AsiaUrumqi = <any> 'Asia/Urumqi',
        AsiaUstNera = <any> 'Asia/Ust-Nera',
        AsiaVientiane = <any> 'Asia/Vientiane',
        AsiaVladivostok = <any> 'Asia/Vladivostok',
        AsiaYakutsk = <any> 'Asia/Yakutsk',
        AsiaYangon = <any> 'Asia/Yangon',
        AsiaYekaterinburg = <any> 'Asia/Yekaterinburg',
        AsiaYerevan = <any> 'Asia/Yerevan',
        AtlanticAzores = <any> 'Atlantic/Azores',
        AtlanticBermuda = <any> 'Atlantic/Bermuda',
        AtlanticCanary = <any> 'Atlantic/Canary',
        AtlanticCapeVerde = <any> 'Atlantic/Cape_Verde',
        AtlanticFaeroe = <any> 'Atlantic/Faeroe',
        AtlanticFaroe = <any> 'Atlantic/Faroe',
        AtlanticJanMayen = <any> 'Atlantic/Jan_Mayen',
        AtlanticMadeira = <any> 'Atlantic/Madeira',
        AtlanticReykjavik = <any> 'Atlantic/Reykjavik',
        AtlanticSouthGeorgia = <any> 'Atlantic/South_Georgia',
        AtlanticStHelena = <any> 'Atlantic/St_Helena',
        AtlanticStanley = <any> 'Atlantic/Stanley',
        AustraliaACT = <any> 'Australia/ACT',
        AustraliaAdelaide = <any> 'Australia/Adelaide',
        AustraliaBrisbane = <any> 'Australia/Brisbane',
        AustraliaBrokenHill = <any> 'Australia/Broken_Hill',
        AustraliaCanberra = <any> 'Australia/Canberra',
        AustraliaCurrie = <any> 'Australia/Currie',
        AustraliaDarwin = <any> 'Australia/Darwin',
        AustraliaEucla = <any> 'Australia/Eucla',
        AustraliaHobart = <any> 'Australia/Hobart',
        AustraliaLHI = <any> 'Australia/LHI',
        AustraliaLindeman = <any> 'Australia/Lindeman',
        AustraliaLordHowe = <any> 'Australia/Lord_Howe',
        AustraliaMelbourne = <any> 'Australia/Melbourne',
        AustraliaNSW = <any> 'Australia/NSW',
        AustraliaNorth = <any> 'Australia/North',
        AustraliaPerth = <any> 'Australia/Perth',
        AustraliaQueensland = <any> 'Australia/Queensland',
        AustraliaSouth = <any> 'Australia/South',
        AustraliaSydney = <any> 'Australia/Sydney',
        AustraliaTasmania = <any> 'Australia/Tasmania',
        AustraliaVictoria = <any> 'Australia/Victoria',
        AustraliaWest = <any> 'Australia/West',
        AustraliaYancowinna = <any> 'Australia/Yancowinna',
        BrazilAcre = <any> 'Brazil/Acre',
        BrazilDeNoronha = <any> 'Brazil/DeNoronha',
        BrazilEast = <any> 'Brazil/East',
        BrazilWest = <any> 'Brazil/West',
        CET = <any> 'CET',
        CST6CDT = <any> 'CST6CDT',
        CanadaAtlantic = <any> 'Canada/Atlantic',
        CanadaCentral = <any> 'Canada/Central',
        CanadaEastern = <any> 'Canada/Eastern',
        CanadaMountain = <any> 'Canada/Mountain',
        CanadaNewfoundland = <any> 'Canada/Newfoundland',
        CanadaPacific = <any> 'Canada/Pacific',
        CanadaSaskatchewan = <any> 'Canada/Saskatchewan',
        CanadaYukon = <any> 'Canada/Yukon',
        ChileContinental = <any> 'Chile/Continental',
        ChileEasterIsland = <any> 'Chile/EasterIsland',
        Cuba = <any> 'Cuba',
        EET = <any> 'EET',
        EST = <any> 'EST',
        EST5EDT = <any> 'EST5EDT',
        Egypt = <any> 'Egypt',
        Eire = <any> 'Eire',
        EtcGMT = <any> 'Etc/GMT',
        EtcGMT0 = <any> 'Etc/GMT+0',
        EtcGMT1 = <any> 'Etc/GMT+1',
        EtcGMT10 = <any> 'Etc/GMT+10',
        EtcGMT11 = <any> 'Etc/GMT+11',
        EtcGMT12 = <any> 'Etc/GMT+12',
        EtcGMT2 = <any> 'Etc/GMT+2',
        EtcGMT3 = <any> 'Etc/GMT+3',
        EtcGMT4 = <any> 'Etc/GMT+4',
        EtcGMT5 = <any> 'Etc/GMT+5',
        EtcGMT6 = <any> 'Etc/GMT+6',
        EtcGMT7 = <any> 'Etc/GMT+7',
        EtcGMT8 = <any> 'Etc/GMT+8',
        EtcGMT9 = <any> 'Etc/GMT+9',
        EtcGMT0_404 = <any> 'Etc/GMT-0',
        EtcGMT1_405 = <any> 'Etc/GMT-1',
        EtcGMT10_406 = <any> 'Etc/GMT-10',
        EtcGMT11_407 = <any> 'Etc/GMT-11',
        EtcGMT12_408 = <any> 'Etc/GMT-12',
        EtcGMT13 = <any> 'Etc/GMT-13',
        EtcGMT14 = <any> 'Etc/GMT-14',
        EtcGMT2_411 = <any> 'Etc/GMT-2',
        EtcGMT3_412 = <any> 'Etc/GMT-3',
        EtcGMT4_413 = <any> 'Etc/GMT-4',
        EtcGMT5_414 = <any> 'Etc/GMT-5',
        EtcGMT6_415 = <any> 'Etc/GMT-6',
        EtcGMT7_416 = <any> 'Etc/GMT-7',
        EtcGMT8_417 = <any> 'Etc/GMT-8',
        EtcGMT9_418 = <any> 'Etc/GMT-9',
        EtcGMT0_419 = <any> 'Etc/GMT0',
        EtcGreenwich = <any> 'Etc/Greenwich',
        EtcUCT = <any> 'Etc/UCT',
        EtcUTC = <any> 'Etc/UTC',
        EtcUniversal = <any> 'Etc/Universal',
        EtcZulu = <any> 'Etc/Zulu',
        EuropeAmsterdam = <any> 'Europe/Amsterdam',
        EuropeAndorra = <any> 'Europe/Andorra',
        EuropeAstrakhan = <any> 'Europe/Astrakhan',
        EuropeAthens = <any> 'Europe/Athens',
        EuropeBelfast = <any> 'Europe/Belfast',
        EuropeBelgrade = <any> 'Europe/Belgrade',
        EuropeBerlin = <any> 'Europe/Berlin',
        EuropeBratislava = <any> 'Europe/Bratislava',
        EuropeBrussels = <any> 'Europe/Brussels',
        EuropeBucharest = <any> 'Europe/Bucharest',
        EuropeBudapest = <any> 'Europe/Budapest',
        EuropeBusingen = <any> 'Europe/Busingen',
        EuropeChisinau = <any> 'Europe/Chisinau',
        EuropeCopenhagen = <any> 'Europe/Copenhagen',
        EuropeDublin = <any> 'Europe/Dublin',
        EuropeGibraltar = <any> 'Europe/Gibraltar',
        EuropeGuernsey = <any> 'Europe/Guernsey',
        EuropeHelsinki = <any> 'Europe/Helsinki',
        EuropeIsleOfMan = <any> 'Europe/Isle_of_Man',
        EuropeIstanbul = <any> 'Europe/Istanbul',
        EuropeJersey = <any> 'Europe/Jersey',
        EuropeKaliningrad = <any> 'Europe/Kaliningrad',
        EuropeKiev = <any> 'Europe/Kiev',
        EuropeKirov = <any> 'Europe/Kirov',
        EuropeLisbon = <any> 'Europe/Lisbon',
        EuropeLjubljana = <any> 'Europe/Ljubljana',
        EuropeLondon = <any> 'Europe/London',
        EuropeLuxembourg = <any> 'Europe/Luxembourg',
        EuropeMadrid = <any> 'Europe/Madrid',
        EuropeMalta = <any> 'Europe/Malta',
        EuropeMariehamn = <any> 'Europe/Mariehamn',
        EuropeMinsk = <any> 'Europe/Minsk',
        EuropeMonaco = <any> 'Europe/Monaco',
        EuropeMoscow = <any> 'Europe/Moscow',
        EuropeNicosia = <any> 'Europe/Nicosia',
        EuropeOslo = <any> 'Europe/Oslo',
        EuropeParis = <any> 'Europe/Paris',
        EuropePodgorica = <any> 'Europe/Podgorica',
        EuropePrague = <any> 'Europe/Prague',
        EuropeRiga = <any> 'Europe/Riga',
        EuropeRome = <any> 'Europe/Rome',
        EuropeSamara = <any> 'Europe/Samara',
        EuropeSanMarino = <any> 'Europe/San_Marino',
        EuropeSarajevo = <any> 'Europe/Sarajevo',
        EuropeSaratov = <any> 'Europe/Saratov',
        EuropeSimferopol = <any> 'Europe/Simferopol',
        EuropeSkopje = <any> 'Europe/Skopje',
        EuropeSofia = <any> 'Europe/Sofia',
        EuropeStockholm = <any> 'Europe/Stockholm',
        EuropeTallinn = <any> 'Europe/Tallinn',
        EuropeTirane = <any> 'Europe/Tirane',
        EuropeTiraspol = <any> 'Europe/Tiraspol',
        EuropeUlyanovsk = <any> 'Europe/Ulyanovsk',
        EuropeUzhgorod = <any> 'Europe/Uzhgorod',
        EuropeVaduz = <any> 'Europe/Vaduz',
        EuropeVatican = <any> 'Europe/Vatican',
        EuropeVienna = <any> 'Europe/Vienna',
        EuropeVilnius = <any> 'Europe/Vilnius',
        EuropeVolgograd = <any> 'Europe/Volgograd',
        EuropeWarsaw = <any> 'Europe/Warsaw',
        EuropeZagreb = <any> 'Europe/Zagreb',
        EuropeZaporozhye = <any> 'Europe/Zaporozhye',
        EuropeZurich = <any> 'Europe/Zurich',
        GB = <any> 'GB',
        GBEire = <any> 'GB-Eire',
        GMT = <any> 'GMT',
        GMT0 = <any> 'GMT+0',
        GMT0_492 = <any> 'GMT-0',
        GMT0_493 = <any> 'GMT0',
        Greenwich = <any> 'Greenwich',
        HST = <any> 'HST',
        Hongkong = <any> 'Hongkong',
        Iceland = <any> 'Iceland',
        IndianAntananarivo = <any> 'Indian/Antananarivo',
        IndianChagos = <any> 'Indian/Chagos',
        IndianChristmas = <any> 'Indian/Christmas',
        IndianCocos = <any> 'Indian/Cocos',
        IndianComoro = <any> 'Indian/Comoro',
        IndianKerguelen = <any> 'Indian/Kerguelen',
        IndianMahe = <any> 'Indian/Mahe',
        IndianMaldives = <any> 'Indian/Maldives',
        IndianMauritius = <any> 'Indian/Mauritius',
        IndianMayotte = <any> 'Indian/Mayotte',
        IndianReunion = <any> 'Indian/Reunion',
        Iran = <any> 'Iran',
        Israel = <any> 'Israel',
        Jamaica = <any> 'Jamaica',
        Japan = <any> 'Japan',
        Kwajalein = <any> 'Kwajalein',
        Libya = <any> 'Libya',
        MET = <any> 'MET',
        MST = <any> 'MST',
        MST7MDT = <any> 'MST7MDT',
        MexicoBajaNorte = <any> 'Mexico/BajaNorte',
        MexicoBajaSur = <any> 'Mexico/BajaSur',
        MexicoGeneral = <any> 'Mexico/General',
        NZ = <any> 'NZ',
        NZCHAT = <any> 'NZ-CHAT',
        Navajo = <any> 'Navajo',
        PRC = <any> 'PRC',
        PST8PDT = <any> 'PST8PDT',
        PacificApia = <any> 'Pacific/Apia',
        PacificAuckland = <any> 'Pacific/Auckland',
        PacificBougainville = <any> 'Pacific/Bougainville',
        PacificChatham = <any> 'Pacific/Chatham',
        PacificChuuk = <any> 'Pacific/Chuuk',
        PacificEaster = <any> 'Pacific/Easter',
        PacificEfate = <any> 'Pacific/Efate',
        PacificEnderbury = <any> 'Pacific/Enderbury',
        PacificFakaofo = <any> 'Pacific/Fakaofo',
        PacificFiji = <any> 'Pacific/Fiji',
        PacificFunafuti = <any> 'Pacific/Funafuti',
        PacificGalapagos = <any> 'Pacific/Galapagos',
        PacificGambier = <any> 'Pacific/Gambier',
        PacificGuadalcanal = <any> 'Pacific/Guadalcanal',
        PacificGuam = <any> 'Pacific/Guam',
        PacificHonolulu = <any> 'Pacific/Honolulu',
        PacificJohnston = <any> 'Pacific/Johnston',
        PacificKanton = <any> 'Pacific/Kanton',
        PacificKiritimati = <any> 'Pacific/Kiritimati',
        PacificKosrae = <any> 'Pacific/Kosrae',
        PacificKwajalein = <any> 'Pacific/Kwajalein',
        PacificMajuro = <any> 'Pacific/Majuro',
        PacificMarquesas = <any> 'Pacific/Marquesas',
        PacificMidway = <any> 'Pacific/Midway',
        PacificNauru = <any> 'Pacific/Nauru',
        PacificNiue = <any> 'Pacific/Niue',
        PacificNorfolk = <any> 'Pacific/Norfolk',
        PacificNoumea = <any> 'Pacific/Noumea',
        PacificPagoPago = <any> 'Pacific/Pago_Pago',
        PacificPalau = <any> 'Pacific/Palau',
        PacificPitcairn = <any> 'Pacific/Pitcairn',
        PacificPohnpei = <any> 'Pacific/Pohnpei',
        PacificPonape = <any> 'Pacific/Ponape',
        PacificPortMoresby = <any> 'Pacific/Port_Moresby',
        PacificRarotonga = <any> 'Pacific/Rarotonga',
        PacificSaipan = <any> 'Pacific/Saipan',
        PacificSamoa = <any> 'Pacific/Samoa',
        PacificTahiti = <any> 'Pacific/Tahiti',
        PacificTarawa = <any> 'Pacific/Tarawa',
        PacificTongatapu = <any> 'Pacific/Tongatapu',
        PacificTruk = <any> 'Pacific/Truk',
        PacificWake = <any> 'Pacific/Wake',
        PacificWallis = <any> 'Pacific/Wallis',
        PacificYap = <any> 'Pacific/Yap',
        Poland = <any> 'Poland',
        Portugal = <any> 'Portugal',
        ROC = <any> 'ROC',
        ROK = <any> 'ROK',
        Singapore = <any> 'Singapore',
        Turkey = <any> 'Turkey',
        UCT = <any> 'UCT',
        USAlaska = <any> 'US/Alaska',
        USAleutian = <any> 'US/Aleutian',
        USArizona = <any> 'US/Arizona',
        USCentral = <any> 'US/Central',
        USEastIndiana = <any> 'US/East-Indiana',
        USEastern = <any> 'US/Eastern',
        USHawaii = <any> 'US/Hawaii',
        USIndianaStarke = <any> 'US/Indiana-Starke',
        USMichigan = <any> 'US/Michigan',
        USMountain = <any> 'US/Mountain',
        USPacific = <any> 'US/Pacific',
        USSamoa = <any> 'US/Samoa',
        UTC = <any> 'UTC',
        Universal = <any> 'Universal',
        WSU = <any> 'W-SU',
        WET = <any> 'WET',
        Zulu = <any> 'Zulu'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Alert = <any> 'Alert',
        Report = <any> 'Report'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ValidatorTypeEnum {
        NotNull = <any> 'not null',
        Operator = <any> 'operator'
    }
}
/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    id: string;
    /**
     * 
     * @type {any}
     * @memberof Resource
     */
    type: any;
}
/**
 * 
 * @export
 * @interface RlsRule
 */
export interface RlsRule {
    /**
     * 
     * @type {string}
     * @memberof RlsRule
     */
    clause: string;
    /**
     * 
     * @type {number}
     * @memberof RlsRule
     */
    dataset?: number;
}
/**
 * 
 * @export
 * @interface Roles
 */
export interface Roles {
    /**
     * 
     * @type {number}
     * @memberof Roles
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Roles
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Roles1
 */
export interface Roles1 {
    /**
     * 
     * @type {number}
     * @memberof Roles1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Roles1
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface SavedQueryImportBody
 */
export interface SavedQueryImportBody {
    /**
     * upload file (ZIP)
     * @type {Blob}
     * @memberof SavedQueryImportBody
     */
    formData?: Blob;
    /**
     * overwrite existing saved queries?
     * @type {boolean}
     * @memberof SavedQueryImportBody
     */
    overwrite?: boolean;
    /**
     * JSON map of passwords for each featured database in the ZIP file. If the ZIP includes a database config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof SavedQueryImportBody
     */
    passwords?: string;
    /**
     * JSON map of passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the password should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_password\"}`.
     * @type {string}
     * @memberof SavedQueryImportBody
     */
    sshTunnelPasswords?: string;
    /**
     * JSON map of private_key_passwords for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key_password\"}`.
     * @type {string}
     * @memberof SavedQueryImportBody
     */
    sshTunnelPrivateKeyPasswords?: string;
    /**
     * JSON map of private_keys for each ssh_tunnel associated to a featured database in the ZIP file. If the ZIP includes a ssh_tunnel config in the path `databases/MyDatabase.yaml`, the private_key should be provided in the following format: `{\"databases/MyDatabase.yaml\": \"my_private_key\"}`.
     * @type {string}
     * @memberof SavedQueryImportBody
     */
    sshTunnelPrivateKeys?: string;
}
/**
 * 
 * @export
 * @interface SavedQueryRestApiGet
 */
export interface SavedQueryRestApiGet {
    /**
     * 
     * @type {any}
     * @memberof SavedQueryRestApiGet
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {SavedQueryRestApiGetUser}
     * @memberof SavedQueryRestApiGet
     */
    createdBy?: SavedQueryRestApiGetUser;
    /**
     * 
     * @type {SavedQueryRestApiGetDatabase}
     * @memberof SavedQueryRestApiGet
     */
    database?: SavedQueryRestApiGetDatabase;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGet
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof SavedQueryRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGet
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGet
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGet
     */
    sql?: string;
    /**
     * 
     * @type {any}
     * @memberof SavedQueryRestApiGet
     */
    sqlTables?: any;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGet
     */
    templateParameters?: string;
}
/**
 * 
 * @export
 * @interface SavedQueryRestApiGetDatabase
 */
export interface SavedQueryRestApiGetDatabase {
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGetDatabase
     */
    databaseName: string;
    /**
     * 
     * @type {number}
     * @memberof SavedQueryRestApiGetDatabase
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface SavedQueryRestApiGetList
 */
export interface SavedQueryRestApiGetList {
    /**
     * 
     * @type {any}
     * @memberof SavedQueryRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {SavedQueryRestApiGetListUser}
     * @memberof SavedQueryRestApiGetList
     */
    createdBy?: SavedQueryRestApiGetListUser;
    /**
     * 
     * @type {Date}
     * @memberof SavedQueryRestApiGetList
     */
    createdOn?: Date;
    /**
     * 
     * @type {SavedQueryRestApiGetListDatabase}
     * @memberof SavedQueryRestApiGetList
     */
    database?: SavedQueryRestApiGetListDatabase;
    /**
     * 
     * @type {number}
     * @memberof SavedQueryRestApiGetList
     */
    dbId?: number;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGetList
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof SavedQueryRestApiGetList
     */
    extra?: any;
    /**
     * 
     * @type {number}
     * @memberof SavedQueryRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGetList
     */
    label?: string;
    /**
     * 
     * @type {any}
     * @memberof SavedQueryRestApiGetList
     */
    lastRunDeltaHumanized?: any;
    /**
     * 
     * @type {number}
     * @memberof SavedQueryRestApiGetList
     */
    rows?: number;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGetList
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGetList
     */
    sql?: string;
    /**
     * 
     * @type {any}
     * @memberof SavedQueryRestApiGetList
     */
    sqlTables?: any;
}
/**
 * 
 * @export
 * @interface SavedQueryRestApiGetListDatabase
 */
export interface SavedQueryRestApiGetListDatabase {
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGetListDatabase
     */
    databaseName: string;
    /**
     * 
     * @type {number}
     * @memberof SavedQueryRestApiGetListDatabase
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface SavedQueryRestApiGetListUser
 */
export interface SavedQueryRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGetListUser
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof SavedQueryRestApiGetListUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGetListUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface SavedQueryRestApiGetUser
 */
export interface SavedQueryRestApiGetUser {
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGetUser
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof SavedQueryRestApiGetUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiGetUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface SavedQueryRestApiPost
 */
export interface SavedQueryRestApiPost {
    /**
     * 
     * @type {number}
     * @memberof SavedQueryRestApiPost
     */
    dbId?: number;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiPost
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiPost
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiPost
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiPost
     */
    sql?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiPost
     */
    templateParameters?: string;
}
/**
 * 
 * @export
 * @interface SavedQueryRestApiPut
 */
export interface SavedQueryRestApiPut {
    /**
     * 
     * @type {number}
     * @memberof SavedQueryRestApiPut
     */
    dbId?: number;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiPut
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiPut
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiPut
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiPut
     */
    sql?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedQueryRestApiPut
     */
    templateParameters?: string;
}
/**
 * 
 * @export
 * @interface SchemasResponseSchema
 */
export interface SchemasResponseSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof SchemasResponseSchema
     */
    result?: Array<string>;
}
/**
 * 
 * @export
 * @interface ScreenshotQuerySchema
 */
export interface ScreenshotQuerySchema {
    /**
     * 
     * @type {boolean}
     * @memberof ScreenshotQuerySchema
     */
    force?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScreenshotQuerySchema
     */
    thumbSize?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScreenshotQuerySchema
     */
    windowSize?: Array<number>;
}
/**
 * 
 * @export
 * @interface SecurityLoginBody
 */
export interface SecurityLoginBody {
    /**
     * The password for authentication
     * @type {string}
     * @memberof SecurityLoginBody
     */
    password?: string;
    /**
     * Choose an authentication provider
     * @type {string}
     * @memberof SecurityLoginBody
     */
    provider?: SecurityLoginBody.ProviderEnum;
    /**
     * If true a refresh token is provided also
     * @type {boolean}
     * @memberof SecurityLoginBody
     */
    refresh?: boolean;
    /**
     * The username for authentication
     * @type {string}
     * @memberof SecurityLoginBody
     */
    username?: string;
}

/**
 * @export
 * @namespace SecurityLoginBody
 */
export namespace SecurityLoginBody {
    /**
     * @export
     * @enum {string}
     */
    export enum ProviderEnum {
        Db = <any> 'db',
        Ldap = <any> 'ldap'
    }
}
/**
 * 
 * @export
 * @interface SelectStarResponseSchema
 */
export interface SelectStarResponseSchema {
    /**
     * SQL select star
     * @type {string}
     * @memberof SelectStarResponseSchema
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface Slice
 */
export interface Slice {
    /**
     * Duration (in seconds) of the caching timeout for this chart.
     * @type {number}
     * @memberof Slice
     */
    cacheTimeout?: number;
    /**
     * Details of the certification.
     * @type {string}
     * @memberof Slice
     */
    certificationDetails?: string;
    /**
     * Person or group that has certified this dashboard.
     * @type {string}
     * @memberof Slice
     */
    certifiedBy?: string;
    /**
     * Timestamp of the last modification.
     * @type {string}
     * @memberof Slice
     */
    changedOn?: string;
    /**
     * Timestamp of the last modification in human readable form.
     * @type {string}
     * @memberof Slice
     */
    changedOnHumanized?: string;
    /**
     * Datasource identifier.
     * @type {string}
     * @memberof Slice
     */
    datasource?: string;
    /**
     * Slice description.
     * @type {string}
     * @memberof Slice
     */
    description?: string;
    /**
     * Sanitized HTML version of the chart description.
     * @type {string}
     * @memberof Slice
     */
    descriptionMarkeddown?: string;
    /**
     * The URL for editing the slice.
     * @type {string}
     * @memberof Slice
     */
    editUrl?: string;
    /**
     * Form data associated with the slice.
     * @type {any}
     * @memberof Slice
     */
    formData?: any;
    /**
     * If the chart is managed outside externally.
     * @type {boolean}
     * @memberof Slice
     */
    isManagedExternally?: boolean;
    /**
     * Last modification in human readable form.
     * @type {string}
     * @memberof Slice
     */
    modified?: string;
    /**
     * Owners identifiers.
     * @type {Array<number>}
     * @memberof Slice
     */
    owners?: Array<number>;
    /**
     * The context associated with the query.
     * @type {any}
     * @memberof Slice
     */
    queryContext?: any;
    /**
     * The slice ID.
     * @type {number}
     * @memberof Slice
     */
    sliceId?: number;
    /**
     * The slice name.
     * @type {string}
     * @memberof Slice
     */
    sliceName?: string;
    /**
     * The slice URL.
     * @type {string}
     * @memberof Slice
     */
    sliceUrl?: string;
}
/**
 * 
 * @export
 * @interface SqlLabGetResultsSchema
 */
export interface SqlLabGetResultsSchema {
    /**
     * 
     * @type {string}
     * @memberof SqlLabGetResultsSchema
     */
    key: string;
}
/**
 * 
 * @export
 * @interface StopQuerySchema
 */
export interface StopQuerySchema {
    /**
     * 
     * @type {string}
     * @memberof StopQuerySchema
     */
    clientId?: string;
}
/**
 * 
 * @export
 * @interface TableExtraMetadataResponseSchema
 */
export interface TableExtraMetadataResponseSchema {
    /**
     * 
     * @type {any}
     * @memberof TableExtraMetadataResponseSchema
     */
    clustering?: any;
    /**
     * 
     * @type {any}
     * @memberof TableExtraMetadataResponseSchema
     */
    metadata?: any;
    /**
     * 
     * @type {any}
     * @memberof TableExtraMetadataResponseSchema
     */
    partitions?: any;
}
/**
 * 
 * @export
 * @interface TableMetadataColumnsResponse
 */
export interface TableMetadataColumnsResponse {
    /**
     * 
     * @type {string}
     * @memberof TableMetadataColumnsResponse
     */
    duplicatesConstraint?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TableMetadataColumnsResponse
     */
    keys?: Array<string>;
    /**
     * The actual backend long type for the column
     * @type {string}
     * @memberof TableMetadataColumnsResponse
     */
    longType?: string;
    /**
     * The column name
     * @type {string}
     * @memberof TableMetadataColumnsResponse
     */
    name?: string;
    /**
     * The column type
     * @type {string}
     * @memberof TableMetadataColumnsResponse
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface TableMetadataForeignKeysIndexesResponse
 */
export interface TableMetadataForeignKeysIndexesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof TableMetadataForeignKeysIndexesResponse
     */
    columnNames?: Array<string>;
    /**
     * The name of the foreign key or index
     * @type {string}
     * @memberof TableMetadataForeignKeysIndexesResponse
     */
    name?: string;
    /**
     * 
     * @type {TableMetadataOptionsResponse}
     * @memberof TableMetadataForeignKeysIndexesResponse
     */
    options?: TableMetadataOptionsResponse;
    /**
     * 
     * @type {Array<string>}
     * @memberof TableMetadataForeignKeysIndexesResponse
     */
    referredColumns?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TableMetadataForeignKeysIndexesResponse
     */
    referredSchema?: string;
    /**
     * 
     * @type {string}
     * @memberof TableMetadataForeignKeysIndexesResponse
     */
    referredTable?: string;
    /**
     * 
     * @type {string}
     * @memberof TableMetadataForeignKeysIndexesResponse
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface TableMetadataOptionsResponse
 */
export interface TableMetadataOptionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TableMetadataOptionsResponse
     */
    deferrable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TableMetadataOptionsResponse
     */
    initially?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TableMetadataOptionsResponse
     */
    match?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TableMetadataOptionsResponse
     */
    ondelete?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TableMetadataOptionsResponse
     */
    onupdate?: boolean;
}
/**
 * 
 * @export
 * @interface TableMetadataPrimaryKeyResponse
 */
export interface TableMetadataPrimaryKeyResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof TableMetadataPrimaryKeyResponse
     */
    columnNames?: Array<string>;
    /**
     * The primary key index name
     * @type {string}
     * @memberof TableMetadataPrimaryKeyResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TableMetadataPrimaryKeyResponse
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface TableMetadataResponseSchema
 */
export interface TableMetadataResponseSchema {
    /**
     * A list of columns and their metadata
     * @type {Array<TableMetadataColumnsResponse>}
     * @memberof TableMetadataResponseSchema
     */
    columns?: Array<TableMetadataColumnsResponse>;
    /**
     * A list of foreign keys and their metadata
     * @type {Array<TableMetadataForeignKeysIndexesResponse>}
     * @memberof TableMetadataResponseSchema
     */
    foreignKeys?: Array<TableMetadataForeignKeysIndexesResponse>;
    /**
     * A list of indexes and their metadata
     * @type {Array<TableMetadataForeignKeysIndexesResponse>}
     * @memberof TableMetadataResponseSchema
     */
    indexes?: Array<TableMetadataForeignKeysIndexesResponse>;
    /**
     * The name of the table
     * @type {string}
     * @memberof TableMetadataResponseSchema
     */
    name?: string;
    /**
     * Primary keys metadata
     * @type {TableMetadataPrimaryKeyResponse}
     * @memberof TableMetadataResponseSchema
     */
    primaryKey?: TableMetadataPrimaryKeyResponse;
    /**
     * SQL select star
     * @type {string}
     * @memberof TableMetadataResponseSchema
     */
    selectStar?: string;
}
/**
 * 
 * @export
 * @interface Tables
 */
export interface Tables {
    /**
     * 
     * @type {number}
     * @memberof Tables
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Tables
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof Tables
     */
    tableName?: string;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof Tag
     */
    type?: any;
}
/**
 * 
 * @export
 * @interface Tag1
 */
export interface Tag1 {
    /**
     * 
     * @type {number}
     * @memberof Tag1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag1
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof Tag1
     */
    type?: any;
}
/**
 * 
 * @export
 * @interface TagGetResponseSchema
 */
export interface TagGetResponseSchema {
    /**
     * 
     * @type {number}
     * @memberof TagGetResponseSchema
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TagGetResponseSchema
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGetResponseSchema
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface TagRestApiGet
 */
export interface TagRestApiGet {
    /**
     * 
     * @type {TagRestApiGetUser}
     * @memberof TagRestApiGet
     */
    changedBy?: TagRestApiGetUser;
    /**
     * 
     * @type {any}
     * @memberof TagRestApiGet
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {TagRestApiGetUser1}
     * @memberof TagRestApiGet
     */
    createdBy?: TagRestApiGetUser1;
    /**
     * 
     * @type {number}
     * @memberof TagRestApiGet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGet
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof TagRestApiGet
     */
    type?: any;
}
/**
 * 
 * @export
 * @interface TagRestApiGetList
 */
export interface TagRestApiGetList {
    /**
     * 
     * @type {TagRestApiGetListUser}
     * @memberof TagRestApiGetList
     */
    changedBy?: TagRestApiGetListUser;
    /**
     * 
     * @type {any}
     * @memberof TagRestApiGetList
     */
    changedOnDeltaHumanized?: any;
    /**
     * 
     * @type {TagRestApiGetListUser1}
     * @memberof TagRestApiGetList
     */
    createdBy?: TagRestApiGetListUser1;
    /**
     * 
     * @type {number}
     * @memberof TagRestApiGetList
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetList
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof TagRestApiGetList
     */
    type?: any;
}
/**
 * 
 * @export
 * @interface TagRestApiGetListUser
 */
export interface TagRestApiGetListUser {
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetListUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetListUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface TagRestApiGetListUser1
 */
export interface TagRestApiGetListUser1 {
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetListUser1
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetListUser1
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface TagRestApiGetUser
 */
export interface TagRestApiGetUser {
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetUser
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface TagRestApiGetUser1
 */
export interface TagRestApiGetUser1 {
    /**
     * 
     * @type {boolean}
     * @memberof TagRestApiGetUser1
     */
    active?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof TagRestApiGetUser1
     */
    changedOn?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TagRestApiGetUser1
     */
    createdOn?: Date;
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetUser1
     */
    email: string;
    /**
     * 
     * @type {number}
     * @memberof TagRestApiGetUser1
     */
    failLoginCount?: number;
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetUser1
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof TagRestApiGetUser1
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof TagRestApiGetUser1
     */
    lastLogin?: Date;
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetUser1
     */
    lastName: string;
    /**
     * 
     * @type {number}
     * @memberof TagRestApiGetUser1
     */
    loginCount?: number;
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetUser1
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof TagRestApiGetUser1
     */
    username: string;
}
/**
 * 
 * @export
 * @interface TagRestApiPost
 */
export interface TagRestApiPost {
    /**
     * 
     * @type {Array<string>}
     * @memberof TagRestApiPost
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface TagRestApiPut
 */
export interface TagRestApiPut {
    /**
     * 
     * @type {number}
     * @memberof TagRestApiPut
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface TaggedObjectEntityResponseSchema
 */
export interface TaggedObjectEntityResponseSchema {
    /**
     * 
     * @type {Date}
     * @memberof TaggedObjectEntityResponseSchema
     */
    changedOn?: Date;
    /**
     * 
     * @type {User}
     * @memberof TaggedObjectEntityResponseSchema
     */
    createdBy?: User;
    /**
     * 
     * @type {string}
     * @memberof TaggedObjectEntityResponseSchema
     */
    creator?: string;
    /**
     * 
     * @type {number}
     * @memberof TaggedObjectEntityResponseSchema
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TaggedObjectEntityResponseSchema
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TaggedObjectEntityResponseSchema
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof TaggedObjectEntityResponseSchema
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface TemporaryCachePostSchema
 */
export interface TemporaryCachePostSchema {
    /**
     * Any type of JSON supported text.
     * @type {string}
     * @memberof TemporaryCachePostSchema
     */
    value: string;
}
/**
 * 
 * @export
 * @interface TemporaryCachePutSchema
 */
export interface TemporaryCachePutSchema {
    /**
     * Any type of JSON supported text.
     * @type {string}
     * @memberof TemporaryCachePutSchema
     */
    value: string;
}
/**
 * 
 * @export
 * @interface ThumbnailQuerySchema
 */
export interface ThumbnailQuerySchema {
    /**
     * 
     * @type {boolean}
     * @memberof ThumbnailQuerySchema
     */
    force?: boolean;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
}
/**
 * 
 * @export
 * @interface User1
 */
export interface User1 {
    /**
     * 
     * @type {string}
     * @memberof User1
     */
    firstName?: string;
    /**
     * 
     * @type {number}
     * @memberof User1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User1
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User1
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface User2
 */
export interface User2 {
    /**
     * 
     * @type {string}
     * @memberof User2
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User2
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User2
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface UserResponseSchema
 */
export interface UserResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof UserResponseSchema
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseSchema
     */
    firstName?: string;
    /**
     * 
     * @type {number}
     * @memberof UserResponseSchema
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseSchema
     */
    isActive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseSchema
     */
    isAnonymous?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponseSchema
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseSchema
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface ValidateSQLRequest
 */
export interface ValidateSQLRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidateSQLRequest
     */
    schema?: string;
    /**
     * SQL statement to validate
     * @type {string}
     * @memberof ValidateSQLRequest
     */
    sql: string;
    /**
     * 
     * @type {any}
     * @memberof ValidateSQLRequest
     */
    templateParams?: any;
}
/**
 * 
 * @export
 * @interface ValidateSQLResponse
 */
export interface ValidateSQLResponse {
    /**
     * 
     * @type {number}
     * @memberof ValidateSQLResponse
     */
    endColumn?: number;
    /**
     * 
     * @type {number}
     * @memberof ValidateSQLResponse
     */
    lineNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof ValidateSQLResponse
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ValidateSQLResponse
     */
    startColumn?: number;
}
/**
 * 
 * @export
 * @interface ValidatorConfigJSON
 */
export interface ValidatorConfigJSON {
    /**
     * The operation to compare with a threshold to apply to the SQL output 
     * @type {string}
     * @memberof ValidatorConfigJSON
     */
    op?: ValidatorConfigJSON.OpEnum;
    /**
     * 
     * @type {number}
     * @memberof ValidatorConfigJSON
     */
    threshold?: number;
}

/**
 * @export
 * @namespace ValidatorConfigJSON
 */
export namespace ValidatorConfigJSON {
    /**
     * @export
     * @enum {string}
     */
    export enum OpEnum {
        LessThan = <any> '<',
        LessThanOrEqualTo = <any> '<=',
        GreaterThan = <any> '>',
        GreaterThanOrEqualTo = <any> '>=',
        Equal = <any> '==',
        NotEqual = <any> '!='
    }
}
/**
 * AdvancedDataTypeApi - fetch parameter creator
 * @export
 */
export const AdvancedDataTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a AdvancedDataTypeResponse object populated with the passed in args.
         * @param {AdvancedDataTypeConvertSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdvancedDataTypeConvertGet(q?: AdvancedDataTypeConvertSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/advanced_data_type/convert`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of available advanced data types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdvancedDataTypeTypesGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/advanced_data_type/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdvancedDataTypeApi - functional programming interface
 * @export
 */
export const AdvancedDataTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a AdvancedDataTypeResponse object populated with the passed in args.
         * @param {AdvancedDataTypeConvertSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdvancedDataTypeConvertGet(q?: AdvancedDataTypeConvertSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdvancedDataTypeSchema> {
            const localVarFetchArgs = AdvancedDataTypeApiFetchParamCreator(configuration).apiV1AdvancedDataTypeConvertGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of available advanced data types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdvancedDataTypeTypesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = AdvancedDataTypeApiFetchParamCreator(configuration).apiV1AdvancedDataTypeTypesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdvancedDataTypeApi - factory interface
 * @export
 */
export const AdvancedDataTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns a AdvancedDataTypeResponse object populated with the passed in args.
         * @param {AdvancedDataTypeConvertSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdvancedDataTypeConvertGet(q?: AdvancedDataTypeConvertSchema, options?: any) {
            return AdvancedDataTypeApiFp(configuration).apiV1AdvancedDataTypeConvertGet(q, options)(fetch, basePath);
        },
        /**
         * Returns a list of available advanced data types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdvancedDataTypeTypesGet(options?: any) {
            return AdvancedDataTypeApiFp(configuration).apiV1AdvancedDataTypeTypesGet(options)(fetch, basePath);
        },
    };
};

/**
 * AdvancedDataTypeApi - object-oriented interface
 * @export
 * @class AdvancedDataTypeApi
 * @extends {BaseAPI}
 */
export class AdvancedDataTypeApi extends BaseAPI {
    /**
     * 
     * @summary Returns a AdvancedDataTypeResponse object populated with the passed in args.
     * @param {AdvancedDataTypeConvertSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvancedDataTypeApi
     */
    public apiV1AdvancedDataTypeConvertGet(q?: AdvancedDataTypeConvertSchema, options?: any) {
        return AdvancedDataTypeApiFp(this.configuration).apiV1AdvancedDataTypeConvertGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of available advanced data types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvancedDataTypeApi
     */
    public apiV1AdvancedDataTypeTypesGet(options?: any) {
        return AdvancedDataTypeApiFp(this.configuration).apiV1AdvancedDataTypeTypesGet(options)(this.fetch, this.basePath);
    }

}
/**
 * AnnotationLayersApi - fetch parameter creator
 * @export
 */
export const AnnotationLayersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes multiple annotation layers in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerDelete(q?: GetDeleteIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/annotation_layer/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Annotation layers, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/annotation_layer/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerInfoGet(q?: GetInfoSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/annotation_layer/_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Annotation layer
         * @param {number} pk The annotation layer pk for this annotation
         * @param {number} annotationId The annotation pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationAnnotationIdDelete(pk: number, annotationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1AnnotationLayerPkAnnotationAnnotationIdDelete.');
            }
            // verify required parameter 'annotationId' is not null or undefined
            if (annotationId === null || annotationId === undefined) {
                throw new RequiredError('annotationId','Required parameter annotationId was null or undefined when calling apiV1AnnotationLayerPkAnnotationAnnotationIdDelete.');
            }
            const localVarPath = `/api/v1/annotation_layer/{pk}/annotation/{annotation_id}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Annotation layer
         * @param {number} pk The annotation layer pk for this annotation
         * @param {number} annotationId The annotation pk
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationAnnotationIdGet(pk: number, annotationId: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1AnnotationLayerPkAnnotationAnnotationIdGet.');
            }
            // verify required parameter 'annotationId' is not null or undefined
            if (annotationId === null || annotationId === undefined) {
                throw new RequiredError('annotationId','Required parameter annotationId was null or undefined when calling apiV1AnnotationLayerPkAnnotationAnnotationIdGet.');
            }
            const localVarPath = `/api/v1/annotation_layer/{pk}/annotation/{annotation_id}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Annotation layer
         * @param {AnnotationRestApiPut} body Annotation schema
         * @param {number} pk The annotation layer pk for this annotation
         * @param {number} annotationId The annotation pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationAnnotationIdPut(body: AnnotationRestApiPut, pk: number, annotationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1AnnotationLayerPkAnnotationAnnotationIdPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1AnnotationLayerPkAnnotationAnnotationIdPut.');
            }
            // verify required parameter 'annotationId' is not null or undefined
            if (annotationId === null || annotationId === undefined) {
                throw new RequiredError('annotationId','Required parameter annotationId was null or undefined when calling apiV1AnnotationLayerPkAnnotationAnnotationIdPut.');
            }
            const localVarPath = `/api/v1/annotation_layer/{pk}/annotation/{annotation_id}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AnnotationRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes multiple annotation in a bulk operation.
         * @param {number} pk The annotation layer pk for this annotation
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationDelete(pk: number, q?: GetDeleteIdsSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1AnnotationLayerPkAnnotationDelete.');
            }
            const localVarPath = `/api/v1/annotation_layer/{pk}/annotation/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Annotation layers, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {number} pk The annotation layer id for this annotation
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationGet(pk: number, q?: GetListSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1AnnotationLayerPkAnnotationGet.');
            }
            const localVarPath = `/api/v1/annotation_layer/{pk}/annotation/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Annotation layer
         * @param {AnnotationRestApiPost} body Annotation schema
         * @param {number} pk The annotation layer pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationPost(body: AnnotationRestApiPost, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1AnnotationLayerPkAnnotationPost.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1AnnotationLayerPkAnnotationPost.');
            }
            const localVarPath = `/api/v1/annotation_layer/{pk}/annotation/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AnnotationRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Annotation layer
         * @param {number} pk The annotation layer pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1AnnotationLayerPkDelete.');
            }
            const localVarPath = `/api/v1/annotation_layer/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Annotation layer
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkGet(pk: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1AnnotationLayerPkGet.');
            }
            const localVarPath = `/api/v1/annotation_layer/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Annotation layer
         * @param {AnnotationLayerRestApiPut} body Annotation schema
         * @param {number} pk The annotation layer pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkPut(body: AnnotationLayerRestApiPut, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1AnnotationLayerPkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1AnnotationLayerPkPut.');
            }
            const localVarPath = `/api/v1/annotation_layer/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AnnotationLayerRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Annotation layer
         * @param {AnnotationLayerRestApiPost} body Annotation Layer schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPost(body: AnnotationLayerRestApiPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1AnnotationLayerPost.');
            }
            const localVarPath = `/api/v1/annotation_layer/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AnnotationLayerRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1AnnotationLayerRelatedColumnNameGet.');
            }
            const localVarPath = `/api/v1/annotation_layer/related/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationLayersApi - functional programming interface
 * @export
 */
export const AnnotationLayersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes multiple annotation layers in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerDelete(q?: GetDeleteIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerDelete(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of Annotation layers, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerInfoGet(q?: GetInfoSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerInfoGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete Annotation layer
         * @param {number} pk The annotation layer pk for this annotation
         * @param {number} annotationId The annotation pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationAnnotationIdDelete(pk: number, annotationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerPkAnnotationAnnotationIdDelete(pk, annotationId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an Annotation layer
         * @param {number} pk The annotation layer pk for this annotation
         * @param {number} annotationId The annotation pk
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationAnnotationIdGet(pk: number, annotationId: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerPkAnnotationAnnotationIdGet(pk, annotationId, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an Annotation layer
         * @param {AnnotationRestApiPut} body Annotation schema
         * @param {number} pk The annotation layer pk for this annotation
         * @param {number} annotationId The annotation pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationAnnotationIdPut(body: AnnotationRestApiPut, pk: number, annotationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerPkAnnotationAnnotationIdPut(body, pk, annotationId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes multiple annotation in a bulk operation.
         * @param {number} pk The annotation layer pk for this annotation
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationDelete(pk: number, q?: GetDeleteIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerPkAnnotationDelete(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of Annotation layers, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {number} pk The annotation layer id for this annotation
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationGet(pk: number, q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerPkAnnotationGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create an Annotation layer
         * @param {AnnotationRestApiPost} body Annotation schema
         * @param {number} pk The annotation layer pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationPost(body: AnnotationRestApiPost, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2011> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerPkAnnotationPost(body, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete Annotation layer
         * @param {number} pk The annotation layer pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerPkDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an Annotation layer
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkGet(pk: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerPkGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an Annotation layer
         * @param {AnnotationLayerRestApiPut} body Annotation schema
         * @param {number} pk The annotation layer pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkPut(body: AnnotationLayerRestApiPut, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerPkPut(body, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create an Annotation layer
         * @param {AnnotationLayerRestApiPost} body Annotation Layer schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPost(body: AnnotationLayerRestApiPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RelatedResponseSchema> {
            const localVarFetchArgs = AnnotationLayersApiFetchParamCreator(configuration).apiV1AnnotationLayerRelatedColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AnnotationLayersApi - factory interface
 * @export
 */
export const AnnotationLayersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes multiple annotation layers in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerDelete(q?: GetDeleteIdsSchema, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerDelete(q, options)(fetch, basePath);
        },
        /**
         * Get a list of Annotation layers, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerGet(q?: GetListSchema, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerGet(q, options)(fetch, basePath);
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerInfoGet(q?: GetInfoSchema, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerInfoGet(q, options)(fetch, basePath);
        },
        /**
         * Delete Annotation layer
         * @param {number} pk The annotation layer pk for this annotation
         * @param {number} annotationId The annotation pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationAnnotationIdDelete(pk: number, annotationId: number, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerPkAnnotationAnnotationIdDelete(pk, annotationId, options)(fetch, basePath);
        },
        /**
         * Get an Annotation layer
         * @param {number} pk The annotation layer pk for this annotation
         * @param {number} annotationId The annotation pk
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationAnnotationIdGet(pk: number, annotationId: number, q?: GetItemSchema, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerPkAnnotationAnnotationIdGet(pk, annotationId, q, options)(fetch, basePath);
        },
        /**
         * Update an Annotation layer
         * @param {AnnotationRestApiPut} body Annotation schema
         * @param {number} pk The annotation layer pk for this annotation
         * @param {number} annotationId The annotation pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationAnnotationIdPut(body: AnnotationRestApiPut, pk: number, annotationId: number, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerPkAnnotationAnnotationIdPut(body, pk, annotationId, options)(fetch, basePath);
        },
        /**
         * Deletes multiple annotation in a bulk operation.
         * @param {number} pk The annotation layer pk for this annotation
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationDelete(pk: number, q?: GetDeleteIdsSchema, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerPkAnnotationDelete(pk, q, options)(fetch, basePath);
        },
        /**
         * Get a list of Annotation layers, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {number} pk The annotation layer id for this annotation
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationGet(pk: number, q?: GetListSchema, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerPkAnnotationGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Create an Annotation layer
         * @param {AnnotationRestApiPost} body Annotation schema
         * @param {number} pk The annotation layer pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkAnnotationPost(body: AnnotationRestApiPost, pk: number, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerPkAnnotationPost(body, pk, options)(fetch, basePath);
        },
        /**
         * Delete Annotation layer
         * @param {number} pk The annotation layer pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkDelete(pk: number, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerPkDelete(pk, options)(fetch, basePath);
        },
        /**
         * Get an Annotation layer
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkGet(pk: number, q?: GetItemSchema, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerPkGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Update an Annotation layer
         * @param {AnnotationLayerRestApiPut} body Annotation schema
         * @param {number} pk The annotation layer pk for this annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPkPut(body: AnnotationLayerRestApiPut, pk: number, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerPkPut(body, pk, options)(fetch, basePath);
        },
        /**
         * Create an Annotation layer
         * @param {AnnotationLayerRestApiPost} body Annotation Layer schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerPost(body: AnnotationLayerRestApiPost, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AnnotationLayerRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return AnnotationLayersApiFp(configuration).apiV1AnnotationLayerRelatedColumnNameGet(columnName, q, options)(fetch, basePath);
        },
    };
};

/**
 * AnnotationLayersApi - object-oriented interface
 * @export
 * @class AnnotationLayersApi
 * @extends {BaseAPI}
 */
export class AnnotationLayersApi extends BaseAPI {
    /**
     * Deletes multiple annotation layers in a bulk operation.
     * @param {GetDeleteIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerDelete(q?: GetDeleteIdsSchema, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerDelete(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of Annotation layers, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerGet(q?: GetListSchema, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get metadata information about this API resource
     * @param {GetInfoSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerInfoGet(q?: GetInfoSchema, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerInfoGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Delete Annotation layer
     * @param {number} pk The annotation layer pk for this annotation
     * @param {number} annotationId The annotation pk for this annotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerPkAnnotationAnnotationIdDelete(pk: number, annotationId: number, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerPkAnnotationAnnotationIdDelete(pk, annotationId, options)(this.fetch, this.basePath);
    }

    /**
     * Get an Annotation layer
     * @param {number} pk The annotation layer pk for this annotation
     * @param {number} annotationId The annotation pk
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerPkAnnotationAnnotationIdGet(pk: number, annotationId: number, q?: GetItemSchema, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerPkAnnotationAnnotationIdGet(pk, annotationId, q, options)(this.fetch, this.basePath);
    }

    /**
     * Update an Annotation layer
     * @param {AnnotationRestApiPut} body Annotation schema
     * @param {number} pk The annotation layer pk for this annotation
     * @param {number} annotationId The annotation pk for this annotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerPkAnnotationAnnotationIdPut(body: AnnotationRestApiPut, pk: number, annotationId: number, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerPkAnnotationAnnotationIdPut(body, pk, annotationId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes multiple annotation in a bulk operation.
     * @param {number} pk The annotation layer pk for this annotation
     * @param {GetDeleteIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerPkAnnotationDelete(pk: number, q?: GetDeleteIdsSchema, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerPkAnnotationDelete(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of Annotation layers, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
     * @param {number} pk The annotation layer id for this annotation
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerPkAnnotationGet(pk: number, q?: GetListSchema, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerPkAnnotationGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Create an Annotation layer
     * @param {AnnotationRestApiPost} body Annotation schema
     * @param {number} pk The annotation layer pk for this annotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerPkAnnotationPost(body: AnnotationRestApiPost, pk: number, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerPkAnnotationPost(body, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Delete Annotation layer
     * @param {number} pk The annotation layer pk for this annotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerPkDelete(pk: number, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerPkDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get an Annotation layer
     * @param {number} pk 
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerPkGet(pk: number, q?: GetItemSchema, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerPkGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Update an Annotation layer
     * @param {AnnotationLayerRestApiPut} body Annotation schema
     * @param {number} pk The annotation layer pk for this annotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerPkPut(body: AnnotationLayerRestApiPut, pk: number, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerPkPut(body, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Create an Annotation layer
     * @param {AnnotationLayerRestApiPost} body Annotation Layer schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerPost(body: AnnotationLayerRestApiPost, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationLayersApi
     */
    public apiV1AnnotationLayerRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return AnnotationLayersApiFp(this.configuration).apiV1AnnotationLayerRelatedColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

}
/**
 * AsyncEventsRestApiApi - fetch parameter creator
 * @export
 */
export const AsyncEventsRestApiApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Reads off of the Redis events stream, using the user's JWT token and optional query params for last event received.
         * @param {string} [lastId] Last ID received by the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AsyncEventGet(lastId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/async_event/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (lastId !== undefined) {
                localVarQueryParameter['last_id'] = lastId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AsyncEventsRestApiApi - functional programming interface
 * @export
 */
export const AsyncEventsRestApiApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Reads off of the Redis events stream, using the user's JWT token and optional query params for last event received.
         * @param {string} [lastId] Last ID received by the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AsyncEventGet(lastId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = AsyncEventsRestApiApiFetchParamCreator(configuration).apiV1AsyncEventGet(lastId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AsyncEventsRestApiApi - factory interface
 * @export
 */
export const AsyncEventsRestApiApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Reads off of the Redis events stream, using the user's JWT token and optional query params for last event received.
         * @param {string} [lastId] Last ID received by the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AsyncEventGet(lastId?: string, options?: any) {
            return AsyncEventsRestApiApiFp(configuration).apiV1AsyncEventGet(lastId, options)(fetch, basePath);
        },
    };
};

/**
 * AsyncEventsRestApiApi - object-oriented interface
 * @export
 * @class AsyncEventsRestApiApi
 * @extends {BaseAPI}
 */
export class AsyncEventsRestApiApi extends BaseAPI {
    /**
     * Reads off of the Redis events stream, using the user's JWT token and optional query params for last event received.
     * @param {string} [lastId] Last ID received by the client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AsyncEventsRestApiApi
     */
    public apiV1AsyncEventGet(lastId?: string, options?: any) {
        return AsyncEventsRestApiApiFp(this.configuration).apiV1AsyncEventGet(lastId, options)(this.fetch, this.basePath);
    }

}
/**
 * AvailableDomainsApi - fetch parameter creator
 * @export
 */
export const AvailableDomainsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all available domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AvailableDomainsGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/available_domains/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvailableDomainsApi - functional programming interface
 * @export
 */
export const AvailableDomainsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all available domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AvailableDomainsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = AvailableDomainsApiFetchParamCreator(configuration).apiV1AvailableDomainsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AvailableDomainsApi - factory interface
 * @export
 */
export const AvailableDomainsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all available domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AvailableDomainsGet(options?: any) {
            return AvailableDomainsApiFp(configuration).apiV1AvailableDomainsGet(options)(fetch, basePath);
        },
    };
};

/**
 * AvailableDomainsApi - object-oriented interface
 * @export
 * @class AvailableDomainsApi
 * @extends {BaseAPI}
 */
export class AvailableDomainsApi extends BaseAPI {
    /**
     * Get all available domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableDomainsApi
     */
    public apiV1AvailableDomainsGet(options?: any) {
        return AvailableDomainsApiFp(this.configuration).apiV1AvailableDomainsGet(options)(this.fetch, this.basePath);
    }

}
/**
 * CSSTemplatesApi - fetch parameter creator
 * @export
 */
export const CSSTemplatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes multiple css templates in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateDelete(q?: GetDeleteIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/css_template/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of CSS templates, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/css_template/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateInfoGet(q?: GetInfoSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/css_template/_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete CSS template
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePkDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1CssTemplatePkDelete.');
            }
            const localVarPath = `/api/v1/css_template/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a CSS template
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePkGet(pk: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1CssTemplatePkGet.');
            }
            const localVarPath = `/api/v1/css_template/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a CSS template
         * @param {CssTemplateRestApiPut} body Model schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePkPut(body: CssTemplateRestApiPut, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1CssTemplatePkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1CssTemplatePkPut.');
            }
            const localVarPath = `/api/v1/css_template/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CssTemplateRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a CSS template
         * @param {CssTemplateRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePost(body: CssTemplateRestApiPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1CssTemplatePost.');
            }
            const localVarPath = `/api/v1/css_template/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CssTemplateRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1CssTemplateRelatedColumnNameGet.');
            }
            const localVarPath = `/api/v1/css_template/related/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CSSTemplatesApi - functional programming interface
 * @export
 */
export const CSSTemplatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes multiple css templates in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateDelete(q?: GetDeleteIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = CSSTemplatesApiFetchParamCreator(configuration).apiV1CssTemplateDelete(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of CSS templates, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = CSSTemplatesApiFetchParamCreator(configuration).apiV1CssTemplateGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateInfoGet(q?: GetInfoSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = CSSTemplatesApiFetchParamCreator(configuration).apiV1CssTemplateInfoGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete CSS template
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePkDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = CSSTemplatesApiFetchParamCreator(configuration).apiV1CssTemplatePkDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a CSS template
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePkGet(pk: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = CSSTemplatesApiFetchParamCreator(configuration).apiV1CssTemplatePkGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a CSS template
         * @param {CssTemplateRestApiPut} body Model schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePkPut(body: CssTemplateRestApiPut, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = CSSTemplatesApiFetchParamCreator(configuration).apiV1CssTemplatePkPut(body, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a CSS template
         * @param {CssTemplateRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePost(body: CssTemplateRestApiPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2013> {
            const localVarFetchArgs = CSSTemplatesApiFetchParamCreator(configuration).apiV1CssTemplatePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RelatedResponseSchema> {
            const localVarFetchArgs = CSSTemplatesApiFetchParamCreator(configuration).apiV1CssTemplateRelatedColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CSSTemplatesApi - factory interface
 * @export
 */
export const CSSTemplatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes multiple css templates in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateDelete(q?: GetDeleteIdsSchema, options?: any) {
            return CSSTemplatesApiFp(configuration).apiV1CssTemplateDelete(q, options)(fetch, basePath);
        },
        /**
         * Get a list of CSS templates, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateGet(q?: GetListSchema, options?: any) {
            return CSSTemplatesApiFp(configuration).apiV1CssTemplateGet(q, options)(fetch, basePath);
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateInfoGet(q?: GetInfoSchema, options?: any) {
            return CSSTemplatesApiFp(configuration).apiV1CssTemplateInfoGet(q, options)(fetch, basePath);
        },
        /**
         * Delete CSS template
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePkDelete(pk: number, options?: any) {
            return CSSTemplatesApiFp(configuration).apiV1CssTemplatePkDelete(pk, options)(fetch, basePath);
        },
        /**
         * Get a CSS template
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePkGet(pk: number, q?: GetItemSchema, options?: any) {
            return CSSTemplatesApiFp(configuration).apiV1CssTemplatePkGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Update a CSS template
         * @param {CssTemplateRestApiPut} body Model schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePkPut(body: CssTemplateRestApiPut, pk: number, options?: any) {
            return CSSTemplatesApiFp(configuration).apiV1CssTemplatePkPut(body, pk, options)(fetch, basePath);
        },
        /**
         * Create a CSS template
         * @param {CssTemplateRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplatePost(body: CssTemplateRestApiPost, options?: any) {
            return CSSTemplatesApiFp(configuration).apiV1CssTemplatePost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CssTemplateRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return CSSTemplatesApiFp(configuration).apiV1CssTemplateRelatedColumnNameGet(columnName, q, options)(fetch, basePath);
        },
    };
};

/**
 * CSSTemplatesApi - object-oriented interface
 * @export
 * @class CSSTemplatesApi
 * @extends {BaseAPI}
 */
export class CSSTemplatesApi extends BaseAPI {
    /**
     * Deletes multiple css templates in a bulk operation.
     * @param {GetDeleteIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSSTemplatesApi
     */
    public apiV1CssTemplateDelete(q?: GetDeleteIdsSchema, options?: any) {
        return CSSTemplatesApiFp(this.configuration).apiV1CssTemplateDelete(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of CSS templates, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSSTemplatesApi
     */
    public apiV1CssTemplateGet(q?: GetListSchema, options?: any) {
        return CSSTemplatesApiFp(this.configuration).apiV1CssTemplateGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get metadata information about this API resource
     * @param {GetInfoSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSSTemplatesApi
     */
    public apiV1CssTemplateInfoGet(q?: GetInfoSchema, options?: any) {
        return CSSTemplatesApiFp(this.configuration).apiV1CssTemplateInfoGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Delete CSS template
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSSTemplatesApi
     */
    public apiV1CssTemplatePkDelete(pk: number, options?: any) {
        return CSSTemplatesApiFp(this.configuration).apiV1CssTemplatePkDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get a CSS template
     * @param {number} pk 
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSSTemplatesApi
     */
    public apiV1CssTemplatePkGet(pk: number, q?: GetItemSchema, options?: any) {
        return CSSTemplatesApiFp(this.configuration).apiV1CssTemplatePkGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Update a CSS template
     * @param {CssTemplateRestApiPut} body Model schema
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSSTemplatesApi
     */
    public apiV1CssTemplatePkPut(body: CssTemplateRestApiPut, pk: number, options?: any) {
        return CSSTemplatesApiFp(this.configuration).apiV1CssTemplatePkPut(body, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Create a CSS template
     * @param {CssTemplateRestApiPost} body Model schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSSTemplatesApi
     */
    public apiV1CssTemplatePost(body: CssTemplateRestApiPost, options?: any) {
        return CSSTemplatesApiFp(this.configuration).apiV1CssTemplatePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSSTemplatesApi
     */
    public apiV1CssTemplateRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return CSSTemplatesApiFp(this.configuration).apiV1CssTemplateRelatedColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

}
/**
 * CacheRestApiApi - fetch parameter creator
 * @export
 */
export const CacheRestApiApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a list of datasources, finds the associated cache records and invalidates them and removes the database records
         * @param {CacheInvalidationRequestSchema} body A list of datasources uuid or the tuples of database and datasource names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CachekeyInvalidatePost(body: CacheInvalidationRequestSchema, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1CachekeyInvalidatePost.');
            }
            const localVarPath = `/api/v1/cachekey/invalidate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CacheInvalidationRequestSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CacheRestApiApi - functional programming interface
 * @export
 */
export const CacheRestApiApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Takes a list of datasources, finds the associated cache records and invalidates them and removes the database records
         * @param {CacheInvalidationRequestSchema} body A list of datasources uuid or the tuples of database and datasource names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CachekeyInvalidatePost(body: CacheInvalidationRequestSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CacheRestApiApiFetchParamCreator(configuration).apiV1CachekeyInvalidatePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CacheRestApiApi - factory interface
 * @export
 */
export const CacheRestApiApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Takes a list of datasources, finds the associated cache records and invalidates them and removes the database records
         * @param {CacheInvalidationRequestSchema} body A list of datasources uuid or the tuples of database and datasource names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CachekeyInvalidatePost(body: CacheInvalidationRequestSchema, options?: any) {
            return CacheRestApiApiFp(configuration).apiV1CachekeyInvalidatePost(body, options)(fetch, basePath);
        },
    };
};

/**
 * CacheRestApiApi - object-oriented interface
 * @export
 * @class CacheRestApiApi
 * @extends {BaseAPI}
 */
export class CacheRestApiApi extends BaseAPI {
    /**
     * Takes a list of datasources, finds the associated cache records and invalidates them and removes the database records
     * @param {CacheInvalidationRequestSchema} body A list of datasources uuid or the tuples of database and datasource names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CacheRestApiApi
     */
    public apiV1CachekeyInvalidatePost(body: CacheInvalidationRequestSchema, options?: any) {
        return CacheRestApiApiFp(this.configuration).apiV1CachekeyInvalidatePost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ChartsApi - fetch parameter creator
 * @export
 */
export const ChartsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a query context cache key and returns payload data response for the given query.
         * @param {string} cacheKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartDataCacheKeyGet(cacheKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'cacheKey' is not null or undefined
            if (cacheKey === null || cacheKey === undefined) {
                throw new RequiredError('cacheKey','Required parameter cacheKey was null or undefined when calling apiV1ChartDataCacheKeyGet.');
            }
            const localVarPath = `/api/v1/chart/data/{cache_key}`
                .replace(`{${"cache_key"}}`, encodeURIComponent(String(cacheKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a query context constructed in the client and returns payload data response for the given query.
         * @param {ChartDataQueryContextSchema} body A query context consists of a datasource from which to fetch data and one or many query objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartDataPost(body: ChartDataQueryContextSchema, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1ChartDataPost.');
            }
            const localVarPath = `/api/v1/chart/data`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChartDataQueryContextSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes multiple Charts in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartDelete(q?: GetDeleteIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/chart/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports multiple charts and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartExportGet(q?: GetExportIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/chart/export/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check favorited dashboards for current user
         * @param {GetFavStarIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartFavoriteStatusGet(q?: GetFavStarIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/chart/favorite_status/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of charts, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/chart/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options: any = {}): FetchArgs {
            // verify required parameter 'formData' is not null or undefined
            if (formData === null || formData === undefined) {
                throw new RequiredError('formData','Required parameter formData was null or undefined when calling apiV1ChartImportPost.');
            }
            // verify required parameter 'overwrite' is not null or undefined
            if (overwrite === null || overwrite === undefined) {
                throw new RequiredError('overwrite','Required parameter overwrite was null or undefined when calling apiV1ChartImportPost.');
            }
            // verify required parameter 'passwords' is not null or undefined
            if (passwords === null || passwords === undefined) {
                throw new RequiredError('passwords','Required parameter passwords was null or undefined when calling apiV1ChartImportPost.');
            }
            // verify required parameter 'sshTunnelPasswords' is not null or undefined
            if (sshTunnelPasswords === null || sshTunnelPasswords === undefined) {
                throw new RequiredError('sshTunnelPasswords','Required parameter sshTunnelPasswords was null or undefined when calling apiV1ChartImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeyPasswords' is not null or undefined
            if (sshTunnelPrivateKeyPasswords === null || sshTunnelPrivateKeyPasswords === undefined) {
                throw new RequiredError('sshTunnelPrivateKeyPasswords','Required parameter sshTunnelPrivateKeyPasswords was null or undefined when calling apiV1ChartImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeys' is not null or undefined
            if (sshTunnelPrivateKeys === null || sshTunnelPrivateKeys === undefined) {
                throw new RequiredError('sshTunnelPrivateKeys','Required parameter sshTunnelPrivateKeys was null or undefined when calling apiV1ChartImportPost.');
            }
            const localVarPath = `/api/v1/chart/import/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication jwt required

            if (formData !== undefined) {
                localVarFormParams.set('formData', formData as any);
            }

            if (overwrite !== undefined) {
                localVarFormParams.set('overwrite', overwrite as any);
            }

            if (passwords !== undefined) {
                localVarFormParams.set('passwords', passwords as any);
            }

            if (sshTunnelPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_passwords', sshTunnelPasswords as any);
            }

            if (sshTunnelPrivateKeyPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_key_passwords', sshTunnelPrivateKeyPasswords as any);
            }

            if (sshTunnelPrivateKeys !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_keys', sshTunnelPrivateKeys as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Several metadata information about chart API endpoints.
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartInfoGet(q?: GetInfoSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/chart/_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compute and cache a screenshot.
         * @param {number} pk 
         * @param {ScreenshotQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkCacheScreenshotGet(pk: number, q?: ScreenshotQuerySchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ChartPkCacheScreenshotGet.');
            }
            const localVarPath = `/api/v1/chart/{pk}/cache_screenshot/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a chart ID and uses the query context stored when the chart was saved to return payload data response.
         * @param {number} pk The chart ID
         * @param {string} [format] The format in which the data should be returned
         * @param {string} [type] The type in which the data should be returned
         * @param {boolean} [force] Should the queries be forced to load from the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkDataGet(pk: number, format?: string, type?: string, force?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ChartPkDataGet.');
            }
            const localVarPath = `/api/v1/chart/{pk}/data/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Chart.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ChartPkDelete.');
            }
            const localVarPath = `/api/v1/chart/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the chart from the user favorite list
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkFavoritesDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ChartPkFavoritesDelete.');
            }
            const localVarPath = `/api/v1/chart/{pk}/favorites/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks the chart as favorite for the current user
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkFavoritesPost(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ChartPkFavoritesPost.');
            }
            const localVarPath = `/api/v1/chart/{pk}/favorites/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a chart detail information.
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkGet(pk: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ChartPkGet.');
            }
            const localVarPath = `/api/v1/chart/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes a Chart.
         * @param {ChartRestApiPut} body Chart schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkPut(body: ChartRestApiPut, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1ChartPkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ChartPkPut.');
            }
            const localVarPath = `/api/v1/chart/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChartRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a computed screenshot from cache.
         * @param {number} pk 
         * @param {string} digest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkScreenshotDigestGet(pk: number, digest: string, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ChartPkScreenshotDigestGet.');
            }
            // verify required parameter 'digest' is not null or undefined
            if (digest === null || digest === undefined) {
                throw new RequiredError('digest','Required parameter digest was null or undefined when calling apiV1ChartPkScreenshotDigestGet.');
            }
            const localVarPath = `/api/v1/chart/{pk}/screenshot/{digest}/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"digest"}}`, encodeURIComponent(String(digest)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compute or get already computed chart thumbnail from cache.
         * @param {number} pk 
         * @param {string} digest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkThumbnailDigestGet(pk: number, digest: string, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ChartPkThumbnailDigestGet.');
            }
            // verify required parameter 'digest' is not null or undefined
            if (digest === null || digest === undefined) {
                throw new RequiredError('digest','Required parameter digest was null or undefined when calling apiV1ChartPkThumbnailDigestGet.');
            }
            const localVarPath = `/api/v1/chart/{pk}/thumbnail/{digest}/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"digest"}}`, encodeURIComponent(String(digest)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Chart.
         * @param {ChartRestApiPost} body Chart schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPost(body: ChartRestApiPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1ChartPost.');
            }
            const localVarPath = `/api/v1/chart/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChartRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all possible owners for a chart. Use `owners` has the `column_name` parameter
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1ChartRelatedColumnNameGet.');
            }
            const localVarPath = `/api/v1/chart/related/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChartsApi - functional programming interface
 * @export
 */
export const ChartsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Takes a query context cache key and returns payload data response for the given query.
         * @param {string} cacheKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartDataCacheKeyGet(cacheKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChartDataResponseSchema> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartDataCacheKeyGet(cacheKey, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Takes a query context constructed in the client and returns payload data response for the given query.
         * @param {ChartDataQueryContextSchema} body A query context consists of a datasource from which to fetch data and one or many query objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartDataPost(body: ChartDataQueryContextSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChartDataResponseSchema> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartDataPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes multiple Charts in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartDelete(q?: GetDeleteIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartDelete(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Exports multiple charts and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartExportGet(q?: GetExportIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartExportGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check favorited dashboards for current user
         * @param {GetFavStarIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartFavoriteStatusGet(q?: GetFavStarIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetFavStarIdsSchema> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartFavoriteStatusGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of charts, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Several metadata information about chart API endpoints.
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartInfoGet(q?: GetInfoSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartInfoGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Compute and cache a screenshot.
         * @param {number} pk 
         * @param {ScreenshotQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkCacheScreenshotGet(pk: number, q?: ScreenshotQuerySchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChartCacheScreenshotResponseSchema> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartPkCacheScreenshotGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Takes a chart ID and uses the query context stored when the chart was saved to return payload data response.
         * @param {number} pk The chart ID
         * @param {string} [format] The format in which the data should be returned
         * @param {string} [type] The type in which the data should be returned
         * @param {boolean} [force] Should the queries be forced to load from the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkDataGet(pk: number, format?: string, type?: string, force?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChartDataResponseSchema> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartPkDataGet(pk, format, type, force, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Chart.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartPkDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove the chart from the user favorite list
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkFavoritesDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartPkFavoritesDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks the chart as favorite for the current user
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkFavoritesPost(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartPkFavoritesPost(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a chart detail information.
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkGet(pk: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartPkGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Changes a Chart.
         * @param {ChartRestApiPut} body Chart schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkPut(body: ChartRestApiPut, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartPkPut(body, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a computed screenshot from cache.
         * @param {number} pk 
         * @param {string} digest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkScreenshotDigestGet(pk: number, digest: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartPkScreenshotDigestGet(pk, digest, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Compute or get already computed chart thumbnail from cache.
         * @param {number} pk 
         * @param {string} digest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkThumbnailDigestGet(pk: number, digest: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartPkThumbnailDigestGet(pk, digest, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Chart.
         * @param {ChartRestApiPost} body Chart schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPost(body: ChartRestApiPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2012> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all possible owners for a chart. Use `owners` has the `column_name` parameter
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RelatedResponseSchema> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV1ChartRelatedColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChartsApi - factory interface
 * @export
 */
export const ChartsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Takes a query context cache key and returns payload data response for the given query.
         * @param {string} cacheKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartDataCacheKeyGet(cacheKey: string, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartDataCacheKeyGet(cacheKey, options)(fetch, basePath);
        },
        /**
         * Takes a query context constructed in the client and returns payload data response for the given query.
         * @param {ChartDataQueryContextSchema} body A query context consists of a datasource from which to fetch data and one or many query objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartDataPost(body: ChartDataQueryContextSchema, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartDataPost(body, options)(fetch, basePath);
        },
        /**
         * Deletes multiple Charts in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartDelete(q?: GetDeleteIdsSchema, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartDelete(q, options)(fetch, basePath);
        },
        /**
         * Exports multiple charts and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartExportGet(q?: GetExportIdsSchema, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartExportGet(q, options)(fetch, basePath);
        },
        /**
         * Check favorited dashboards for current user
         * @param {GetFavStarIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartFavoriteStatusGet(q?: GetFavStarIdsSchema, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartFavoriteStatusGet(q, options)(fetch, basePath);
        },
        /**
         * Get a list of charts, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartGet(q?: GetListSchema, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartGet(q, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options)(fetch, basePath);
        },
        /**
         * Several metadata information about chart API endpoints.
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartInfoGet(q?: GetInfoSchema, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartInfoGet(q, options)(fetch, basePath);
        },
        /**
         * Compute and cache a screenshot.
         * @param {number} pk 
         * @param {ScreenshotQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkCacheScreenshotGet(pk: number, q?: ScreenshotQuerySchema, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartPkCacheScreenshotGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Takes a chart ID and uses the query context stored when the chart was saved to return payload data response.
         * @param {number} pk The chart ID
         * @param {string} [format] The format in which the data should be returned
         * @param {string} [type] The type in which the data should be returned
         * @param {boolean} [force] Should the queries be forced to load from the source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkDataGet(pk: number, format?: string, type?: string, force?: boolean, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartPkDataGet(pk, format, type, force, options)(fetch, basePath);
        },
        /**
         * Deletes a Chart.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkDelete(pk: number, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartPkDelete(pk, options)(fetch, basePath);
        },
        /**
         * Remove the chart from the user favorite list
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkFavoritesDelete(pk: number, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartPkFavoritesDelete(pk, options)(fetch, basePath);
        },
        /**
         * Marks the chart as favorite for the current user
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkFavoritesPost(pk: number, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartPkFavoritesPost(pk, options)(fetch, basePath);
        },
        /**
         * Get a chart detail information.
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkGet(pk: number, q?: GetItemSchema, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartPkGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Changes a Chart.
         * @param {ChartRestApiPut} body Chart schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkPut(body: ChartRestApiPut, pk: number, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartPkPut(body, pk, options)(fetch, basePath);
        },
        /**
         * Get a computed screenshot from cache.
         * @param {number} pk 
         * @param {string} digest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkScreenshotDigestGet(pk: number, digest: string, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartPkScreenshotDigestGet(pk, digest, options)(fetch, basePath);
        },
        /**
         * Compute or get already computed chart thumbnail from cache.
         * @param {number} pk 
         * @param {string} digest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPkThumbnailDigestGet(pk: number, digest: string, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartPkThumbnailDigestGet(pk, digest, options)(fetch, basePath);
        },
        /**
         * Create a new Chart.
         * @param {ChartRestApiPost} body Chart schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartPost(body: ChartRestApiPost, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartPost(body, options)(fetch, basePath);
        },
        /**
         * Get a list of all possible owners for a chart. Use `owners` has the `column_name` parameter
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChartRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return ChartsApiFp(configuration).apiV1ChartRelatedColumnNameGet(columnName, q, options)(fetch, basePath);
        },
    };
};

/**
 * ChartsApi - object-oriented interface
 * @export
 * @class ChartsApi
 * @extends {BaseAPI}
 */
export class ChartsApi extends BaseAPI {
    /**
     * Takes a query context cache key and returns payload data response for the given query.
     * @param {string} cacheKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartDataCacheKeyGet(cacheKey: string, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartDataCacheKeyGet(cacheKey, options)(this.fetch, this.basePath);
    }

    /**
     * Takes a query context constructed in the client and returns payload data response for the given query.
     * @param {ChartDataQueryContextSchema} body A query context consists of a datasource from which to fetch data and one or many query objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartDataPost(body: ChartDataQueryContextSchema, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartDataPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes multiple Charts in a bulk operation.
     * @param {GetDeleteIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartDelete(q?: GetDeleteIdsSchema, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartDelete(q, options)(this.fetch, this.basePath);
    }

    /**
     * Exports multiple charts and downloads them as YAML files
     * @param {GetExportIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartExportGet(q?: GetExportIdsSchema, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartExportGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Check favorited dashboards for current user
     * @param {GetFavStarIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartFavoriteStatusGet(q?: GetFavStarIdsSchema, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartFavoriteStatusGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of charts, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartGet(q?: GetListSchema, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Blob} formData 
     * @param {boolean} overwrite 
     * @param {string} passwords 
     * @param {string} sshTunnelPasswords 
     * @param {string} sshTunnelPrivateKeyPasswords 
     * @param {string} sshTunnelPrivateKeys 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options)(this.fetch, this.basePath);
    }

    /**
     * Several metadata information about chart API endpoints.
     * @param {GetInfoSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartInfoGet(q?: GetInfoSchema, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartInfoGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Compute and cache a screenshot.
     * @param {number} pk 
     * @param {ScreenshotQuerySchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartPkCacheScreenshotGet(pk: number, q?: ScreenshotQuerySchema, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartPkCacheScreenshotGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Takes a chart ID and uses the query context stored when the chart was saved to return payload data response.
     * @param {number} pk The chart ID
     * @param {string} [format] The format in which the data should be returned
     * @param {string} [type] The type in which the data should be returned
     * @param {boolean} [force] Should the queries be forced to load from the source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartPkDataGet(pk: number, format?: string, type?: string, force?: boolean, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartPkDataGet(pk, format, type, force, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Chart.
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartPkDelete(pk: number, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartPkDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Remove the chart from the user favorite list
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartPkFavoritesDelete(pk: number, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartPkFavoritesDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Marks the chart as favorite for the current user
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartPkFavoritesPost(pk: number, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartPkFavoritesPost(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get a chart detail information.
     * @param {number} pk 
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartPkGet(pk: number, q?: GetItemSchema, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartPkGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Changes a Chart.
     * @param {ChartRestApiPut} body Chart schema
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartPkPut(body: ChartRestApiPut, pk: number, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartPkPut(body, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get a computed screenshot from cache.
     * @param {number} pk 
     * @param {string} digest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartPkScreenshotDigestGet(pk: number, digest: string, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartPkScreenshotDigestGet(pk, digest, options)(this.fetch, this.basePath);
    }

    /**
     * Compute or get already computed chart thumbnail from cache.
     * @param {number} pk 
     * @param {string} digest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartPkThumbnailDigestGet(pk: number, digest: string, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartPkThumbnailDigestGet(pk, digest, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new Chart.
     * @param {ChartRestApiPost} body Chart schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartPost(body: ChartRestApiPost, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all possible owners for a chart. Use `owners` has the `column_name` parameter
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV1ChartRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return ChartsApiFp(this.configuration).apiV1ChartRelatedColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

}
/**
 * CurrentUserApi - fetch parameter creator
 * @export
 */
export const CurrentUserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the user object corresponding to the agent making the request, or returns a 401 error if the user is unauthenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MeGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/me/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the user roles corresponding to the agent making the request, or returns a 401 error if the user is unauthenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MeRolesGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/me/roles/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrentUserApi - functional programming interface
 * @export
 */
export const CurrentUserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the user object corresponding to the agent making the request, or returns a 401 error if the user is unauthenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MeGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20042> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).apiV1MeGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the user roles corresponding to the agent making the request, or returns a 401 error if the user is unauthenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MeRolesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20042> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).apiV1MeRolesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CurrentUserApi - factory interface
 * @export
 */
export const CurrentUserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the user object corresponding to the agent making the request, or returns a 401 error if the user is unauthenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MeGet(options?: any) {
            return CurrentUserApiFp(configuration).apiV1MeGet(options)(fetch, basePath);
        },
        /**
         * Returns the user roles corresponding to the agent making the request, or returns a 401 error if the user is unauthenticated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MeRolesGet(options?: any) {
            return CurrentUserApiFp(configuration).apiV1MeRolesGet(options)(fetch, basePath);
        },
    };
};

/**
 * CurrentUserApi - object-oriented interface
 * @export
 * @class CurrentUserApi
 * @extends {BaseAPI}
 */
export class CurrentUserApi extends BaseAPI {
    /**
     * Returns the user object corresponding to the agent making the request, or returns a 401 error if the user is unauthenticated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public apiV1MeGet(options?: any) {
        return CurrentUserApiFp(this.configuration).apiV1MeGet(options)(this.fetch, this.basePath);
    }

    /**
     * Returns the user roles corresponding to the agent making the request, or returns a 401 error if the user is unauthenticated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public apiV1MeRolesGet(options?: any) {
        return CurrentUserApiFp(this.configuration).apiV1MeRolesGet(options)(this.fetch, this.basePath);
    }

}
/**
 * DashboardFilterStateApi - fetch parameter creator
 * @export
 */
export const DashboardFilterStateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a value.
         * @param {number} pk 
         * @param {string} key The value key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStateKeyDelete(pk: number, key: string, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardPkFilterStateKeyDelete.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling apiV1DashboardPkFilterStateKeyDelete.');
            }
            const localVarPath = `/api/v1/dashboard/{pk}/filter_state/{key}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrives a value.
         * @param {number} pk 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStateKeyGet(pk: number, key: string, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardPkFilterStateKeyGet.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling apiV1DashboardPkFilterStateKeyGet.');
            }
            const localVarPath = `/api/v1/dashboard/{pk}/filter_state/{key}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing value.
         * @param {TemporaryCachePutSchema} body 
         * @param {number} pk 
         * @param {string} key 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStateKeyPut(body: TemporaryCachePutSchema, pk: number, key: string, tabId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DashboardPkFilterStateKeyPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardPkFilterStateKeyPut.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling apiV1DashboardPkFilterStateKeyPut.');
            }
            const localVarPath = `/api/v1/dashboard/{pk}/filter_state/{key}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (tabId !== undefined) {
                localVarQueryParameter['tab_id'] = tabId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TemporaryCachePutSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores a new value.
         * @param {TemporaryCachePostSchema} body 
         * @param {number} pk 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStatePost(body: TemporaryCachePostSchema, pk: number, tabId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DashboardPkFilterStatePost.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardPkFilterStatePost.');
            }
            const localVarPath = `/api/v1/dashboard/{pk}/filter_state`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (tabId !== undefined) {
                localVarQueryParameter['tab_id'] = tabId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TemporaryCachePostSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardFilterStateApi - functional programming interface
 * @export
 */
export const DashboardFilterStateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a value.
         * @param {number} pk 
         * @param {string} key The value key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStateKeyDelete(pk: number, key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20028> {
            const localVarFetchArgs = DashboardFilterStateApiFetchParamCreator(configuration).apiV1DashboardPkFilterStateKeyDelete(pk, key, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrives a value.
         * @param {number} pk 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStateKeyGet(pk: number, key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20027> {
            const localVarFetchArgs = DashboardFilterStateApiFetchParamCreator(configuration).apiV1DashboardPkFilterStateKeyGet(pk, key, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an existing value.
         * @param {TemporaryCachePutSchema} body 
         * @param {number} pk 
         * @param {string} key 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStateKeyPut(body: TemporaryCachePutSchema, pk: number, key: string, tabId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2016> {
            const localVarFetchArgs = DashboardFilterStateApiFetchParamCreator(configuration).apiV1DashboardPkFilterStateKeyPut(body, pk, key, tabId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stores a new value.
         * @param {TemporaryCachePostSchema} body 
         * @param {number} pk 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStatePost(body: TemporaryCachePostSchema, pk: number, tabId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2016> {
            const localVarFetchArgs = DashboardFilterStateApiFetchParamCreator(configuration).apiV1DashboardPkFilterStatePost(body, pk, tabId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DashboardFilterStateApi - factory interface
 * @export
 */
export const DashboardFilterStateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes a value.
         * @param {number} pk 
         * @param {string} key The value key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStateKeyDelete(pk: number, key: string, options?: any) {
            return DashboardFilterStateApiFp(configuration).apiV1DashboardPkFilterStateKeyDelete(pk, key, options)(fetch, basePath);
        },
        /**
         * Retrives a value.
         * @param {number} pk 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStateKeyGet(pk: number, key: string, options?: any) {
            return DashboardFilterStateApiFp(configuration).apiV1DashboardPkFilterStateKeyGet(pk, key, options)(fetch, basePath);
        },
        /**
         * Updates an existing value.
         * @param {TemporaryCachePutSchema} body 
         * @param {number} pk 
         * @param {string} key 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStateKeyPut(body: TemporaryCachePutSchema, pk: number, key: string, tabId?: number, options?: any) {
            return DashboardFilterStateApiFp(configuration).apiV1DashboardPkFilterStateKeyPut(body, pk, key, tabId, options)(fetch, basePath);
        },
        /**
         * Stores a new value.
         * @param {TemporaryCachePostSchema} body 
         * @param {number} pk 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFilterStatePost(body: TemporaryCachePostSchema, pk: number, tabId?: number, options?: any) {
            return DashboardFilterStateApiFp(configuration).apiV1DashboardPkFilterStatePost(body, pk, tabId, options)(fetch, basePath);
        },
    };
};

/**
 * DashboardFilterStateApi - object-oriented interface
 * @export
 * @class DashboardFilterStateApi
 * @extends {BaseAPI}
 */
export class DashboardFilterStateApi extends BaseAPI {
    /**
     * Deletes a value.
     * @param {number} pk 
     * @param {string} key The value key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardFilterStateApi
     */
    public apiV1DashboardPkFilterStateKeyDelete(pk: number, key: string, options?: any) {
        return DashboardFilterStateApiFp(this.configuration).apiV1DashboardPkFilterStateKeyDelete(pk, key, options)(this.fetch, this.basePath);
    }

    /**
     * Retrives a value.
     * @param {number} pk 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardFilterStateApi
     */
    public apiV1DashboardPkFilterStateKeyGet(pk: number, key: string, options?: any) {
        return DashboardFilterStateApiFp(this.configuration).apiV1DashboardPkFilterStateKeyGet(pk, key, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an existing value.
     * @param {TemporaryCachePutSchema} body 
     * @param {number} pk 
     * @param {string} key 
     * @param {number} [tabId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardFilterStateApi
     */
    public apiV1DashboardPkFilterStateKeyPut(body: TemporaryCachePutSchema, pk: number, key: string, tabId?: number, options?: any) {
        return DashboardFilterStateApiFp(this.configuration).apiV1DashboardPkFilterStateKeyPut(body, pk, key, tabId, options)(this.fetch, this.basePath);
    }

    /**
     * Stores a new value.
     * @param {TemporaryCachePostSchema} body 
     * @param {number} pk 
     * @param {number} [tabId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardFilterStateApi
     */
    public apiV1DashboardPkFilterStatePost(body: TemporaryCachePostSchema, pk: number, tabId?: number, options?: any) {
        return DashboardFilterStateApiFp(this.configuration).apiV1DashboardPkFilterStatePost(body, pk, tabId, options)(this.fetch, this.basePath);
    }

}
/**
 * DashboardPermanentLinkApi - fetch parameter creator
 * @export
 */
export const DashboardPermanentLinkApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrives dashboard state associated with a permanent link.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPermalinkKeyGet(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling apiV1DashboardPermalinkKeyGet.');
            }
            const localVarPath = `/api/v1/dashboard/permalink/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores a new permanent link.
         * @param {string} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkPermalinkPost(pk: string, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardPkPermalinkPost.');
            }
            const localVarPath = `/api/v1/dashboard/{pk}/permalink`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardPermanentLinkApi - functional programming interface
 * @export
 */
export const DashboardPermanentLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrives dashboard state associated with a permanent link.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPermalinkKeyGet(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20018> {
            const localVarFetchArgs = DashboardPermanentLinkApiFetchParamCreator(configuration).apiV1DashboardPermalinkKeyGet(key, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stores a new permanent link.
         * @param {string} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkPermalinkPost(pk: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2017> {
            const localVarFetchArgs = DashboardPermanentLinkApiFetchParamCreator(configuration).apiV1DashboardPkPermalinkPost(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DashboardPermanentLinkApi - factory interface
 * @export
 */
export const DashboardPermanentLinkApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrives dashboard state associated with a permanent link.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPermalinkKeyGet(key: string, options?: any) {
            return DashboardPermanentLinkApiFp(configuration).apiV1DashboardPermalinkKeyGet(key, options)(fetch, basePath);
        },
        /**
         * Stores a new permanent link.
         * @param {string} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkPermalinkPost(pk: string, options?: any) {
            return DashboardPermanentLinkApiFp(configuration).apiV1DashboardPkPermalinkPost(pk, options)(fetch, basePath);
        },
    };
};

/**
 * DashboardPermanentLinkApi - object-oriented interface
 * @export
 * @class DashboardPermanentLinkApi
 * @extends {BaseAPI}
 */
export class DashboardPermanentLinkApi extends BaseAPI {
    /**
     * Retrives dashboard state associated with a permanent link.
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPermanentLinkApi
     */
    public apiV1DashboardPermalinkKeyGet(key: string, options?: any) {
        return DashboardPermanentLinkApiFp(this.configuration).apiV1DashboardPermalinkKeyGet(key, options)(this.fetch, this.basePath);
    }

    /**
     * Stores a new permanent link.
     * @param {string} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPermanentLinkApi
     */
    public apiV1DashboardPkPermalinkPost(pk: string, options?: any) {
        return DashboardPermanentLinkApiFp(this.configuration).apiV1DashboardPkPermalinkPost(pk, options)(this.fetch, this.basePath);
    }

}
/**
 * DashboardsApi - fetch parameter creator
 * @export
 */
export const DashboardsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes multiple Dashboards in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDelete(q?: GetDeleteIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/dashboard/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports multiple Dashboards and downloads them as YAML files.
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardExportGet(q?: GetExportIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/dashboard/export/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check favorited dashboards for current user
         * @param {GetFavStarIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardFavoriteStatusGet(q?: GetFavStarIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/dashboard/favorite_status/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of dashboards, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/dashboard/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the chart definitions for a given dashboard
         * @param {string} idOrSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugChartsGet(idOrSlug: string, options: any = {}): FetchArgs {
            // verify required parameter 'idOrSlug' is not null or undefined
            if (idOrSlug === null || idOrSlug === undefined) {
                throw new RequiredError('idOrSlug','Required parameter idOrSlug was null or undefined when calling apiV1DashboardIdOrSlugChartsGet.');
            }
            const localVarPath = `/api/v1/dashboard/{id_or_slug}/charts`
                .replace(`{${"id_or_slug"}}`, encodeURIComponent(String(idOrSlug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Makes a copy of an existing dashboard
         * @param {DashboardCopySchema} body 
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugCopyPost(body: DashboardCopySchema, idOrSlug: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DashboardIdOrSlugCopyPost.');
            }
            // verify required parameter 'idOrSlug' is not null or undefined
            if (idOrSlug === null || idOrSlug === undefined) {
                throw new RequiredError('idOrSlug','Required parameter idOrSlug was null or undefined when calling apiV1DashboardIdOrSlugCopyPost.');
            }
            const localVarPath = `/api/v1/dashboard/{id_or_slug}/copy/`
                .replace(`{${"id_or_slug"}}`, encodeURIComponent(String(idOrSlug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DashboardCopySchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of a dashboard's datasets. Each dataset includes only the information necessary to render the dashboard's charts.
         * @param {string} idOrSlug Either the id of the dashboard, or its slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugDatasetsGet(idOrSlug: string, options: any = {}): FetchArgs {
            // verify required parameter 'idOrSlug' is not null or undefined
            if (idOrSlug === null || idOrSlug === undefined) {
                throw new RequiredError('idOrSlug','Required parameter idOrSlug was null or undefined when calling apiV1DashboardIdOrSlugDatasetsGet.');
            }
            const localVarPath = `/api/v1/dashboard/{id_or_slug}/datasets`
                .replace(`{${"id_or_slug"}}`, encodeURIComponent(String(idOrSlug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a dashboard's embedded configuration.
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedDelete(idOrSlug: string, options: any = {}): FetchArgs {
            // verify required parameter 'idOrSlug' is not null or undefined
            if (idOrSlug === null || idOrSlug === undefined) {
                throw new RequiredError('idOrSlug','Required parameter idOrSlug was null or undefined when calling apiV1DashboardIdOrSlugEmbeddedDelete.');
            }
            const localVarPath = `/api/v1/dashboard/{id_or_slug}/embedded`
                .replace(`{${"id_or_slug"}}`, encodeURIComponent(String(idOrSlug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the dashboard's embedded configuration
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedGet(idOrSlug: string, options: any = {}): FetchArgs {
            // verify required parameter 'idOrSlug' is not null or undefined
            if (idOrSlug === null || idOrSlug === undefined) {
                throw new RequiredError('idOrSlug','Required parameter idOrSlug was null or undefined when calling apiV1DashboardIdOrSlugEmbeddedGet.');
            }
            const localVarPath = `/api/v1/dashboard/{id_or_slug}/embedded`
                .replace(`{${"id_or_slug"}}`, encodeURIComponent(String(idOrSlug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a dashboard's embedded configuration.
         * @param {EmbeddedDashboardConfig} body The embedded configuration to set
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedPost(body: EmbeddedDashboardConfig, idOrSlug: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DashboardIdOrSlugEmbeddedPost.');
            }
            // verify required parameter 'idOrSlug' is not null or undefined
            if (idOrSlug === null || idOrSlug === undefined) {
                throw new RequiredError('idOrSlug','Required parameter idOrSlug was null or undefined when calling apiV1DashboardIdOrSlugEmbeddedPost.');
            }
            const localVarPath = `/api/v1/dashboard/{id_or_slug}/embedded`
                .replace(`{${"id_or_slug"}}`, encodeURIComponent(String(idOrSlug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmbeddedDashboardConfig" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a dashboard's embedded configuration.
         * @param {EmbeddedDashboardConfig} body The embedded configuration to set
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedPut(body: EmbeddedDashboardConfig, idOrSlug: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DashboardIdOrSlugEmbeddedPut.');
            }
            // verify required parameter 'idOrSlug' is not null or undefined
            if (idOrSlug === null || idOrSlug === undefined) {
                throw new RequiredError('idOrSlug','Required parameter idOrSlug was null or undefined when calling apiV1DashboardIdOrSlugEmbeddedPut.');
            }
            const localVarPath = `/api/v1/dashboard/{id_or_slug}/embedded`
                .replace(`{${"id_or_slug"}}`, encodeURIComponent(String(idOrSlug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmbeddedDashboardConfig" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a dashboard detail information.
         * @param {string} idOrSlug Either the id of the dashboard, or its slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugGet(idOrSlug: string, options: any = {}): FetchArgs {
            // verify required parameter 'idOrSlug' is not null or undefined
            if (idOrSlug === null || idOrSlug === undefined) {
                throw new RequiredError('idOrSlug','Required parameter idOrSlug was null or undefined when calling apiV1DashboardIdOrSlugGet.');
            }
            const localVarPath = `/api/v1/dashboard/{id_or_slug}`
                .replace(`{${"id_or_slug"}}`, encodeURIComponent(String(idOrSlug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options: any = {}): FetchArgs {
            // verify required parameter 'formData' is not null or undefined
            if (formData === null || formData === undefined) {
                throw new RequiredError('formData','Required parameter formData was null or undefined when calling apiV1DashboardImportPost.');
            }
            // verify required parameter 'overwrite' is not null or undefined
            if (overwrite === null || overwrite === undefined) {
                throw new RequiredError('overwrite','Required parameter overwrite was null or undefined when calling apiV1DashboardImportPost.');
            }
            // verify required parameter 'passwords' is not null or undefined
            if (passwords === null || passwords === undefined) {
                throw new RequiredError('passwords','Required parameter passwords was null or undefined when calling apiV1DashboardImportPost.');
            }
            // verify required parameter 'sshTunnelPasswords' is not null or undefined
            if (sshTunnelPasswords === null || sshTunnelPasswords === undefined) {
                throw new RequiredError('sshTunnelPasswords','Required parameter sshTunnelPasswords was null or undefined when calling apiV1DashboardImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeyPasswords' is not null or undefined
            if (sshTunnelPrivateKeyPasswords === null || sshTunnelPrivateKeyPasswords === undefined) {
                throw new RequiredError('sshTunnelPrivateKeyPasswords','Required parameter sshTunnelPrivateKeyPasswords was null or undefined when calling apiV1DashboardImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeys' is not null or undefined
            if (sshTunnelPrivateKeys === null || sshTunnelPrivateKeys === undefined) {
                throw new RequiredError('sshTunnelPrivateKeys','Required parameter sshTunnelPrivateKeys was null or undefined when calling apiV1DashboardImportPost.');
            }
            const localVarPath = `/api/v1/dashboard/import/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication jwt required

            if (formData !== undefined) {
                localVarFormParams.set('formData', formData as any);
            }

            if (overwrite !== undefined) {
                localVarFormParams.set('overwrite', overwrite as any);
            }

            if (passwords !== undefined) {
                localVarFormParams.set('passwords', passwords as any);
            }

            if (sshTunnelPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_passwords', sshTunnelPasswords as any);
            }

            if (sshTunnelPrivateKeyPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_key_passwords', sshTunnelPrivateKeyPasswords as any);
            }

            if (sshTunnelPrivateKeys !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_keys', sshTunnelPrivateKeys as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Several metadata information about dashboard API endpoints.
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardInfoGet(q?: GetInfoSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/dashboard/_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Dashboard.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardPkDelete.');
            }
            const localVarPath = `/api/v1/dashboard/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the dashboard from the user favorite list
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFavoritesDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardPkFavoritesDelete.');
            }
            const localVarPath = `/api/v1/dashboard/{pk}/favorites/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks the dashboard as favorite for the current user
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFavoritesPost(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardPkFavoritesPost.');
            }
            const localVarPath = `/api/v1/dashboard/{pk}/favorites/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes a Dashboard.
         * @param {DashboardRestApiPut} body Dashboard schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkPut(body: DashboardRestApiPut, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DashboardPkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardPkPut.');
            }
            const localVarPath = `/api/v1/dashboard/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DashboardRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compute async or get already computed dashboard thumbnail from cache.
         * @param {number} pk 
         * @param {string} digest A hex digest that makes this dashboard unique
         * @param {ThumbnailQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkThumbnailDigestGet(pk: number, digest: string, q?: ThumbnailQuerySchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardPkThumbnailDigestGet.');
            }
            // verify required parameter 'digest' is not null or undefined
            if (digest === null || digest === undefined) {
                throw new RequiredError('digest','Required parameter digest was null or undefined when calling apiV1DashboardPkThumbnailDigestGet.');
            }
            const localVarPath = `/api/v1/dashboard/{pk}/thumbnail/{digest}/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"digest"}}`, encodeURIComponent(String(digest)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Dashboard.
         * @param {DashboardRestApiPost} body Dashboard schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPost(body: DashboardRestApiPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DashboardPost.');
            }
            const localVarPath = `/api/v1/dashboard/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DashboardRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all possible owners for a dashboard.
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1DashboardRelatedColumnNameGet.');
            }
            const localVarPath = `/api/v1/dashboard/related/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes multiple Dashboards in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDelete(q?: GetDeleteIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardDelete(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Exports multiple Dashboards and downloads them as YAML files.
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardExportGet(q?: GetExportIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardExportGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check favorited dashboards for current user
         * @param {GetFavStarIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardFavoriteStatusGet(q?: GetFavStarIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetFavStarIdsSchema> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardFavoriteStatusGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of dashboards, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20017> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the chart definitions for a given dashboard
         * @param {string} idOrSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugChartsGet(idOrSlug: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20022> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardIdOrSlugChartsGet(idOrSlug, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Makes a copy of an existing dashboard
         * @param {DashboardCopySchema} body 
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugCopyPost(body: DashboardCopySchema, idOrSlug: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20023> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardIdOrSlugCopyPost(body, idOrSlug, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of a dashboard's datasets. Each dataset includes only the information necessary to render the dashboard's charts.
         * @param {string} idOrSlug Either the id of the dashboard, or its slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugDatasetsGet(idOrSlug: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20024> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardIdOrSlugDatasetsGet(idOrSlug, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes a dashboard's embedded configuration.
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedDelete(idOrSlug: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardIdOrSlugEmbeddedDelete(idOrSlug, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the dashboard's embedded configuration
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedGet(idOrSlug: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20025> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardIdOrSlugEmbeddedGet(idOrSlug, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets a dashboard's embedded configuration.
         * @param {EmbeddedDashboardConfig} body The embedded configuration to set
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedPost(body: EmbeddedDashboardConfig, idOrSlug: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20025> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardIdOrSlugEmbeddedPost(body, idOrSlug, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets a dashboard's embedded configuration.
         * @param {EmbeddedDashboardConfig} body The embedded configuration to set
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedPut(body: EmbeddedDashboardConfig, idOrSlug: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20025> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardIdOrSlugEmbeddedPut(body, idOrSlug, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a dashboard detail information.
         * @param {string} idOrSlug Either the id of the dashboard, or its slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugGet(idOrSlug: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20021> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardIdOrSlugGet(idOrSlug, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Several metadata information about dashboard API endpoints.
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardInfoGet(q?: GetInfoSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardInfoGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Dashboard.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardPkDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove the dashboard from the user favorite list
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFavoritesDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardPkFavoritesDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks the dashboard as favorite for the current user
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFavoritesPost(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardPkFavoritesPost(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Changes a Dashboard.
         * @param {DashboardRestApiPut} body Dashboard schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkPut(body: DashboardRestApiPut, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20026> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardPkPut(body, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Compute async or get already computed dashboard thumbnail from cache.
         * @param {number} pk 
         * @param {string} digest A hex digest that makes this dashboard unique
         * @param {ThumbnailQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkThumbnailDigestGet(pk: number, digest: string, q?: ThumbnailQuerySchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardPkThumbnailDigestGet(pk, digest, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Dashboard.
         * @param {DashboardRestApiPost} body Dashboard schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPost(body: DashboardRestApiPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2014> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all possible owners for a dashboard.
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RelatedResponseSchema> {
            const localVarFetchArgs = DashboardsApiFetchParamCreator(configuration).apiV1DashboardRelatedColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes multiple Dashboards in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDelete(q?: GetDeleteIdsSchema, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardDelete(q, options)(fetch, basePath);
        },
        /**
         * Exports multiple Dashboards and downloads them as YAML files.
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardExportGet(q?: GetExportIdsSchema, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardExportGet(q, options)(fetch, basePath);
        },
        /**
         * Check favorited dashboards for current user
         * @param {GetFavStarIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardFavoriteStatusGet(q?: GetFavStarIdsSchema, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardFavoriteStatusGet(q, options)(fetch, basePath);
        },
        /**
         * Get a list of dashboards, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardGet(q?: GetListSchema, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardGet(q, options)(fetch, basePath);
        },
        /**
         * Get the chart definitions for a given dashboard
         * @param {string} idOrSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugChartsGet(idOrSlug: string, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardIdOrSlugChartsGet(idOrSlug, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Makes a copy of an existing dashboard
         * @param {DashboardCopySchema} body 
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugCopyPost(body: DashboardCopySchema, idOrSlug: string, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardIdOrSlugCopyPost(body, idOrSlug, options)(fetch, basePath);
        },
        /**
         * Returns a list of a dashboard's datasets. Each dataset includes only the information necessary to render the dashboard's charts.
         * @param {string} idOrSlug Either the id of the dashboard, or its slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugDatasetsGet(idOrSlug: string, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardIdOrSlugDatasetsGet(idOrSlug, options)(fetch, basePath);
        },
        /**
         * Removes a dashboard's embedded configuration.
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedDelete(idOrSlug: string, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardIdOrSlugEmbeddedDelete(idOrSlug, options)(fetch, basePath);
        },
        /**
         * Returns the dashboard's embedded configuration
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedGet(idOrSlug: string, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardIdOrSlugEmbeddedGet(idOrSlug, options)(fetch, basePath);
        },
        /**
         * Sets a dashboard's embedded configuration.
         * @param {EmbeddedDashboardConfig} body The embedded configuration to set
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedPost(body: EmbeddedDashboardConfig, idOrSlug: string, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardIdOrSlugEmbeddedPost(body, idOrSlug, options)(fetch, basePath);
        },
        /**
         * Sets a dashboard's embedded configuration.
         * @param {EmbeddedDashboardConfig} body The embedded configuration to set
         * @param {string} idOrSlug The dashboard id or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugEmbeddedPut(body: EmbeddedDashboardConfig, idOrSlug: string, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardIdOrSlugEmbeddedPut(body, idOrSlug, options)(fetch, basePath);
        },
        /**
         * Get a dashboard detail information.
         * @param {string} idOrSlug Either the id of the dashboard, or its slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardIdOrSlugGet(idOrSlug: string, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardIdOrSlugGet(idOrSlug, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options)(fetch, basePath);
        },
        /**
         * Several metadata information about dashboard API endpoints.
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardInfoGet(q?: GetInfoSchema, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardInfoGet(q, options)(fetch, basePath);
        },
        /**
         * Deletes a Dashboard.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkDelete(pk: number, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardPkDelete(pk, options)(fetch, basePath);
        },
        /**
         * Remove the dashboard from the user favorite list
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFavoritesDelete(pk: number, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardPkFavoritesDelete(pk, options)(fetch, basePath);
        },
        /**
         * Marks the dashboard as favorite for the current user
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkFavoritesPost(pk: number, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardPkFavoritesPost(pk, options)(fetch, basePath);
        },
        /**
         * Changes a Dashboard.
         * @param {DashboardRestApiPut} body Dashboard schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkPut(body: DashboardRestApiPut, pk: number, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardPkPut(body, pk, options)(fetch, basePath);
        },
        /**
         * Compute async or get already computed dashboard thumbnail from cache.
         * @param {number} pk 
         * @param {string} digest A hex digest that makes this dashboard unique
         * @param {ThumbnailQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPkThumbnailDigestGet(pk: number, digest: string, q?: ThumbnailQuerySchema, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardPkThumbnailDigestGet(pk, digest, q, options)(fetch, basePath);
        },
        /**
         * Create a new Dashboard.
         * @param {DashboardRestApiPost} body Dashboard schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardPost(body: DashboardRestApiPost, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardPost(body, options)(fetch, basePath);
        },
        /**
         * Get a list of all possible owners for a dashboard.
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return DashboardsApiFp(configuration).apiV1DashboardRelatedColumnNameGet(columnName, q, options)(fetch, basePath);
        },
    };
};

/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
    /**
     * Deletes multiple Dashboards in a bulk operation.
     * @param {GetDeleteIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardDelete(q?: GetDeleteIdsSchema, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardDelete(q, options)(this.fetch, this.basePath);
    }

    /**
     * Exports multiple Dashboards and downloads them as YAML files.
     * @param {GetExportIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardExportGet(q?: GetExportIdsSchema, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardExportGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Check favorited dashboards for current user
     * @param {GetFavStarIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardFavoriteStatusGet(q?: GetFavStarIdsSchema, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardFavoriteStatusGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of dashboards, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardGet(q?: GetListSchema, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get the chart definitions for a given dashboard
     * @param {string} idOrSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardIdOrSlugChartsGet(idOrSlug: string, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardIdOrSlugChartsGet(idOrSlug, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Makes a copy of an existing dashboard
     * @param {DashboardCopySchema} body 
     * @param {string} idOrSlug The dashboard id or slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardIdOrSlugCopyPost(body: DashboardCopySchema, idOrSlug: string, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardIdOrSlugCopyPost(body, idOrSlug, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of a dashboard's datasets. Each dataset includes only the information necessary to render the dashboard's charts.
     * @param {string} idOrSlug Either the id of the dashboard, or its slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardIdOrSlugDatasetsGet(idOrSlug: string, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardIdOrSlugDatasetsGet(idOrSlug, options)(this.fetch, this.basePath);
    }

    /**
     * Removes a dashboard's embedded configuration.
     * @param {string} idOrSlug The dashboard id or slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardIdOrSlugEmbeddedDelete(idOrSlug: string, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardIdOrSlugEmbeddedDelete(idOrSlug, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the dashboard's embedded configuration
     * @param {string} idOrSlug The dashboard id or slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardIdOrSlugEmbeddedGet(idOrSlug: string, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardIdOrSlugEmbeddedGet(idOrSlug, options)(this.fetch, this.basePath);
    }

    /**
     * Sets a dashboard's embedded configuration.
     * @param {EmbeddedDashboardConfig} body The embedded configuration to set
     * @param {string} idOrSlug The dashboard id or slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardIdOrSlugEmbeddedPost(body: EmbeddedDashboardConfig, idOrSlug: string, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardIdOrSlugEmbeddedPost(body, idOrSlug, options)(this.fetch, this.basePath);
    }

    /**
     * Sets a dashboard's embedded configuration.
     * @param {EmbeddedDashboardConfig} body The embedded configuration to set
     * @param {string} idOrSlug The dashboard id or slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardIdOrSlugEmbeddedPut(body: EmbeddedDashboardConfig, idOrSlug: string, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardIdOrSlugEmbeddedPut(body, idOrSlug, options)(this.fetch, this.basePath);
    }

    /**
     * Get a dashboard detail information.
     * @param {string} idOrSlug Either the id of the dashboard, or its slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardIdOrSlugGet(idOrSlug: string, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardIdOrSlugGet(idOrSlug, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Blob} formData 
     * @param {boolean} overwrite 
     * @param {string} passwords 
     * @param {string} sshTunnelPasswords 
     * @param {string} sshTunnelPrivateKeyPasswords 
     * @param {string} sshTunnelPrivateKeys 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options)(this.fetch, this.basePath);
    }

    /**
     * Several metadata information about dashboard API endpoints.
     * @param {GetInfoSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardInfoGet(q?: GetInfoSchema, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardInfoGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Dashboard.
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardPkDelete(pk: number, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardPkDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Remove the dashboard from the user favorite list
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardPkFavoritesDelete(pk: number, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardPkFavoritesDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Marks the dashboard as favorite for the current user
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardPkFavoritesPost(pk: number, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardPkFavoritesPost(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Changes a Dashboard.
     * @param {DashboardRestApiPut} body Dashboard schema
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardPkPut(body: DashboardRestApiPut, pk: number, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardPkPut(body, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Compute async or get already computed dashboard thumbnail from cache.
     * @param {number} pk 
     * @param {string} digest A hex digest that makes this dashboard unique
     * @param {ThumbnailQuerySchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardPkThumbnailDigestGet(pk: number, digest: string, q?: ThumbnailQuerySchema, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardPkThumbnailDigestGet(pk, digest, q, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new Dashboard.
     * @param {DashboardRestApiPost} body Dashboard schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardPost(body: DashboardRestApiPost, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all possible owners for a dashboard.
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public apiV1DashboardRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return DashboardsApiFp(this.configuration).apiV1DashboardRelatedColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

}
/**
 * DatabaseApi - fetch parameter creator
 * @export
 */
export const DatabaseApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get names of databases currently available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseAvailableGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/database/available/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download database(s) and associated dataset(s) as a zip file
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseExportGet(q?: GetExportIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/database/export/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/database/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options: any = {}): FetchArgs {
            // verify required parameter 'formData' is not null or undefined
            if (formData === null || formData === undefined) {
                throw new RequiredError('formData','Required parameter formData was null or undefined when calling apiV1DatabaseImportPost.');
            }
            // verify required parameter 'overwrite' is not null or undefined
            if (overwrite === null || overwrite === undefined) {
                throw new RequiredError('overwrite','Required parameter overwrite was null or undefined when calling apiV1DatabaseImportPost.');
            }
            // verify required parameter 'passwords' is not null or undefined
            if (passwords === null || passwords === undefined) {
                throw new RequiredError('passwords','Required parameter passwords was null or undefined when calling apiV1DatabaseImportPost.');
            }
            // verify required parameter 'sshTunnelPasswords' is not null or undefined
            if (sshTunnelPasswords === null || sshTunnelPasswords === undefined) {
                throw new RequiredError('sshTunnelPasswords','Required parameter sshTunnelPasswords was null or undefined when calling apiV1DatabaseImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeyPasswords' is not null or undefined
            if (sshTunnelPrivateKeyPasswords === null || sshTunnelPrivateKeyPasswords === undefined) {
                throw new RequiredError('sshTunnelPrivateKeyPasswords','Required parameter sshTunnelPrivateKeyPasswords was null or undefined when calling apiV1DatabaseImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeys' is not null or undefined
            if (sshTunnelPrivateKeys === null || sshTunnelPrivateKeys === undefined) {
                throw new RequiredError('sshTunnelPrivateKeys','Required parameter sshTunnelPrivateKeys was null or undefined when calling apiV1DatabaseImportPost.');
            }
            const localVarPath = `/api/v1/database/import/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication jwt required

            if (formData !== undefined) {
                localVarFormParams.set('formData', formData as any);
            }

            if (overwrite !== undefined) {
                localVarFormParams.set('overwrite', overwrite as any);
            }

            if (passwords !== undefined) {
                localVarFormParams.set('passwords', passwords as any);
            }

            if (sshTunnelPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_passwords', sshTunnelPasswords as any);
            }

            if (sshTunnelPrivateKeyPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_key_passwords', sshTunnelPrivateKeyPasswords as any);
            }

            if (sshTunnelPrivateKeys !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_keys', sshTunnelPrivateKeys as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseInfoGet(q?: GetInfoSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/database/_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a database connection info
         * @param {number} pk The database id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkConnectionGet(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkConnectionGet.');
            }
            const localVarPath = `/api/v1/database/{pk}/connection`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Database.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkDelete.');
            }
            const localVarPath = `/api/v1/database/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get function names supported by a database
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkFunctionNamesGet(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkFunctionNamesGet.');
            }
            const localVarPath = `/api/v1/database/{pk}/function_names/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a database
         * @param {number} pk The database id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkGet(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkGet.');
            }
            const localVarPath = `/api/v1/database/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes a Database.
         * @param {DatabaseRestApiPut} body Database schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkPut(body: DatabaseRestApiPut, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatabasePkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkPut.');
            }
            const localVarPath = `/api/v1/database/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DatabaseRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get charts and dashboards count associated to a database
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkRelatedObjectsGet(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkRelatedObjectsGet.');
            }
            const localVarPath = `/api/v1/database/{pk}/related_objects/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The list of the database schemas where to upload information
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSchemasAccessForFileUploadGet(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkSchemasAccessForFileUploadGet.');
            }
            const localVarPath = `/api/v1/database/{pk}/schemas_access_for_file_upload/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all schemas from a database
         * @param {number} pk The database id
         * @param {DatabaseSchemasQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSchemasGet(pk: number, q?: DatabaseSchemasQuerySchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkSchemasGet.');
            }
            const localVarPath = `/api/v1/database/{pk}/schemas/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database select star for table
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSelectStarTableNameGet(pk: number, tableName: string, schemaName: string, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkSelectStarTableNameGet.');
            }
            // verify required parameter 'tableName' is not null or undefined
            if (tableName === null || tableName === undefined) {
                throw new RequiredError('tableName','Required parameter tableName was null or undefined when calling apiV1DatabasePkSelectStarTableNameGet.');
            }
            // verify required parameter 'schemaName' is not null or undefined
            if (schemaName === null || schemaName === undefined) {
                throw new RequiredError('schemaName','Required parameter schemaName was null or undefined when calling apiV1DatabasePkSelectStarTableNameGet.');
            }
            const localVarPath = `/api/v1/database/{pk}/select_star/{table_name}/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database select star for table
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSelectStarTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkSelectStarTableNameSchemaNameGet.');
            }
            // verify required parameter 'tableName' is not null or undefined
            if (tableName === null || tableName === undefined) {
                throw new RequiredError('tableName','Required parameter tableName was null or undefined when calling apiV1DatabasePkSelectStarTableNameSchemaNameGet.');
            }
            // verify required parameter 'schemaName' is not null or undefined
            if (schemaName === null || schemaName === undefined) {
                throw new RequiredError('schemaName','Required parameter schemaName was null or undefined when calling apiV1DatabasePkSelectStarTableNameSchemaNameGet.');
            }
            const localVarPath = `/api/v1/database/{pk}/select_star/{table_name}/{schema_name}/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a SSH Tunnel.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSshTunnelDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkSshTunnelDelete.');
            }
            const localVarPath = `/api/v1/database/{pk}/ssh_tunnel/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Response depends on each DB engine spec normally focused on partitions
         * @summary Get table extra metadata
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkTableExtraTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkTableExtraTableNameSchemaNameGet.');
            }
            // verify required parameter 'tableName' is not null or undefined
            if (tableName === null || tableName === undefined) {
                throw new RequiredError('tableName','Required parameter tableName was null or undefined when calling apiV1DatabasePkTableExtraTableNameSchemaNameGet.');
            }
            // verify required parameter 'schemaName' is not null or undefined
            if (schemaName === null || schemaName === undefined) {
                throw new RequiredError('schemaName','Required parameter schemaName was null or undefined when calling apiV1DatabasePkTableExtraTableNameSchemaNameGet.');
            }
            const localVarPath = `/api/v1/database/{pk}/table_extra/{table_name}/{schema_name}/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database table metadata
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkTableTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkTableTableNameSchemaNameGet.');
            }
            // verify required parameter 'tableName' is not null or undefined
            if (tableName === null || tableName === undefined) {
                throw new RequiredError('tableName','Required parameter tableName was null or undefined when calling apiV1DatabasePkTableTableNameSchemaNameGet.');
            }
            // verify required parameter 'schemaName' is not null or undefined
            if (schemaName === null || schemaName === undefined) {
                throw new RequiredError('schemaName','Required parameter schemaName was null or undefined when calling apiV1DatabasePkTableTableNameSchemaNameGet.');
            }
            const localVarPath = `/api/v1/database/{pk}/table/{table_name}/{schema_name}/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"table_name"}}`, encodeURIComponent(String(tableName)))
                .replace(`{${"schema_name"}}`, encodeURIComponent(String(schemaName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of tables for given database
         * @param {number} pk The database id
         * @param {DatabaseTablesQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkTablesGet(pk: number, q?: DatabaseTablesQuerySchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkTablesGet.');
            }
            const localVarPath = `/api/v1/database/{pk}/tables/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates arbitrary SQL.
         * @summary Validates that arbitrary sql is acceptable for the given database
         * @param {ValidateSQLRequest} body Validate SQL request
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkValidateSqlPost(body: ValidateSQLRequest, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatabasePkValidateSqlPost.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatabasePkValidateSqlPost.');
            }
            const localVarPath = `/api/v1/database/{pk}/validate_sql/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ValidateSQLRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Database.
         * @param {DatabaseRestApiPost} body Database schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePost(body: DatabaseRestApiPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatabasePost.');
            }
            const localVarPath = `/api/v1/database/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DatabaseRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests a database connection
         * @param {DatabaseTestConnectionSchema} body Database schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseTestConnectionPost(body: DatabaseTestConnectionSchema, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatabaseTestConnectionPost.');
            }
            const localVarPath = `/api/v1/database/test_connection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DatabaseTestConnectionSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates parameters used to connect to a database
         * @param {DatabaseValidateParametersSchema} body DB-specific parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseValidateParametersPost(body: DatabaseValidateParametersSchema, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatabaseValidateParametersPost.');
            }
            const localVarPath = `/api/v1/database/validate_parameters/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DatabaseValidateParametersSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseApi - functional programming interface
 * @export
 */
export const DatabaseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get names of databases currently available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseAvailableGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20030>> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabaseAvailableGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Download database(s) and associated dataset(s) as a zip file
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseExportGet(q?: GetExportIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabaseExportGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabaseGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabaseImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseInfoGet(q?: GetInfoSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabaseInfoGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a database connection info
         * @param {number} pk The database id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkConnectionGet(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DatabaseConnectionSchema> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkConnectionGet(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Database.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get function names supported by a database
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkFunctionNamesGet(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DatabaseFunctionNamesResponse> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkFunctionNamesGet(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a database
         * @param {number} pk The database id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkGet(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkGet(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Changes a Database.
         * @param {DatabaseRestApiPut} body Database schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkPut(body: DatabaseRestApiPut, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20031> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkPut(body, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get charts and dashboards count associated to a database
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkRelatedObjectsGet(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DatabaseRelatedObjectsResponse> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkRelatedObjectsGet(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary The list of the database schemas where to upload information
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSchemasAccessForFileUploadGet(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DatabaseSchemaAccessForFileUploadResponse> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkSchemasAccessForFileUploadGet(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all schemas from a database
         * @param {number} pk The database id
         * @param {DatabaseSchemasQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSchemasGet(pk: number, q?: DatabaseSchemasQuerySchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SchemasResponseSchema> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkSchemasGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get database select star for table
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSelectStarTableNameGet(pk: number, tableName: string, schemaName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SelectStarResponseSchema> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkSelectStarTableNameGet(pk, tableName, schemaName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get database select star for table
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSelectStarTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SelectStarResponseSchema> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkSelectStarTableNameSchemaNameGet(pk, tableName, schemaName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a SSH Tunnel.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSshTunnelDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkSshTunnelDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Response depends on each DB engine spec normally focused on partitions
         * @summary Get table extra metadata
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkTableExtraTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TableExtraMetadataResponseSchema> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkTableExtraTableNameSchemaNameGet(pk, tableName, schemaName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get database table metadata
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkTableTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TableMetadataResponseSchema> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkTableTableNameSchemaNameGet(pk, tableName, schemaName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of tables for given database
         * @param {number} pk The database id
         * @param {DatabaseTablesQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkTablesGet(pk: number, q?: DatabaseTablesQuerySchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20032> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkTablesGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validates arbitrary SQL.
         * @summary Validates that arbitrary sql is acceptable for the given database
         * @param {ValidateSQLRequest} body Validate SQL request
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkValidateSqlPost(body: ValidateSQLRequest, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20033> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePkValidateSqlPost(body, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Database.
         * @param {DatabaseRestApiPost} body Database schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePost(body: DatabaseRestApiPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2018> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabasePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Tests a database connection
         * @param {DatabaseTestConnectionSchema} body Database schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseTestConnectionPost(body: DatabaseTestConnectionSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabaseTestConnectionPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validates parameters used to connect to a database
         * @param {DatabaseValidateParametersSchema} body DB-specific parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseValidateParametersPost(body: DatabaseValidateParametersSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DatabaseApiFetchParamCreator(configuration).apiV1DatabaseValidateParametersPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DatabaseApi - factory interface
 * @export
 */
export const DatabaseApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get names of databases currently available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseAvailableGet(options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabaseAvailableGet(options)(fetch, basePath);
        },
        /**
         * Download database(s) and associated dataset(s) as a zip file
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseExportGet(q?: GetExportIdsSchema, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabaseExportGet(q, options)(fetch, basePath);
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseGet(q?: GetListSchema, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabaseGet(q, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabaseImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options)(fetch, basePath);
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseInfoGet(q?: GetInfoSchema, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabaseInfoGet(q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a database connection info
         * @param {number} pk The database id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkConnectionGet(pk: number, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkConnectionGet(pk, options)(fetch, basePath);
        },
        /**
         * Deletes a Database.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkDelete(pk: number, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkDelete(pk, options)(fetch, basePath);
        },
        /**
         * Get function names supported by a database
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkFunctionNamesGet(pk: number, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkFunctionNamesGet(pk, options)(fetch, basePath);
        },
        /**
         * Get a database
         * @param {number} pk The database id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkGet(pk: number, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkGet(pk, options)(fetch, basePath);
        },
        /**
         * Changes a Database.
         * @param {DatabaseRestApiPut} body Database schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkPut(body: DatabaseRestApiPut, pk: number, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkPut(body, pk, options)(fetch, basePath);
        },
        /**
         * Get charts and dashboards count associated to a database
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkRelatedObjectsGet(pk: number, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkRelatedObjectsGet(pk, options)(fetch, basePath);
        },
        /**
         * 
         * @summary The list of the database schemas where to upload information
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSchemasAccessForFileUploadGet(pk: number, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkSchemasAccessForFileUploadGet(pk, options)(fetch, basePath);
        },
        /**
         * Get all schemas from a database
         * @param {number} pk The database id
         * @param {DatabaseSchemasQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSchemasGet(pk: number, q?: DatabaseSchemasQuerySchema, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkSchemasGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Get database select star for table
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSelectStarTableNameGet(pk: number, tableName: string, schemaName: string, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkSelectStarTableNameGet(pk, tableName, schemaName, options)(fetch, basePath);
        },
        /**
         * Get database select star for table
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSelectStarTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkSelectStarTableNameSchemaNameGet(pk, tableName, schemaName, options)(fetch, basePath);
        },
        /**
         * Deletes a SSH Tunnel.
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkSshTunnelDelete(pk: number, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkSshTunnelDelete(pk, options)(fetch, basePath);
        },
        /**
         * Response depends on each DB engine spec normally focused on partitions
         * @summary Get table extra metadata
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkTableExtraTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkTableExtraTableNameSchemaNameGet(pk, tableName, schemaName, options)(fetch, basePath);
        },
        /**
         * Get database table metadata
         * @param {number} pk The database id
         * @param {string} tableName Table name
         * @param {string} schemaName Table schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkTableTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkTableTableNameSchemaNameGet(pk, tableName, schemaName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of tables for given database
         * @param {number} pk The database id
         * @param {DatabaseTablesQuerySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkTablesGet(pk: number, q?: DatabaseTablesQuerySchema, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkTablesGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Validates arbitrary SQL.
         * @summary Validates that arbitrary sql is acceptable for the given database
         * @param {ValidateSQLRequest} body Validate SQL request
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePkValidateSqlPost(body: ValidateSQLRequest, pk: number, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePkValidateSqlPost(body, pk, options)(fetch, basePath);
        },
        /**
         * Create a new Database.
         * @param {DatabaseRestApiPost} body Database schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabasePost(body: DatabaseRestApiPost, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabasePost(body, options)(fetch, basePath);
        },
        /**
         * Tests a database connection
         * @param {DatabaseTestConnectionSchema} body Database schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseTestConnectionPost(body: DatabaseTestConnectionSchema, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabaseTestConnectionPost(body, options)(fetch, basePath);
        },
        /**
         * Validates parameters used to connect to a database
         * @param {DatabaseValidateParametersSchema} body DB-specific parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatabaseValidateParametersPost(body: DatabaseValidateParametersSchema, options?: any) {
            return DatabaseApiFp(configuration).apiV1DatabaseValidateParametersPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * DatabaseApi - object-oriented interface
 * @export
 * @class DatabaseApi
 * @extends {BaseAPI}
 */
export class DatabaseApi extends BaseAPI {
    /**
     * Get names of databases currently available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabaseAvailableGet(options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabaseAvailableGet(options)(this.fetch, this.basePath);
    }

    /**
     * Download database(s) and associated dataset(s) as a zip file
     * @param {GetExportIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabaseExportGet(q?: GetExportIdsSchema, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabaseExportGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of models
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabaseGet(q?: GetListSchema, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabaseGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Blob} formData 
     * @param {boolean} overwrite 
     * @param {string} passwords 
     * @param {string} sshTunnelPasswords 
     * @param {string} sshTunnelPrivateKeyPasswords 
     * @param {string} sshTunnelPrivateKeys 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabaseImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabaseImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options)(this.fetch, this.basePath);
    }

    /**
     * Get metadata information about this API resource
     * @param {GetInfoSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabaseInfoGet(q?: GetInfoSchema, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabaseInfoGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a database connection info
     * @param {number} pk The database id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkConnectionGet(pk: number, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkConnectionGet(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Database.
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkDelete(pk: number, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get function names supported by a database
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkFunctionNamesGet(pk: number, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkFunctionNamesGet(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get a database
     * @param {number} pk The database id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkGet(pk: number, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkGet(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Changes a Database.
     * @param {DatabaseRestApiPut} body Database schema
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkPut(body: DatabaseRestApiPut, pk: number, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkPut(body, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get charts and dashboards count associated to a database
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkRelatedObjectsGet(pk: number, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkRelatedObjectsGet(pk, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary The list of the database schemas where to upload information
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkSchemasAccessForFileUploadGet(pk: number, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkSchemasAccessForFileUploadGet(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get all schemas from a database
     * @param {number} pk The database id
     * @param {DatabaseSchemasQuerySchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkSchemasGet(pk: number, q?: DatabaseSchemasQuerySchema, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkSchemasGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Get database select star for table
     * @param {number} pk The database id
     * @param {string} tableName Table name
     * @param {string} schemaName Table schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkSelectStarTableNameGet(pk: number, tableName: string, schemaName: string, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkSelectStarTableNameGet(pk, tableName, schemaName, options)(this.fetch, this.basePath);
    }

    /**
     * Get database select star for table
     * @param {number} pk The database id
     * @param {string} tableName Table name
     * @param {string} schemaName Table schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkSelectStarTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkSelectStarTableNameSchemaNameGet(pk, tableName, schemaName, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a SSH Tunnel.
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkSshTunnelDelete(pk: number, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkSshTunnelDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Response depends on each DB engine spec normally focused on partitions
     * @summary Get table extra metadata
     * @param {number} pk The database id
     * @param {string} tableName Table name
     * @param {string} schemaName Table schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkTableExtraTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkTableExtraTableNameSchemaNameGet(pk, tableName, schemaName, options)(this.fetch, this.basePath);
    }

    /**
     * Get database table metadata
     * @param {number} pk The database id
     * @param {string} tableName Table name
     * @param {string} schemaName Table schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkTableTableNameSchemaNameGet(pk: number, tableName: string, schemaName: string, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkTableTableNameSchemaNameGet(pk, tableName, schemaName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of tables for given database
     * @param {number} pk The database id
     * @param {DatabaseTablesQuerySchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkTablesGet(pk: number, q?: DatabaseTablesQuerySchema, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkTablesGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Validates arbitrary SQL.
     * @summary Validates that arbitrary sql is acceptable for the given database
     * @param {ValidateSQLRequest} body Validate SQL request
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePkValidateSqlPost(body: ValidateSQLRequest, pk: number, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePkValidateSqlPost(body, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new Database.
     * @param {DatabaseRestApiPost} body Database schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabasePost(body: DatabaseRestApiPost, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabasePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Tests a database connection
     * @param {DatabaseTestConnectionSchema} body Database schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabaseTestConnectionPost(body: DatabaseTestConnectionSchema, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabaseTestConnectionPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Validates parameters used to connect to a database
     * @param {DatabaseValidateParametersSchema} body DB-specific parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseApi
     */
    public apiV1DatabaseValidateParametersPost(body: DatabaseValidateParametersSchema, options?: any) {
        return DatabaseApiFp(this.configuration).apiV1DatabaseValidateParametersPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * DatasetsApi - fetch parameter creator
 * @export
 */
export const DatasetsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes multiple Datasets in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDelete(q?: GetDeleteIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/dataset/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1DatasetDistinctColumnNameGet.');
            }
            const localVarPath = `/api/v1/dataset/distinct/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicates a Dataset
         * @param {DatasetDuplicateSchema} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDuplicatePost(body: DatasetDuplicateSchema, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatasetDuplicatePost.');
            }
            const localVarPath = `/api/v1/dataset/duplicate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DatasetDuplicateSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports multiple datasets and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetExportGet(q?: GetExportIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/dataset/export/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/dataset/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a table by name, or create it if it does not exist
         * @param {GetOrCreateDatasetSchema} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetGetOrCreatePost(body: GetOrCreateDatasetSchema, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatasetGetOrCreatePost.');
            }
            const localVarPath = `/api/v1/dataset/get_or_create/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetOrCreateDatasetSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {boolean} syncColumns 
         * @param {boolean} syncMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, syncColumns: boolean, syncMetrics: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'formData' is not null or undefined
            if (formData === null || formData === undefined) {
                throw new RequiredError('formData','Required parameter formData was null or undefined when calling apiV1DatasetImportPost.');
            }
            // verify required parameter 'overwrite' is not null or undefined
            if (overwrite === null || overwrite === undefined) {
                throw new RequiredError('overwrite','Required parameter overwrite was null or undefined when calling apiV1DatasetImportPost.');
            }
            // verify required parameter 'passwords' is not null or undefined
            if (passwords === null || passwords === undefined) {
                throw new RequiredError('passwords','Required parameter passwords was null or undefined when calling apiV1DatasetImportPost.');
            }
            // verify required parameter 'sshTunnelPasswords' is not null or undefined
            if (sshTunnelPasswords === null || sshTunnelPasswords === undefined) {
                throw new RequiredError('sshTunnelPasswords','Required parameter sshTunnelPasswords was null or undefined when calling apiV1DatasetImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeyPasswords' is not null or undefined
            if (sshTunnelPrivateKeyPasswords === null || sshTunnelPrivateKeyPasswords === undefined) {
                throw new RequiredError('sshTunnelPrivateKeyPasswords','Required parameter sshTunnelPrivateKeyPasswords was null or undefined when calling apiV1DatasetImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeys' is not null or undefined
            if (sshTunnelPrivateKeys === null || sshTunnelPrivateKeys === undefined) {
                throw new RequiredError('sshTunnelPrivateKeys','Required parameter sshTunnelPrivateKeys was null or undefined when calling apiV1DatasetImportPost.');
            }
            // verify required parameter 'syncColumns' is not null or undefined
            if (syncColumns === null || syncColumns === undefined) {
                throw new RequiredError('syncColumns','Required parameter syncColumns was null or undefined when calling apiV1DatasetImportPost.');
            }
            // verify required parameter 'syncMetrics' is not null or undefined
            if (syncMetrics === null || syncMetrics === undefined) {
                throw new RequiredError('syncMetrics','Required parameter syncMetrics was null or undefined when calling apiV1DatasetImportPost.');
            }
            const localVarPath = `/api/v1/dataset/import/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication jwt required

            if (formData !== undefined) {
                localVarFormParams.set('formData', formData as any);
            }

            if (overwrite !== undefined) {
                localVarFormParams.set('overwrite', overwrite as any);
            }

            if (passwords !== undefined) {
                localVarFormParams.set('passwords', passwords as any);
            }

            if (sshTunnelPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_passwords', sshTunnelPasswords as any);
            }

            if (sshTunnelPrivateKeyPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_key_passwords', sshTunnelPrivateKeyPasswords as any);
            }

            if (sshTunnelPrivateKeys !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_keys', sshTunnelPrivateKeys as any);
            }

            if (syncColumns !== undefined) {
                localVarFormParams.set('sync_columns', syncColumns as any);
            }

            if (syncMetrics !== undefined) {
                localVarFormParams.set('sync_metrics', syncMetrics as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetInfoGet(q?: GetInfoSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/dataset/_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Dataset column
         * @param {number} pk The dataset pk for this column
         * @param {number} columnId The column id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkColumnColumnIdDelete(pk: number, columnId: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkColumnColumnIdDelete.');
            }
            // verify required parameter 'columnId' is not null or undefined
            if (columnId === null || columnId === undefined) {
                throw new RequiredError('columnId','Required parameter columnId was null or undefined when calling apiV1DatasetPkColumnColumnIdDelete.');
            }
            const localVarPath = `/api/v1/dataset/{pk}/column/{column_id}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"column_id"}}`, encodeURIComponent(String(columnId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkDelete.');
            }
            const localVarPath = `/api/v1/dataset/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkGet(pk: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkGet.');
            }
            const localVarPath = `/api/v1/dataset/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Dataset metric
         * @param {number} pk The dataset pk for this column
         * @param {number} metricId The metric id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkMetricMetricIdDelete(pk: number, metricId: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkMetricMetricIdDelete.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling apiV1DatasetPkMetricMetricIdDelete.');
            }
            const localVarPath = `/api/v1/dataset/{pk}/metric/{metric_id}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"metric_id"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes a Dataset
         * @param {DatasetRestApiPut} body Dataset schema
         * @param {number} pk 
         * @param {boolean} [overrideColumns] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkPut(body: DatasetRestApiPut, pk: number, overrideColumns?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatasetPkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkPut.');
            }
            const localVarPath = `/api/v1/dataset/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (overrideColumns !== undefined) {
                localVarQueryParameter['override_columns'] = overrideColumns;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DatasetRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refreshes and updates columns of a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkRefreshPut(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkRefreshPut.');
            }
            const localVarPath = `/api/v1/dataset/{pk}/refresh`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get charts and dashboards count associated to a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkRelatedObjectsGet(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DatasetPkRelatedObjectsGet.');
            }
            const localVarPath = `/api/v1/dataset/{pk}/related_objects`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Dataset
         * @param {DatasetRestApiPost} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPost(body: DatasetRestApiPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DatasetPost.');
            }
            const localVarPath = `/api/v1/dataset/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DatasetRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1DatasetRelatedColumnNameGet.');
            }
            const localVarPath = `/api/v1/dataset/related/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetsApi - functional programming interface
 * @export
 */
export const DatasetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes multiple Datasets in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDelete(q?: GetDeleteIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetDelete(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DistincResponseSchema> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetDistinctColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Duplicates a Dataset
         * @param {DatasetDuplicateSchema} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDuplicatePost(body: DatasetDuplicateSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20110> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetDuplicatePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Exports multiple datasets and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetExportGet(q?: GetExportIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetExportGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20034> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieve a table by name, or create it if it does not exist
         * @param {GetOrCreateDatasetSchema} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetGetOrCreatePost(body: GetOrCreateDatasetSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20035> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetGetOrCreatePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {boolean} syncColumns 
         * @param {boolean} syncMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, syncColumns: boolean, syncMetrics: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, syncColumns, syncMetrics, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetInfoGet(q?: GetInfoSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetInfoGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a Dataset column
         * @param {number} pk The dataset pk for this column
         * @param {number} columnId The column id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkColumnColumnIdDelete(pk: number, columnId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetPkColumnColumnIdDelete(pk, columnId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetPkDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkGet(pk: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20036> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetPkGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a Dataset metric
         * @param {number} pk The dataset pk for this column
         * @param {number} metricId The metric id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkMetricMetricIdDelete(pk: number, metricId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetPkMetricMetricIdDelete(pk, metricId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Changes a Dataset
         * @param {DatasetRestApiPut} body Dataset schema
         * @param {number} pk 
         * @param {boolean} [overrideColumns] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkPut(body: DatasetRestApiPut, pk: number, overrideColumns?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20037> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetPkPut(body, pk, overrideColumns, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Refreshes and updates columns of a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkRefreshPut(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetPkRefreshPut(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get charts and dashboards count associated to a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkRelatedObjectsGet(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DatasetRelatedObjectsResponse> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetPkRelatedObjectsGet(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Dataset
         * @param {DatasetRestApiPost} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPost(body: DatasetRestApiPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2019> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RelatedResponseSchema> {
            const localVarFetchArgs = DatasetsApiFetchParamCreator(configuration).apiV1DatasetRelatedColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DatasetsApi - factory interface
 * @export
 */
export const DatasetsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes multiple Datasets in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDelete(q?: GetDeleteIdsSchema, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetDelete(q, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetDistinctColumnNameGet(columnName, q, options)(fetch, basePath);
        },
        /**
         * Duplicates a Dataset
         * @param {DatasetDuplicateSchema} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetDuplicatePost(body: DatasetDuplicateSchema, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetDuplicatePost(body, options)(fetch, basePath);
        },
        /**
         * Exports multiple datasets and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetExportGet(q?: GetExportIdsSchema, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetExportGet(q, options)(fetch, basePath);
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetGet(q?: GetListSchema, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetGet(q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve a table by name, or create it if it does not exist
         * @param {GetOrCreateDatasetSchema} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetGetOrCreatePost(body: GetOrCreateDatasetSchema, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetGetOrCreatePost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {boolean} syncColumns 
         * @param {boolean} syncMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, syncColumns: boolean, syncMetrics: boolean, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, syncColumns, syncMetrics, options)(fetch, basePath);
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetInfoGet(q?: GetInfoSchema, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetInfoGet(q, options)(fetch, basePath);
        },
        /**
         * Delete a Dataset column
         * @param {number} pk The dataset pk for this column
         * @param {number} columnId The column id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkColumnColumnIdDelete(pk: number, columnId: number, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetPkColumnColumnIdDelete(pk, columnId, options)(fetch, basePath);
        },
        /**
         * Deletes a Dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkDelete(pk: number, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetPkDelete(pk, options)(fetch, basePath);
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkGet(pk: number, q?: GetItemSchema, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetPkGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Delete a Dataset metric
         * @param {number} pk The dataset pk for this column
         * @param {number} metricId The metric id for this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkMetricMetricIdDelete(pk: number, metricId: number, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetPkMetricMetricIdDelete(pk, metricId, options)(fetch, basePath);
        },
        /**
         * Changes a Dataset
         * @param {DatasetRestApiPut} body Dataset schema
         * @param {number} pk 
         * @param {boolean} [overrideColumns] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkPut(body: DatasetRestApiPut, pk: number, overrideColumns?: boolean, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetPkPut(body, pk, overrideColumns, options)(fetch, basePath);
        },
        /**
         * Refreshes and updates columns of a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkRefreshPut(pk: number, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetPkRefreshPut(pk, options)(fetch, basePath);
        },
        /**
         * Get charts and dashboards count associated to a dataset
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPkRelatedObjectsGet(pk: number, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetPkRelatedObjectsGet(pk, options)(fetch, basePath);
        },
        /**
         * Create a new Dataset
         * @param {DatasetRestApiPost} body Dataset schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetPost(body: DatasetRestApiPost, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasetRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return DatasetsApiFp(configuration).apiV1DatasetRelatedColumnNameGet(columnName, q, options)(fetch, basePath);
        },
    };
};

/**
 * DatasetsApi - object-oriented interface
 * @export
 * @class DatasetsApi
 * @extends {BaseAPI}
 */
export class DatasetsApi extends BaseAPI {
    /**
     * Deletes multiple Datasets in a bulk operation.
     * @param {GetDeleteIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetDelete(q?: GetDeleteIdsSchema, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetDelete(q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetDistinctColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

    /**
     * Duplicates a Dataset
     * @param {DatasetDuplicateSchema} body Dataset schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetDuplicatePost(body: DatasetDuplicateSchema, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetDuplicatePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Exports multiple datasets and downloads them as YAML files
     * @param {GetExportIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetExportGet(q?: GetExportIdsSchema, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetExportGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of models
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetGet(q?: GetListSchema, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve a table by name, or create it if it does not exist
     * @param {GetOrCreateDatasetSchema} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetGetOrCreatePost(body: GetOrCreateDatasetSchema, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetGetOrCreatePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Blob} formData 
     * @param {boolean} overwrite 
     * @param {string} passwords 
     * @param {string} sshTunnelPasswords 
     * @param {string} sshTunnelPrivateKeyPasswords 
     * @param {string} sshTunnelPrivateKeys 
     * @param {boolean} syncColumns 
     * @param {boolean} syncMetrics 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, syncColumns: boolean, syncMetrics: boolean, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, syncColumns, syncMetrics, options)(this.fetch, this.basePath);
    }

    /**
     * Get metadata information about this API resource
     * @param {GetInfoSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetInfoGet(q?: GetInfoSchema, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetInfoGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a Dataset column
     * @param {number} pk The dataset pk for this column
     * @param {number} columnId The column id for this dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetPkColumnColumnIdDelete(pk: number, columnId: number, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkColumnColumnIdDelete(pk, columnId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Dataset
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetPkDelete(pk: number, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get an item model
     * @param {number} pk 
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetPkGet(pk: number, q?: GetItemSchema, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a Dataset metric
     * @param {number} pk The dataset pk for this column
     * @param {number} metricId The metric id for this dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetPkMetricMetricIdDelete(pk: number, metricId: number, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkMetricMetricIdDelete(pk, metricId, options)(this.fetch, this.basePath);
    }

    /**
     * Changes a Dataset
     * @param {DatasetRestApiPut} body Dataset schema
     * @param {number} pk 
     * @param {boolean} [overrideColumns] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetPkPut(body: DatasetRestApiPut, pk: number, overrideColumns?: boolean, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkPut(body, pk, overrideColumns, options)(this.fetch, this.basePath);
    }

    /**
     * Refreshes and updates columns of a dataset
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetPkRefreshPut(pk: number, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkRefreshPut(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get charts and dashboards count associated to a dataset
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetPkRelatedObjectsGet(pk: number, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetPkRelatedObjectsGet(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new Dataset
     * @param {DatasetRestApiPost} body Dataset schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetPost(body: DatasetRestApiPost, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public apiV1DatasetRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return DatasetsApiFp(this.configuration).apiV1DatasetRelatedColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

}
/**
 * DatasourcesApi - fetch parameter creator
 * @export
 */
export const DatasourcesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get possible values for a datasource column
         * @param {string} datasourceType The type of datasource
         * @param {number} datasourceId The id of the datasource
         * @param {string} columnName The name of the column to get values for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasourceDatasourceTypeDatasourceIdColumnColumnNameValuesGet(datasourceType: string, datasourceId: number, columnName: string, options: any = {}): FetchArgs {
            // verify required parameter 'datasourceType' is not null or undefined
            if (datasourceType === null || datasourceType === undefined) {
                throw new RequiredError('datasourceType','Required parameter datasourceType was null or undefined when calling apiV1DatasourceDatasourceTypeDatasourceIdColumnColumnNameValuesGet.');
            }
            // verify required parameter 'datasourceId' is not null or undefined
            if (datasourceId === null || datasourceId === undefined) {
                throw new RequiredError('datasourceId','Required parameter datasourceId was null or undefined when calling apiV1DatasourceDatasourceTypeDatasourceIdColumnColumnNameValuesGet.');
            }
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1DatasourceDatasourceTypeDatasourceIdColumnColumnNameValuesGet.');
            }
            const localVarPath = `/api/v1/datasource/{datasource_type}/{datasource_id}/column/{column_name}/values/`
                .replace(`{${"datasource_type"}}`, encodeURIComponent(String(datasourceType)))
                .replace(`{${"datasource_id"}}`, encodeURIComponent(String(datasourceId)))
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasourcesApi - functional programming interface
 * @export
 */
export const DatasourcesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get possible values for a datasource column
         * @param {string} datasourceType The type of datasource
         * @param {number} datasourceId The id of the datasource
         * @param {string} columnName The name of the column to get values for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasourceDatasourceTypeDatasourceIdColumnColumnNameValuesGet(datasourceType: string, datasourceId: number, columnName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20038> {
            const localVarFetchArgs = DatasourcesApiFetchParamCreator(configuration).apiV1DatasourceDatasourceTypeDatasourceIdColumnColumnNameValuesGet(datasourceType, datasourceId, columnName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DatasourcesApi - factory interface
 * @export
 */
export const DatasourcesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get possible values for a datasource column
         * @param {string} datasourceType The type of datasource
         * @param {number} datasourceId The id of the datasource
         * @param {string} columnName The name of the column to get values for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DatasourceDatasourceTypeDatasourceIdColumnColumnNameValuesGet(datasourceType: string, datasourceId: number, columnName: string, options?: any) {
            return DatasourcesApiFp(configuration).apiV1DatasourceDatasourceTypeDatasourceIdColumnColumnNameValuesGet(datasourceType, datasourceId, columnName, options)(fetch, basePath);
        },
    };
};

/**
 * DatasourcesApi - object-oriented interface
 * @export
 * @class DatasourcesApi
 * @extends {BaseAPI}
 */
export class DatasourcesApi extends BaseAPI {
    /**
     * 
     * @summary Get possible values for a datasource column
     * @param {string} datasourceType The type of datasource
     * @param {number} datasourceId The id of the datasource
     * @param {string} columnName The name of the column to get values for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public apiV1DatasourceDatasourceTypeDatasourceIdColumnColumnNameValuesGet(datasourceType: string, datasourceId: number, columnName: string, options?: any) {
        return DatasourcesApiFp(this.configuration).apiV1DatasourceDatasourceTypeDatasourceIdColumnColumnNameValuesGet(datasourceType, datasourceId, columnName, options)(this.fetch, this.basePath);
    }

}
/**
 * EmbeddedDashboardApi - fetch parameter creator
 * @export
 */
export const EmbeddedDashboardApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a report schedule log
         * @param {string} uuid The embedded configuration uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1EmbeddedDashboardUuidGet(uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling apiV1EmbeddedDashboardUuidGet.');
            }
            const localVarPath = `/api/v1/embedded_dashboard/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmbeddedDashboardApi - functional programming interface
 * @export
 */
export const EmbeddedDashboardApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a report schedule log
         * @param {string} uuid The embedded configuration uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1EmbeddedDashboardUuidGet(uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20025> {
            const localVarFetchArgs = EmbeddedDashboardApiFetchParamCreator(configuration).apiV1EmbeddedDashboardUuidGet(uuid, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmbeddedDashboardApi - factory interface
 * @export
 */
export const EmbeddedDashboardApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a report schedule log
         * @param {string} uuid The embedded configuration uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1EmbeddedDashboardUuidGet(uuid: string, options?: any) {
            return EmbeddedDashboardApiFp(configuration).apiV1EmbeddedDashboardUuidGet(uuid, options)(fetch, basePath);
        },
    };
};

/**
 * EmbeddedDashboardApi - object-oriented interface
 * @export
 * @class EmbeddedDashboardApi
 * @extends {BaseAPI}
 */
export class EmbeddedDashboardApi extends BaseAPI {
    /**
     * Get a report schedule log
     * @param {string} uuid The embedded configuration uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedDashboardApi
     */
    public apiV1EmbeddedDashboardUuidGet(uuid: string, options?: any) {
        return EmbeddedDashboardApiFp(this.configuration).apiV1EmbeddedDashboardUuidGet(uuid, options)(this.fetch, this.basePath);
    }

}
/**
 * ExploreApi - fetch parameter creator
 * @export
 */
export const ExploreApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assembles Explore related information (form_data, slice, dataset)\\n in a single endpoint.<br/><br/>\\nThe information can be assembled from:<br/> - The cache using a form_data_key<br/> - The metadata database using a permalink_key<br/> - Build from scratch using dataset or slice identifiers.
         * @summary Assembles Explore related information (form_data, slice, dataset)\\n in a single endpoint.
         * @param {string} [formDataKey] 
         * @param {string} [permalinkKey] 
         * @param {number} [sliceId] 
         * @param {number} [datasourceId] 
         * @param {string} [datasourceType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreGet(formDataKey?: string, permalinkKey?: string, sliceId?: number, datasourceId?: number, datasourceType?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/explore/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (formDataKey !== undefined) {
                localVarQueryParameter['form_data_key'] = formDataKey;
            }

            if (permalinkKey !== undefined) {
                localVarQueryParameter['permalink_key'] = permalinkKey;
            }

            if (sliceId !== undefined) {
                localVarQueryParameter['slice_id'] = sliceId;
            }

            if (datasourceId !== undefined) {
                localVarQueryParameter['datasource_id'] = datasourceId;
            }

            if (datasourceType !== undefined) {
                localVarQueryParameter['datasource_type'] = datasourceType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExploreApi - functional programming interface
 * @export
 */
export const ExploreApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Assembles Explore related information (form_data, slice, dataset)\\n in a single endpoint.<br/><br/>\\nThe information can be assembled from:<br/> - The cache using a form_data_key<br/> - The metadata database using a permalink_key<br/> - Build from scratch using dataset or slice identifiers.
         * @summary Assembles Explore related information (form_data, slice, dataset)\\n in a single endpoint.
         * @param {string} [formDataKey] 
         * @param {string} [permalinkKey] 
         * @param {number} [sliceId] 
         * @param {number} [datasourceId] 
         * @param {string} [datasourceType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreGet(formDataKey?: string, permalinkKey?: string, sliceId?: number, datasourceId?: number, datasourceType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExploreContextSchema> {
            const localVarFetchArgs = ExploreApiFetchParamCreator(configuration).apiV1ExploreGet(formDataKey, permalinkKey, sliceId, datasourceId, datasourceType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExploreApi - factory interface
 * @export
 */
export const ExploreApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Assembles Explore related information (form_data, slice, dataset)\\n in a single endpoint.<br/><br/>\\nThe information can be assembled from:<br/> - The cache using a form_data_key<br/> - The metadata database using a permalink_key<br/> - Build from scratch using dataset or slice identifiers.
         * @summary Assembles Explore related information (form_data, slice, dataset)\\n in a single endpoint.
         * @param {string} [formDataKey] 
         * @param {string} [permalinkKey] 
         * @param {number} [sliceId] 
         * @param {number} [datasourceId] 
         * @param {string} [datasourceType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreGet(formDataKey?: string, permalinkKey?: string, sliceId?: number, datasourceId?: number, datasourceType?: string, options?: any) {
            return ExploreApiFp(configuration).apiV1ExploreGet(formDataKey, permalinkKey, sliceId, datasourceId, datasourceType, options)(fetch, basePath);
        },
    };
};

/**
 * ExploreApi - object-oriented interface
 * @export
 * @class ExploreApi
 * @extends {BaseAPI}
 */
export class ExploreApi extends BaseAPI {
    /**
     * Assembles Explore related information (form_data, slice, dataset)\\n in a single endpoint.<br/><br/>\\nThe information can be assembled from:<br/> - The cache using a form_data_key<br/> - The metadata database using a permalink_key<br/> - Build from scratch using dataset or slice identifiers.
     * @summary Assembles Explore related information (form_data, slice, dataset)\\n in a single endpoint.
     * @param {string} [formDataKey] 
     * @param {string} [permalinkKey] 
     * @param {number} [sliceId] 
     * @param {number} [datasourceId] 
     * @param {string} [datasourceType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploreApi
     */
    public apiV1ExploreGet(formDataKey?: string, permalinkKey?: string, sliceId?: number, datasourceId?: number, datasourceType?: string, options?: any) {
        return ExploreApiFp(this.configuration).apiV1ExploreGet(formDataKey, permalinkKey, sliceId, datasourceId, datasourceType, options)(this.fetch, this.basePath);
    }

}
/**
 * ExploreFormDataApi - fetch parameter creator
 * @export
 */
export const ExploreFormDataApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a form_data.
         * @param {string} key The form_data key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataKeyDelete(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling apiV1ExploreFormDataKeyDelete.');
            }
            const localVarPath = `/api/v1/explore/form_data/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrives a form_data.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataKeyGet(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling apiV1ExploreFormDataKeyGet.');
            }
            const localVarPath = `/api/v1/explore/form_data/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing form_data.
         * @param {FormDataPutSchema} body 
         * @param {string} key 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataKeyPut(body: FormDataPutSchema, key: string, tabId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1ExploreFormDataKeyPut.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling apiV1ExploreFormDataKeyPut.');
            }
            const localVarPath = `/api/v1/explore/form_data/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (tabId !== undefined) {
                localVarQueryParameter['tab_id'] = tabId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FormDataPutSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores a new form_data.
         * @param {FormDataPostSchema} body 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataPost(body: FormDataPostSchema, tabId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1ExploreFormDataPost.');
            }
            const localVarPath = `/api/v1/explore/form_data`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (tabId !== undefined) {
                localVarQueryParameter['tab_id'] = tabId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FormDataPostSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExploreFormDataApi - functional programming interface
 * @export
 */
export const ExploreFormDataApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a form_data.
         * @param {string} key The form_data key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataKeyDelete(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20028> {
            const localVarFetchArgs = ExploreFormDataApiFetchParamCreator(configuration).apiV1ExploreFormDataKeyDelete(key, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrives a form_data.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataKeyGet(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20039> {
            const localVarFetchArgs = ExploreFormDataApiFetchParamCreator(configuration).apiV1ExploreFormDataKeyGet(key, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an existing form_data.
         * @param {FormDataPutSchema} body 
         * @param {string} key 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataKeyPut(body: FormDataPutSchema, key: string, tabId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20111> {
            const localVarFetchArgs = ExploreFormDataApiFetchParamCreator(configuration).apiV1ExploreFormDataKeyPut(body, key, tabId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stores a new form_data.
         * @param {FormDataPostSchema} body 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataPost(body: FormDataPostSchema, tabId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20111> {
            const localVarFetchArgs = ExploreFormDataApiFetchParamCreator(configuration).apiV1ExploreFormDataPost(body, tabId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExploreFormDataApi - factory interface
 * @export
 */
export const ExploreFormDataApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes a form_data.
         * @param {string} key The form_data key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataKeyDelete(key: string, options?: any) {
            return ExploreFormDataApiFp(configuration).apiV1ExploreFormDataKeyDelete(key, options)(fetch, basePath);
        },
        /**
         * Retrives a form_data.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataKeyGet(key: string, options?: any) {
            return ExploreFormDataApiFp(configuration).apiV1ExploreFormDataKeyGet(key, options)(fetch, basePath);
        },
        /**
         * Updates an existing form_data.
         * @param {FormDataPutSchema} body 
         * @param {string} key 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataKeyPut(body: FormDataPutSchema, key: string, tabId?: number, options?: any) {
            return ExploreFormDataApiFp(configuration).apiV1ExploreFormDataKeyPut(body, key, tabId, options)(fetch, basePath);
        },
        /**
         * Stores a new form_data.
         * @param {FormDataPostSchema} body 
         * @param {number} [tabId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExploreFormDataPost(body: FormDataPostSchema, tabId?: number, options?: any) {
            return ExploreFormDataApiFp(configuration).apiV1ExploreFormDataPost(body, tabId, options)(fetch, basePath);
        },
    };
};

/**
 * ExploreFormDataApi - object-oriented interface
 * @export
 * @class ExploreFormDataApi
 * @extends {BaseAPI}
 */
export class ExploreFormDataApi extends BaseAPI {
    /**
     * Deletes a form_data.
     * @param {string} key The form_data key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploreFormDataApi
     */
    public apiV1ExploreFormDataKeyDelete(key: string, options?: any) {
        return ExploreFormDataApiFp(this.configuration).apiV1ExploreFormDataKeyDelete(key, options)(this.fetch, this.basePath);
    }

    /**
     * Retrives a form_data.
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploreFormDataApi
     */
    public apiV1ExploreFormDataKeyGet(key: string, options?: any) {
        return ExploreFormDataApiFp(this.configuration).apiV1ExploreFormDataKeyGet(key, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an existing form_data.
     * @param {FormDataPutSchema} body 
     * @param {string} key 
     * @param {number} [tabId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploreFormDataApi
     */
    public apiV1ExploreFormDataKeyPut(body: FormDataPutSchema, key: string, tabId?: number, options?: any) {
        return ExploreFormDataApiFp(this.configuration).apiV1ExploreFormDataKeyPut(body, key, tabId, options)(this.fetch, this.basePath);
    }

    /**
     * Stores a new form_data.
     * @param {FormDataPostSchema} body 
     * @param {number} [tabId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploreFormDataApi
     */
    public apiV1ExploreFormDataPost(body: FormDataPostSchema, tabId?: number, options?: any) {
        return ExploreFormDataApiFp(this.configuration).apiV1ExploreFormDataPost(body, tabId, options)(this.fetch, this.basePath);
    }

}
/**
 * ExplorePermanentLinkApi - fetch parameter creator
 * @export
 */
export const ExplorePermanentLinkApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrives chart state associated with a permanent link.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExplorePermalinkKeyGet(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling apiV1ExplorePermalinkKeyGet.');
            }
            const localVarPath = `/api/v1/explore/permalink/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stores a new permanent link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExplorePermalinkPost(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/explore/permalink`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExplorePermanentLinkApi - functional programming interface
 * @export
 */
export const ExplorePermanentLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrives chart state associated with a permanent link.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExplorePermalinkKeyGet(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20018> {
            const localVarFetchArgs = ExplorePermanentLinkApiFetchParamCreator(configuration).apiV1ExplorePermalinkKeyGet(key, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stores a new permanent link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExplorePermalinkPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2017> {
            const localVarFetchArgs = ExplorePermanentLinkApiFetchParamCreator(configuration).apiV1ExplorePermalinkPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExplorePermanentLinkApi - factory interface
 * @export
 */
export const ExplorePermanentLinkApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrives chart state associated with a permanent link.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExplorePermalinkKeyGet(key: string, options?: any) {
            return ExplorePermanentLinkApiFp(configuration).apiV1ExplorePermalinkKeyGet(key, options)(fetch, basePath);
        },
        /**
         * Stores a new permanent link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExplorePermalinkPost(options?: any) {
            return ExplorePermanentLinkApiFp(configuration).apiV1ExplorePermalinkPost(options)(fetch, basePath);
        },
    };
};

/**
 * ExplorePermanentLinkApi - object-oriented interface
 * @export
 * @class ExplorePermanentLinkApi
 * @extends {BaseAPI}
 */
export class ExplorePermanentLinkApi extends BaseAPI {
    /**
     * Retrives chart state associated with a permanent link.
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExplorePermanentLinkApi
     */
    public apiV1ExplorePermalinkKeyGet(key: string, options?: any) {
        return ExplorePermanentLinkApiFp(this.configuration).apiV1ExplorePermalinkKeyGet(key, options)(this.fetch, this.basePath);
    }

    /**
     * Stores a new permanent link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExplorePermanentLinkApi
     */
    public apiV1ExplorePermalinkPost(options?: any) {
        return ExplorePermanentLinkApiFp(this.configuration).apiV1ExplorePermalinkPost(options)(this.fetch, this.basePath);
    }

}
/**
 * FilterSetRestApiApi - fetch parameter creator
 * @export
 */
export const FilterSetRestApiApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a dashboard's list of filter sets
         * @param {number} dashboardId The id of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsGet(dashboardId: number, options: any = {}): FetchArgs {
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId','Required parameter dashboardId was null or undefined when calling apiV1DashboardDashboardIdFiltersetsGet.');
            }
            const localVarPath = `/api/v1/dashboard/{dashboard_id}/filtersets`
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Dashboard.
         * @param {number} dashboardId 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsPkDelete(dashboardId: number, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId','Required parameter dashboardId was null or undefined when calling apiV1DashboardDashboardIdFiltersetsPkDelete.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardDashboardIdFiltersetsPkDelete.');
            }
            const localVarPath = `/api/v1/dashboard/{dashboard_id}/filtersets/{pk}`
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)))
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes a Dashboard's Filter set.
         * @param {FilterSetRestApiPut} body Filter set schema
         * @param {number} dashboardId 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsPkPut(body: FilterSetRestApiPut, dashboardId: number, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DashboardDashboardIdFiltersetsPkPut.');
            }
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId','Required parameter dashboardId was null or undefined when calling apiV1DashboardDashboardIdFiltersetsPkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1DashboardDashboardIdFiltersetsPkPut.');
            }
            const localVarPath = `/api/v1/dashboard/{dashboard_id}/filtersets/{pk}`
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)))
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FilterSetRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Dashboard's Filter Set.
         * @param {FilterSetRestApiPost} body Filter set schema
         * @param {number} dashboardId The id of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsPost(body: FilterSetRestApiPost, dashboardId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DashboardDashboardIdFiltersetsPost.');
            }
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId','Required parameter dashboardId was null or undefined when calling apiV1DashboardDashboardIdFiltersetsPost.');
            }
            const localVarPath = `/api/v1/dashboard/{dashboard_id}/filtersets`
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FilterSetRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterSetRestApiApi - functional programming interface
 * @export
 */
export const FilterSetRestApiApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a dashboard's list of filter sets
         * @param {number} dashboardId The id of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsGet(dashboardId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20019>> {
            const localVarFetchArgs = FilterSetRestApiApiFetchParamCreator(configuration).apiV1DashboardDashboardIdFiltersetsGet(dashboardId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Dashboard.
         * @param {number} dashboardId 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsPkDelete(dashboardId: number, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = FilterSetRestApiApiFetchParamCreator(configuration).apiV1DashboardDashboardIdFiltersetsPkDelete(dashboardId, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Changes a Dashboard's Filter set.
         * @param {FilterSetRestApiPut} body Filter set schema
         * @param {number} dashboardId 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsPkPut(body: FilterSetRestApiPut, dashboardId: number, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = FilterSetRestApiApiFetchParamCreator(configuration).apiV1DashboardDashboardIdFiltersetsPkPut(body, dashboardId, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Dashboard's Filter Set.
         * @param {FilterSetRestApiPost} body Filter set schema
         * @param {number} dashboardId The id of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsPost(body: FilterSetRestApiPost, dashboardId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2015> {
            const localVarFetchArgs = FilterSetRestApiApiFetchParamCreator(configuration).apiV1DashboardDashboardIdFiltersetsPost(body, dashboardId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FilterSetRestApiApi - factory interface
 * @export
 */
export const FilterSetRestApiApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a dashboard's list of filter sets
         * @param {number} dashboardId The id of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsGet(dashboardId: number, options?: any) {
            return FilterSetRestApiApiFp(configuration).apiV1DashboardDashboardIdFiltersetsGet(dashboardId, options)(fetch, basePath);
        },
        /**
         * Deletes a Dashboard.
         * @param {number} dashboardId 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsPkDelete(dashboardId: number, pk: number, options?: any) {
            return FilterSetRestApiApiFp(configuration).apiV1DashboardDashboardIdFiltersetsPkDelete(dashboardId, pk, options)(fetch, basePath);
        },
        /**
         * Changes a Dashboard's Filter set.
         * @param {FilterSetRestApiPut} body Filter set schema
         * @param {number} dashboardId 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsPkPut(body: FilterSetRestApiPut, dashboardId: number, pk: number, options?: any) {
            return FilterSetRestApiApiFp(configuration).apiV1DashboardDashboardIdFiltersetsPkPut(body, dashboardId, pk, options)(fetch, basePath);
        },
        /**
         * Create a new Dashboard's Filter Set.
         * @param {FilterSetRestApiPost} body Filter set schema
         * @param {number} dashboardId The id of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardDashboardIdFiltersetsPost(body: FilterSetRestApiPost, dashboardId: number, options?: any) {
            return FilterSetRestApiApiFp(configuration).apiV1DashboardDashboardIdFiltersetsPost(body, dashboardId, options)(fetch, basePath);
        },
    };
};

/**
 * FilterSetRestApiApi - object-oriented interface
 * @export
 * @class FilterSetRestApiApi
 * @extends {BaseAPI}
 */
export class FilterSetRestApiApi extends BaseAPI {
    /**
     * Get a dashboard's list of filter sets
     * @param {number} dashboardId The id of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterSetRestApiApi
     */
    public apiV1DashboardDashboardIdFiltersetsGet(dashboardId: number, options?: any) {
        return FilterSetRestApiApiFp(this.configuration).apiV1DashboardDashboardIdFiltersetsGet(dashboardId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Dashboard.
     * @param {number} dashboardId 
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterSetRestApiApi
     */
    public apiV1DashboardDashboardIdFiltersetsPkDelete(dashboardId: number, pk: number, options?: any) {
        return FilterSetRestApiApiFp(this.configuration).apiV1DashboardDashboardIdFiltersetsPkDelete(dashboardId, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Changes a Dashboard's Filter set.
     * @param {FilterSetRestApiPut} body Filter set schema
     * @param {number} dashboardId 
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterSetRestApiApi
     */
    public apiV1DashboardDashboardIdFiltersetsPkPut(body: FilterSetRestApiPut, dashboardId: number, pk: number, options?: any) {
        return FilterSetRestApiApiFp(this.configuration).apiV1DashboardDashboardIdFiltersetsPkPut(body, dashboardId, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new Dashboard's Filter Set.
     * @param {FilterSetRestApiPost} body Filter set schema
     * @param {number} dashboardId The id of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterSetRestApiApi
     */
    public apiV1DashboardDashboardIdFiltersetsPost(body: FilterSetRestApiPost, dashboardId: number, options?: any) {
        return FilterSetRestApiApiFp(this.configuration).apiV1DashboardDashboardIdFiltersetsPost(body, dashboardId, options)(this.fetch, this.basePath);
    }

}
/**
 * ImportexportApi - fetch parameter creator
 * @export
 */
export const ImportexportApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a ZIP file with all the Superset assets (databases, datasets, charts, dashboards, saved queries) as YAML files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AssetsExportGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/assets/export/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Blob} bundle 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AssetsImportPost(bundle: Blob, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options: any = {}): FetchArgs {
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling apiV1AssetsImportPost.');
            }
            // verify required parameter 'passwords' is not null or undefined
            if (passwords === null || passwords === undefined) {
                throw new RequiredError('passwords','Required parameter passwords was null or undefined when calling apiV1AssetsImportPost.');
            }
            // verify required parameter 'sshTunnelPasswords' is not null or undefined
            if (sshTunnelPasswords === null || sshTunnelPasswords === undefined) {
                throw new RequiredError('sshTunnelPasswords','Required parameter sshTunnelPasswords was null or undefined when calling apiV1AssetsImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeyPasswords' is not null or undefined
            if (sshTunnelPrivateKeyPasswords === null || sshTunnelPrivateKeyPasswords === undefined) {
                throw new RequiredError('sshTunnelPrivateKeyPasswords','Required parameter sshTunnelPrivateKeyPasswords was null or undefined when calling apiV1AssetsImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeys' is not null or undefined
            if (sshTunnelPrivateKeys === null || sshTunnelPrivateKeys === undefined) {
                throw new RequiredError('sshTunnelPrivateKeys','Required parameter sshTunnelPrivateKeys was null or undefined when calling apiV1AssetsImportPost.');
            }
            const localVarPath = `/api/v1/assets/import/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication jwt required

            if (bundle !== undefined) {
                localVarFormParams.set('bundle', bundle as any);
            }

            if (passwords !== undefined) {
                localVarFormParams.set('passwords', passwords as any);
            }

            if (sshTunnelPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_passwords', sshTunnelPasswords as any);
            }

            if (sshTunnelPrivateKeyPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_key_passwords', sshTunnelPrivateKeyPasswords as any);
            }

            if (sshTunnelPrivateKeys !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_keys', sshTunnelPrivateKeys as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportexportApi - functional programming interface
 * @export
 */
export const ImportexportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a ZIP file with all the Superset assets (databases, datasets, charts, dashboards, saved queries) as YAML files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AssetsExportGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ImportexportApiFetchParamCreator(configuration).apiV1AssetsExportGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Blob} bundle 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AssetsImportPost(bundle: Blob, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = ImportexportApiFetchParamCreator(configuration).apiV1AssetsImportPost(bundle, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ImportexportApi - factory interface
 * @export
 */
export const ImportexportApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a ZIP file with all the Superset assets (databases, datasets, charts, dashboards, saved queries) as YAML files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AssetsExportGet(options?: any) {
            return ImportexportApiFp(configuration).apiV1AssetsExportGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {Blob} bundle 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AssetsImportPost(bundle: Blob, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any) {
            return ImportexportApiFp(configuration).apiV1AssetsImportPost(bundle, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options)(fetch, basePath);
        },
    };
};

/**
 * ImportexportApi - object-oriented interface
 * @export
 * @class ImportexportApi
 * @extends {BaseAPI}
 */
export class ImportexportApi extends BaseAPI {
    /**
     * Returns a ZIP file with all the Superset assets (databases, datasets, charts, dashboards, saved queries) as YAML files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportexportApi
     */
    public apiV1AssetsExportGet(options?: any) {
        return ImportexportApiFp(this.configuration).apiV1AssetsExportGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Blob} bundle 
     * @param {string} passwords 
     * @param {string} sshTunnelPasswords 
     * @param {string} sshTunnelPrivateKeyPasswords 
     * @param {string} sshTunnelPrivateKeys 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportexportApi
     */
    public apiV1AssetsImportPost(bundle: Blob, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any) {
        return ImportexportApiFp(this.configuration).apiV1AssetsImportPost(bundle, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options)(this.fetch, this.basePath);
    }

}
/**
 * LogRestApiApi - fetch parameter creator
 * @export
 */
export const LogRestApiApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/log/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogPkGet(pk: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1LogPkGet.');
            }
            const localVarPath = `/api/v1/log/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LogRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogPost(body: LogRestApiPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1LogPost.');
            }
            const localVarPath = `/api/v1/log/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LogRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recent activity data for a user
         * @param {number} userId The id of the user
         * @param {GetRecentActivitySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogRecentActivityUserIdGet(userId: number, q?: GetRecentActivitySchema, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling apiV1LogRecentActivityUserIdGet.');
            }
            const localVarPath = `/api/v1/log/recent_activity/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogRestApiApi - functional programming interface
 * @export
 */
export const LogRestApiApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20040> {
            const localVarFetchArgs = LogRestApiApiFetchParamCreator(configuration).apiV1LogGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogPkGet(pk: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20041> {
            const localVarFetchArgs = LogRestApiApiFetchParamCreator(configuration).apiV1LogPkGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {LogRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogPost(body: LogRestApiPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20112> {
            const localVarFetchArgs = LogRestApiApiFetchParamCreator(configuration).apiV1LogPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get recent activity data for a user
         * @param {number} userId The id of the user
         * @param {GetRecentActivitySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogRecentActivityUserIdGet(userId: number, q?: GetRecentActivitySchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecentActivityResponseSchema> {
            const localVarFetchArgs = LogRestApiApiFetchParamCreator(configuration).apiV1LogRecentActivityUserIdGet(userId, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LogRestApiApi - factory interface
 * @export
 */
export const LogRestApiApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogGet(q?: GetListSchema, options?: any) {
            return LogRestApiApiFp(configuration).apiV1LogGet(q, options)(fetch, basePath);
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogPkGet(pk: number, q?: GetItemSchema, options?: any) {
            return LogRestApiApiFp(configuration).apiV1LogPkGet(pk, q, options)(fetch, basePath);
        },
        /**
         * 
         * @param {LogRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogPost(body: LogRestApiPost, options?: any) {
            return LogRestApiApiFp(configuration).apiV1LogPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get recent activity data for a user
         * @param {number} userId The id of the user
         * @param {GetRecentActivitySchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogRecentActivityUserIdGet(userId: number, q?: GetRecentActivitySchema, options?: any) {
            return LogRestApiApiFp(configuration).apiV1LogRecentActivityUserIdGet(userId, q, options)(fetch, basePath);
        },
    };
};

/**
 * LogRestApiApi - object-oriented interface
 * @export
 * @class LogRestApiApi
 * @extends {BaseAPI}
 */
export class LogRestApiApi extends BaseAPI {
    /**
     * Get a list of models
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogRestApiApi
     */
    public apiV1LogGet(q?: GetListSchema, options?: any) {
        return LogRestApiApiFp(this.configuration).apiV1LogGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get an item model
     * @param {number} pk 
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogRestApiApi
     */
    public apiV1LogPkGet(pk: number, q?: GetItemSchema, options?: any) {
        return LogRestApiApiFp(this.configuration).apiV1LogPkGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {LogRestApiPost} body Model schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogRestApiApi
     */
    public apiV1LogPost(body: LogRestApiPost, options?: any) {
        return LogRestApiApiFp(this.configuration).apiV1LogPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get recent activity data for a user
     * @param {number} userId The id of the user
     * @param {GetRecentActivitySchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogRestApiApi
     */
    public apiV1LogRecentActivityUserIdGet(userId: number, q?: GetRecentActivitySchema, options?: any) {
        return LogRestApiApiFp(this.configuration).apiV1LogRecentActivityUserIdGet(userId, q, options)(this.fetch, this.basePath);
    }

}
/**
 * MenuApi - fetch parameter creator
 * @export
 */
export const MenuApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the menu data structure. Returns a forest like structure with the menu the user has access to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MenuGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/menu/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenuApi - functional programming interface
 * @export
 */
export const MenuApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the menu data structure. Returns a forest like structure with the menu the user has access to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MenuGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20043> {
            const localVarFetchArgs = MenuApiFetchParamCreator(configuration).apiV1MenuGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MenuApi - factory interface
 * @export
 */
export const MenuApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get the menu data structure. Returns a forest like structure with the menu the user has access to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MenuGet(options?: any) {
            return MenuApiFp(configuration).apiV1MenuGet(options)(fetch, basePath);
        },
    };
};

/**
 * MenuApi - object-oriented interface
 * @export
 * @class MenuApi
 * @extends {BaseAPI}
 */
export class MenuApi extends BaseAPI {
    /**
     * Get the menu data structure. Returns a forest like structure with the menu the user has access to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public apiV1MenuGet(options?: any) {
        return MenuApiFp(this.configuration).apiV1MenuGet(options)(this.fetch, this.basePath);
    }

}
/**
 * OpenApiApi - fetch parameter creator
 * @export
 */
export const OpenApiApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the OpenAPI spec for a specific API version
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVersionOpenapiGet(version: string, options: any = {}): FetchArgs {
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling apiVersionOpenapiGet.');
            }
            const localVarPath = `/api/{version}/_openapi`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenApiApi - functional programming interface
 * @export
 */
export const OpenApiApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the OpenAPI spec for a specific API version
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVersionOpenapiGet(version: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OpenApiApiFetchParamCreator(configuration).apiVersionOpenapiGet(version, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OpenApiApi - factory interface
 * @export
 */
export const OpenApiApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get the OpenAPI spec for a specific API version
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVersionOpenapiGet(version: string, options?: any) {
            return OpenApiApiFp(configuration).apiVersionOpenapiGet(version, options)(fetch, basePath);
        },
    };
};

/**
 * OpenApiApi - object-oriented interface
 * @export
 * @class OpenApiApi
 * @extends {BaseAPI}
 */
export class OpenApiApi extends BaseAPI {
    /**
     * Get the OpenAPI spec for a specific API version
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenApiApi
     */
    public apiVersionOpenapiGet(version: string, options?: any) {
        return OpenApiApiFp(this.configuration).apiVersionOpenapiGet(version, options)(this.fetch, this.basePath);
    }

}
/**
 * QueriesApi - fetch parameter creator
 * @export
 */
export const QueriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1QueryDistinctColumnNameGet.');
            }
            const localVarPath = `/api/v1/query/distinct/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of queries, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/query/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get query detail information.
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryPkGet(pk: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1QueryPkGet.');
            }
            const localVarPath = `/api/v1/query/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1QueryRelatedColumnNameGet.');
            }
            const localVarPath = `/api/v1/query/related/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Manually stop a query with client_id
         * @param {StopQuerySchema} body Stop query schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryStopPost(body: StopQuerySchema, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1QueryStopPost.');
            }
            const localVarPath = `/api/v1/query/stop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StopQuerySchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of queries that changed after last_updated_ms
         * @param {QueriesGetUpdatedSinceSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryUpdatedSinceGet(q?: QueriesGetUpdatedSinceSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/query/updated_since`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes multiple saved queries in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryDelete(q?: GetDeleteIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/saved_query/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1SavedQueryDistinctColumnNameGet.');
            }
            const localVarPath = `/api/v1/saved_query/distinct/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports multiple saved queries and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryExportGet(q?: GetExportIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/saved_query/export/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of saved queries, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/saved_query/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options: any = {}): FetchArgs {
            // verify required parameter 'formData' is not null or undefined
            if (formData === null || formData === undefined) {
                throw new RequiredError('formData','Required parameter formData was null or undefined when calling apiV1SavedQueryImportPost.');
            }
            // verify required parameter 'overwrite' is not null or undefined
            if (overwrite === null || overwrite === undefined) {
                throw new RequiredError('overwrite','Required parameter overwrite was null or undefined when calling apiV1SavedQueryImportPost.');
            }
            // verify required parameter 'passwords' is not null or undefined
            if (passwords === null || passwords === undefined) {
                throw new RequiredError('passwords','Required parameter passwords was null or undefined when calling apiV1SavedQueryImportPost.');
            }
            // verify required parameter 'sshTunnelPasswords' is not null or undefined
            if (sshTunnelPasswords === null || sshTunnelPasswords === undefined) {
                throw new RequiredError('sshTunnelPasswords','Required parameter sshTunnelPasswords was null or undefined when calling apiV1SavedQueryImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeyPasswords' is not null or undefined
            if (sshTunnelPrivateKeyPasswords === null || sshTunnelPrivateKeyPasswords === undefined) {
                throw new RequiredError('sshTunnelPrivateKeyPasswords','Required parameter sshTunnelPrivateKeyPasswords was null or undefined when calling apiV1SavedQueryImportPost.');
            }
            // verify required parameter 'sshTunnelPrivateKeys' is not null or undefined
            if (sshTunnelPrivateKeys === null || sshTunnelPrivateKeys === undefined) {
                throw new RequiredError('sshTunnelPrivateKeys','Required parameter sshTunnelPrivateKeys was null or undefined when calling apiV1SavedQueryImportPost.');
            }
            const localVarPath = `/api/v1/saved_query/import/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication jwt required

            if (formData !== undefined) {
                localVarFormParams.set('formData', formData as any);
            }

            if (overwrite !== undefined) {
                localVarFormParams.set('overwrite', overwrite as any);
            }

            if (passwords !== undefined) {
                localVarFormParams.set('passwords', passwords as any);
            }

            if (sshTunnelPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_passwords', sshTunnelPasswords as any);
            }

            if (sshTunnelPrivateKeyPasswords !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_key_passwords', sshTunnelPrivateKeyPasswords as any);
            }

            if (sshTunnelPrivateKeys !== undefined) {
                localVarFormParams.set('ssh_tunnel_private_keys', sshTunnelPrivateKeys as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryInfoGet(q?: GetInfoSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/saved_query/_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete saved query
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPkDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1SavedQueryPkDelete.');
            }
            const localVarPath = `/api/v1/saved_query/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a saved query
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPkGet(pk: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1SavedQueryPkGet.');
            }
            const localVarPath = `/api/v1/saved_query/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a saved query
         * @param {SavedQueryRestApiPut} body Model schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPkPut(body: SavedQueryRestApiPut, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1SavedQueryPkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1SavedQueryPkPut.');
            }
            const localVarPath = `/api/v1/saved_query/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SavedQueryRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a saved query
         * @param {SavedQueryRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPost(body: SavedQueryRestApiPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1SavedQueryPost.');
            }
            const localVarPath = `/api/v1/saved_query/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SavedQueryRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1SavedQueryRelatedColumnNameGet.');
            }
            const localVarPath = `/api/v1/saved_query/related/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueriesApi - functional programming interface
 * @export
 */
export const QueriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DistincResponseSchema> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1QueryDistinctColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of queries, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20044> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1QueryGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get query detail information.
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryPkGet(pk: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20047> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1QueryPkGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RelatedResponseSchema> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1QueryRelatedColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Manually stop a query with client_id
         * @param {StopQuerySchema} body Stop query schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryStopPost(body: StopQuerySchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20045> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1QueryStopPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of queries that changed after last_updated_ms
         * @param {QueriesGetUpdatedSinceSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryUpdatedSinceGet(q?: QueriesGetUpdatedSinceSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20046> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1QueryUpdatedSinceGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes multiple saved queries in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryDelete(q?: GetDeleteIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1SavedQueryDelete(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DistincResponseSchema> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1SavedQueryDistinctColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Exports multiple saved queries and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryExportGet(q?: GetExportIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1SavedQueryExportGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of saved queries, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20056> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1SavedQueryGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1SavedQueryImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryInfoGet(q?: GetInfoSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1SavedQueryInfoGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete saved query
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPkDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1SavedQueryPkDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a saved query
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPkGet(pk: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20057> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1SavedQueryPkGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a saved query
         * @param {SavedQueryRestApiPut} body Model schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPkPut(body: SavedQueryRestApiPut, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20058> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1SavedQueryPkPut(body, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a saved query
         * @param {SavedQueryRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPost(body: SavedQueryRestApiPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20115> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1SavedQueryPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RelatedResponseSchema> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).apiV1SavedQueryRelatedColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueriesApi - factory interface
 * @export
 */
export const QueriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1QueryDistinctColumnNameGet(columnName, q, options)(fetch, basePath);
        },
        /**
         * Get a list of queries, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryGet(q?: GetListSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1QueryGet(q, options)(fetch, basePath);
        },
        /**
         * Get query detail information.
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryPkGet(pk: number, q?: GetItemSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1QueryPkGet(pk, q, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1QueryRelatedColumnNameGet(columnName, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Manually stop a query with client_id
         * @param {StopQuerySchema} body Stop query schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryStopPost(body: StopQuerySchema, options?: any) {
            return QueriesApiFp(configuration).apiV1QueryStopPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of queries that changed after last_updated_ms
         * @param {QueriesGetUpdatedSinceSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QueryUpdatedSinceGet(q?: QueriesGetUpdatedSinceSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1QueryUpdatedSinceGet(q, options)(fetch, basePath);
        },
        /**
         * Deletes multiple saved queries in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryDelete(q?: GetDeleteIdsSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1SavedQueryDelete(q, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1SavedQueryDistinctColumnNameGet(columnName, q, options)(fetch, basePath);
        },
        /**
         * Exports multiple saved queries and downloads them as YAML files
         * @param {GetExportIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryExportGet(q?: GetExportIdsSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1SavedQueryExportGet(q, options)(fetch, basePath);
        },
        /**
         * Get a list of saved queries, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryGet(q?: GetListSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1SavedQueryGet(q, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Blob} formData 
         * @param {boolean} overwrite 
         * @param {string} passwords 
         * @param {string} sshTunnelPasswords 
         * @param {string} sshTunnelPrivateKeyPasswords 
         * @param {string} sshTunnelPrivateKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any) {
            return QueriesApiFp(configuration).apiV1SavedQueryImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options)(fetch, basePath);
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryInfoGet(q?: GetInfoSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1SavedQueryInfoGet(q, options)(fetch, basePath);
        },
        /**
         * Delete saved query
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPkDelete(pk: number, options?: any) {
            return QueriesApiFp(configuration).apiV1SavedQueryPkDelete(pk, options)(fetch, basePath);
        },
        /**
         * Get a saved query
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPkGet(pk: number, q?: GetItemSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1SavedQueryPkGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Update a saved query
         * @param {SavedQueryRestApiPut} body Model schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPkPut(body: SavedQueryRestApiPut, pk: number, options?: any) {
            return QueriesApiFp(configuration).apiV1SavedQueryPkPut(body, pk, options)(fetch, basePath);
        },
        /**
         * Create a saved query
         * @param {SavedQueryRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryPost(body: SavedQueryRestApiPost, options?: any) {
            return QueriesApiFp(configuration).apiV1SavedQueryPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SavedQueryRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return QueriesApiFp(configuration).apiV1SavedQueryRelatedColumnNameGet(columnName, q, options)(fetch, basePath);
        },
    };
};

/**
 * QueriesApi - object-oriented interface
 * @export
 * @class QueriesApi
 * @extends {BaseAPI}
 */
export class QueriesApi extends BaseAPI {
    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1QueryDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1QueryDistinctColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of queries, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1QueryGet(q?: GetListSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1QueryGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get query detail information.
     * @param {number} pk 
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1QueryPkGet(pk: number, q?: GetItemSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1QueryPkGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1QueryRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1QueryRelatedColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Manually stop a query with client_id
     * @param {StopQuerySchema} body Stop query schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1QueryStopPost(body: StopQuerySchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1QueryStopPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of queries that changed after last_updated_ms
     * @param {QueriesGetUpdatedSinceSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1QueryUpdatedSinceGet(q?: QueriesGetUpdatedSinceSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1QueryUpdatedSinceGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes multiple saved queries in a bulk operation.
     * @param {GetDeleteIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1SavedQueryDelete(q?: GetDeleteIdsSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1SavedQueryDelete(q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1SavedQueryDistinctColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1SavedQueryDistinctColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

    /**
     * Exports multiple saved queries and downloads them as YAML files
     * @param {GetExportIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1SavedQueryExportGet(q?: GetExportIdsSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1SavedQueryExportGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of saved queries, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1SavedQueryGet(q?: GetListSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1SavedQueryGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Blob} formData 
     * @param {boolean} overwrite 
     * @param {string} passwords 
     * @param {string} sshTunnelPasswords 
     * @param {string} sshTunnelPrivateKeyPasswords 
     * @param {string} sshTunnelPrivateKeys 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1SavedQueryImportPost(formData: Blob, overwrite: boolean, passwords: string, sshTunnelPasswords: string, sshTunnelPrivateKeyPasswords: string, sshTunnelPrivateKeys: string, options?: any) {
        return QueriesApiFp(this.configuration).apiV1SavedQueryImportPost(formData, overwrite, passwords, sshTunnelPasswords, sshTunnelPrivateKeyPasswords, sshTunnelPrivateKeys, options)(this.fetch, this.basePath);
    }

    /**
     * Get metadata information about this API resource
     * @param {GetInfoSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1SavedQueryInfoGet(q?: GetInfoSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1SavedQueryInfoGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Delete saved query
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1SavedQueryPkDelete(pk: number, options?: any) {
        return QueriesApiFp(this.configuration).apiV1SavedQueryPkDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get a saved query
     * @param {number} pk 
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1SavedQueryPkGet(pk: number, q?: GetItemSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1SavedQueryPkGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Update a saved query
     * @param {SavedQueryRestApiPut} body Model schema
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1SavedQueryPkPut(body: SavedQueryRestApiPut, pk: number, options?: any) {
        return QueriesApiFp(this.configuration).apiV1SavedQueryPkPut(body, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Create a saved query
     * @param {SavedQueryRestApiPost} body Model schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1SavedQueryPost(body: SavedQueryRestApiPost, options?: any) {
        return QueriesApiFp(this.configuration).apiV1SavedQueryPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public apiV1SavedQueryRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return QueriesApiFp(this.configuration).apiV1SavedQueryRelatedColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

}
/**
 * ReportSchedulesApi - fetch parameter creator
 * @export
 */
export const ReportSchedulesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes multiple report schedules in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportDelete(q?: GetDeleteIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/report/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of report schedules, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/report/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportInfoGet(q?: GetInfoSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/report/_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a report schedule
         * @param {number} pk The report schedule pk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ReportPkDelete.');
            }
            const localVarPath = `/api/v1/report/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a report schedule
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkGet(pk: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ReportPkGet.');
            }
            const localVarPath = `/api/v1/report/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of report schedule logs, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {number} pk The report schedule id for these logs
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkLogGet(pk: number, q?: GetListSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ReportPkLogGet.');
            }
            const localVarPath = `/api/v1/report/{pk}/log/`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a report schedule log
         * @param {number} pk The report schedule pk for log
         * @param {number} logId The log pk
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkLogLogIdGet(pk: number, logId: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ReportPkLogLogIdGet.');
            }
            // verify required parameter 'logId' is not null or undefined
            if (logId === null || logId === undefined) {
                throw new RequiredError('logId','Required parameter logId was null or undefined when calling apiV1ReportPkLogLogIdGet.');
            }
            const localVarPath = `/api/v1/report/{pk}/log/{log_id}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"log_id"}}`, encodeURIComponent(String(logId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a report schedule
         * @param {ReportScheduleRestApiPut} body Report Schedule schema
         * @param {number} pk The Report Schedule pk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkPut(body: ReportScheduleRestApiPut, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1ReportPkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1ReportPkPut.');
            }
            const localVarPath = `/api/v1/report/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReportScheduleRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a report schedule
         * @param {ReportScheduleRestApiPost} body Report Schedule schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPost(body: ReportScheduleRestApiPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1ReportPost.');
            }
            const localVarPath = `/api/v1/report/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReportScheduleRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1ReportRelatedColumnNameGet.');
            }
            const localVarPath = `/api/v1/report/related/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportSchedulesApi - functional programming interface
 * @export
 */
export const ReportSchedulesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes multiple report schedules in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportDelete(q?: GetDeleteIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = ReportSchedulesApiFetchParamCreator(configuration).apiV1ReportDelete(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of report schedules, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20048> {
            const localVarFetchArgs = ReportSchedulesApiFetchParamCreator(configuration).apiV1ReportGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportInfoGet(q?: GetInfoSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ReportSchedulesApiFetchParamCreator(configuration).apiV1ReportInfoGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a report schedule
         * @param {number} pk The report schedule pk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = ReportSchedulesApiFetchParamCreator(configuration).apiV1ReportPkDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a report schedule
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkGet(pk: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20049> {
            const localVarFetchArgs = ReportSchedulesApiFetchParamCreator(configuration).apiV1ReportPkGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of report schedule logs, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {number} pk The report schedule id for these logs
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkLogGet(pk: number, q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20051> {
            const localVarFetchArgs = ReportSchedulesApiFetchParamCreator(configuration).apiV1ReportPkLogGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a report schedule log
         * @param {number} pk The report schedule pk for log
         * @param {number} logId The log pk
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkLogLogIdGet(pk: number, logId: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20052> {
            const localVarFetchArgs = ReportSchedulesApiFetchParamCreator(configuration).apiV1ReportPkLogLogIdGet(pk, logId, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a report schedule
         * @param {ReportScheduleRestApiPut} body Report Schedule schema
         * @param {number} pk The Report Schedule pk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkPut(body: ReportScheduleRestApiPut, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20050> {
            const localVarFetchArgs = ReportSchedulesApiFetchParamCreator(configuration).apiV1ReportPkPut(body, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a report schedule
         * @param {ReportScheduleRestApiPost} body Report Schedule schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPost(body: ReportScheduleRestApiPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20113> {
            const localVarFetchArgs = ReportSchedulesApiFetchParamCreator(configuration).apiV1ReportPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RelatedResponseSchema> {
            const localVarFetchArgs = ReportSchedulesApiFetchParamCreator(configuration).apiV1ReportRelatedColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ReportSchedulesApi - factory interface
 * @export
 */
export const ReportSchedulesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes multiple report schedules in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportDelete(q?: GetDeleteIdsSchema, options?: any) {
            return ReportSchedulesApiFp(configuration).apiV1ReportDelete(q, options)(fetch, basePath);
        },
        /**
         * Get a list of report schedules, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportGet(q?: GetListSchema, options?: any) {
            return ReportSchedulesApiFp(configuration).apiV1ReportGet(q, options)(fetch, basePath);
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportInfoGet(q?: GetInfoSchema, options?: any) {
            return ReportSchedulesApiFp(configuration).apiV1ReportInfoGet(q, options)(fetch, basePath);
        },
        /**
         * Delete a report schedule
         * @param {number} pk The report schedule pk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkDelete(pk: number, options?: any) {
            return ReportSchedulesApiFp(configuration).apiV1ReportPkDelete(pk, options)(fetch, basePath);
        },
        /**
         * Get a report schedule
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkGet(pk: number, q?: GetItemSchema, options?: any) {
            return ReportSchedulesApiFp(configuration).apiV1ReportPkGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Get a list of report schedule logs, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
         * @param {number} pk The report schedule id for these logs
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkLogGet(pk: number, q?: GetListSchema, options?: any) {
            return ReportSchedulesApiFp(configuration).apiV1ReportPkLogGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Get a report schedule log
         * @param {number} pk The report schedule pk for log
         * @param {number} logId The log pk
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkLogLogIdGet(pk: number, logId: number, q?: GetItemSchema, options?: any) {
            return ReportSchedulesApiFp(configuration).apiV1ReportPkLogLogIdGet(pk, logId, q, options)(fetch, basePath);
        },
        /**
         * Update a report schedule
         * @param {ReportScheduleRestApiPut} body Report Schedule schema
         * @param {number} pk The Report Schedule pk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPkPut(body: ReportScheduleRestApiPut, pk: number, options?: any) {
            return ReportSchedulesApiFp(configuration).apiV1ReportPkPut(body, pk, options)(fetch, basePath);
        },
        /**
         * Create a report schedule
         * @param {ReportScheduleRestApiPost} body Report Schedule schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportPost(body: ReportScheduleRestApiPost, options?: any) {
            return ReportSchedulesApiFp(configuration).apiV1ReportPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return ReportSchedulesApiFp(configuration).apiV1ReportRelatedColumnNameGet(columnName, q, options)(fetch, basePath);
        },
    };
};

/**
 * ReportSchedulesApi - object-oriented interface
 * @export
 * @class ReportSchedulesApi
 * @extends {BaseAPI}
 */
export class ReportSchedulesApi extends BaseAPI {
    /**
     * Deletes multiple report schedules in a bulk operation.
     * @param {GetDeleteIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportSchedulesApi
     */
    public apiV1ReportDelete(q?: GetDeleteIdsSchema, options?: any) {
        return ReportSchedulesApiFp(this.configuration).apiV1ReportDelete(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of report schedules, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportSchedulesApi
     */
    public apiV1ReportGet(q?: GetListSchema, options?: any) {
        return ReportSchedulesApiFp(this.configuration).apiV1ReportGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get metadata information about this API resource
     * @param {GetInfoSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportSchedulesApi
     */
    public apiV1ReportInfoGet(q?: GetInfoSchema, options?: any) {
        return ReportSchedulesApiFp(this.configuration).apiV1ReportInfoGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a report schedule
     * @param {number} pk The report schedule pk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportSchedulesApi
     */
    public apiV1ReportPkDelete(pk: number, options?: any) {
        return ReportSchedulesApiFp(this.configuration).apiV1ReportPkDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get a report schedule
     * @param {number} pk 
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportSchedulesApi
     */
    public apiV1ReportPkGet(pk: number, q?: GetItemSchema, options?: any) {
        return ReportSchedulesApiFp(this.configuration).apiV1ReportPkGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of report schedule logs, use Rison or JSON query parameters for filtering, sorting, pagination and for selecting specific columns and metadata.
     * @param {number} pk The report schedule id for these logs
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportSchedulesApi
     */
    public apiV1ReportPkLogGet(pk: number, q?: GetListSchema, options?: any) {
        return ReportSchedulesApiFp(this.configuration).apiV1ReportPkLogGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a report schedule log
     * @param {number} pk The report schedule pk for log
     * @param {number} logId The log pk
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportSchedulesApi
     */
    public apiV1ReportPkLogLogIdGet(pk: number, logId: number, q?: GetItemSchema, options?: any) {
        return ReportSchedulesApiFp(this.configuration).apiV1ReportPkLogLogIdGet(pk, logId, q, options)(this.fetch, this.basePath);
    }

    /**
     * Update a report schedule
     * @param {ReportScheduleRestApiPut} body Report Schedule schema
     * @param {number} pk The Report Schedule pk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportSchedulesApi
     */
    public apiV1ReportPkPut(body: ReportScheduleRestApiPut, pk: number, options?: any) {
        return ReportSchedulesApiFp(this.configuration).apiV1ReportPkPut(body, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Create a report schedule
     * @param {ReportScheduleRestApiPost} body Report Schedule schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportSchedulesApi
     */
    public apiV1ReportPost(body: ReportScheduleRestApiPost, options?: any) {
        return ReportSchedulesApiFp(this.configuration).apiV1ReportPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportSchedulesApi
     */
    public apiV1ReportRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return ReportSchedulesApiFp(this.configuration).apiV1ReportRelatedColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

}
/**
 * RowLevelSecurityApi - fetch parameter creator
 * @export
 */
export const RowLevelSecurityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes multiple RLS rules in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityDelete(q?: GetDeleteIdsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/rowlevelsecurity/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/rowlevelsecurity/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityInfoGet(q?: GetInfoSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/rowlevelsecurity/_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPkDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1RowlevelsecurityPkDelete.');
            }
            const localVarPath = `/api/v1/rowlevelsecurity/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPkGet(pk: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1RowlevelsecurityPkGet.');
            }
            const localVarPath = `/api/v1/rowlevelsecurity/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an RLS Rule
         * @param {RLSRestApiPut} body RLS schema
         * @param {number} pk The Rule pk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPkPut(body: RLSRestApiPut, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1RowlevelsecurityPkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1RowlevelsecurityPkPut.');
            }
            const localVarPath = `/api/v1/rowlevelsecurity/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RLSRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new RLS Rule
         * @param {RLSRestApiPost} body RLS schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPost(body: RLSRestApiPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1RowlevelsecurityPost.');
            }
            const localVarPath = `/api/v1/rowlevelsecurity/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RLSRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1RowlevelsecurityRelatedColumnNameGet.');
            }
            const localVarPath = `/api/v1/rowlevelsecurity/related/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RowLevelSecurityApi - functional programming interface
 * @export
 */
export const RowLevelSecurityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes multiple RLS rules in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityDelete(q?: GetDeleteIdsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = RowLevelSecurityApiFetchParamCreator(configuration).apiV1RowlevelsecurityDelete(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20053> {
            const localVarFetchArgs = RowLevelSecurityApiFetchParamCreator(configuration).apiV1RowlevelsecurityGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityInfoGet(q?: GetInfoSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = RowLevelSecurityApiFetchParamCreator(configuration).apiV1RowlevelsecurityInfoGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPkDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = RowLevelSecurityApiFetchParamCreator(configuration).apiV1RowlevelsecurityPkDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPkGet(pk: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20054> {
            const localVarFetchArgs = RowLevelSecurityApiFetchParamCreator(configuration).apiV1RowlevelsecurityPkGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an RLS Rule
         * @param {RLSRestApiPut} body RLS schema
         * @param {number} pk The Rule pk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPkPut(body: RLSRestApiPut, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20055> {
            const localVarFetchArgs = RowLevelSecurityApiFetchParamCreator(configuration).apiV1RowlevelsecurityPkPut(body, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new RLS Rule
         * @param {RLSRestApiPost} body RLS schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPost(body: RLSRestApiPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20114> {
            const localVarFetchArgs = RowLevelSecurityApiFetchParamCreator(configuration).apiV1RowlevelsecurityPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RelatedResponseSchema> {
            const localVarFetchArgs = RowLevelSecurityApiFetchParamCreator(configuration).apiV1RowlevelsecurityRelatedColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RowLevelSecurityApi - factory interface
 * @export
 */
export const RowLevelSecurityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes multiple RLS rules in a bulk operation.
         * @param {GetDeleteIdsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityDelete(q?: GetDeleteIdsSchema, options?: any) {
            return RowLevelSecurityApiFp(configuration).apiV1RowlevelsecurityDelete(q, options)(fetch, basePath);
        },
        /**
         * Get a list of models
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityGet(q?: GetListSchema, options?: any) {
            return RowLevelSecurityApiFp(configuration).apiV1RowlevelsecurityGet(q, options)(fetch, basePath);
        },
        /**
         * Get metadata information about this API resource
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityInfoGet(q?: GetInfoSchema, options?: any) {
            return RowLevelSecurityApiFp(configuration).apiV1RowlevelsecurityInfoGet(q, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPkDelete(pk: number, options?: any) {
            return RowLevelSecurityApiFp(configuration).apiV1RowlevelsecurityPkDelete(pk, options)(fetch, basePath);
        },
        /**
         * Get an item model
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPkGet(pk: number, q?: GetItemSchema, options?: any) {
            return RowLevelSecurityApiFp(configuration).apiV1RowlevelsecurityPkGet(pk, q, options)(fetch, basePath);
        },
        /**
         * Updates an RLS Rule
         * @param {RLSRestApiPut} body RLS schema
         * @param {number} pk The Rule pk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPkPut(body: RLSRestApiPut, pk: number, options?: any) {
            return RowLevelSecurityApiFp(configuration).apiV1RowlevelsecurityPkPut(body, pk, options)(fetch, basePath);
        },
        /**
         * Create a new RLS Rule
         * @param {RLSRestApiPost} body RLS schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityPost(body: RLSRestApiPost, options?: any) {
            return RowLevelSecurityApiFp(configuration).apiV1RowlevelsecurityPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RowlevelsecurityRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return RowLevelSecurityApiFp(configuration).apiV1RowlevelsecurityRelatedColumnNameGet(columnName, q, options)(fetch, basePath);
        },
    };
};

/**
 * RowLevelSecurityApi - object-oriented interface
 * @export
 * @class RowLevelSecurityApi
 * @extends {BaseAPI}
 */
export class RowLevelSecurityApi extends BaseAPI {
    /**
     * Deletes multiple RLS rules in a bulk operation.
     * @param {GetDeleteIdsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RowLevelSecurityApi
     */
    public apiV1RowlevelsecurityDelete(q?: GetDeleteIdsSchema, options?: any) {
        return RowLevelSecurityApiFp(this.configuration).apiV1RowlevelsecurityDelete(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of models
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RowLevelSecurityApi
     */
    public apiV1RowlevelsecurityGet(q?: GetListSchema, options?: any) {
        return RowLevelSecurityApiFp(this.configuration).apiV1RowlevelsecurityGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get metadata information about this API resource
     * @param {GetInfoSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RowLevelSecurityApi
     */
    public apiV1RowlevelsecurityInfoGet(q?: GetInfoSchema, options?: any) {
        return RowLevelSecurityApiFp(this.configuration).apiV1RowlevelsecurityInfoGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RowLevelSecurityApi
     */
    public apiV1RowlevelsecurityPkDelete(pk: number, options?: any) {
        return RowLevelSecurityApiFp(this.configuration).apiV1RowlevelsecurityPkDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get an item model
     * @param {number} pk 
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RowLevelSecurityApi
     */
    public apiV1RowlevelsecurityPkGet(pk: number, q?: GetItemSchema, options?: any) {
        return RowLevelSecurityApiFp(this.configuration).apiV1RowlevelsecurityPkGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an RLS Rule
     * @param {RLSRestApiPut} body RLS schema
     * @param {number} pk The Rule pk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RowLevelSecurityApi
     */
    public apiV1RowlevelsecurityPkPut(body: RLSRestApiPut, pk: number, options?: any) {
        return RowLevelSecurityApiFp(this.configuration).apiV1RowlevelsecurityPkPut(body, pk, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new RLS Rule
     * @param {RLSRestApiPost} body RLS schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RowLevelSecurityApi
     */
    public apiV1RowlevelsecurityPost(body: RLSRestApiPost, options?: any) {
        return RowLevelSecurityApiFp(this.configuration).apiV1RowlevelsecurityPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RowLevelSecurityApi
     */
    public apiV1RowlevelsecurityRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return RowLevelSecurityApiFp(this.configuration).apiV1RowlevelsecurityRelatedColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

}
/**
 * SQLLabApi - fetch parameter creator
 * @export
 */
export const SQLLabApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Estimates the SQL query execution cost
         * @param {EstimateQueryCostSchema} body SQL query and params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabEstimatePost(body: EstimateQueryCostSchema, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1SqllabEstimatePost.');
            }
            const localVarPath = `/api/v1/sqllab/estimate/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EstimateQueryCostSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the execution of a SQL query
         * @param {ExecutePayloadSchema} body SQL query and params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabExecutePost(body: ExecutePayloadSchema, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1SqllabExecutePost.');
            }
            const localVarPath = `/api/v1/sqllab/execute/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecutePayloadSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Exports the SQL query results to a CSV
         * @param {number} clientId The SQL query result identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabExportClientIdGet(clientId: number, options: any = {}): FetchArgs {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling apiV1SqllabExportClientIdGet.');
            }
            const localVarPath = `/api/v1/sqllab/export/{client_id}/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the result of a SQL query execution
         * @param {SqlLabGetResultsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabResultsGet(q?: SqlLabGetResultsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/sqllab/results/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SQLLabApi - functional programming interface
 * @export
 */
export const SQLLabApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Estimates the SQL query execution cost
         * @param {EstimateQueryCostSchema} body SQL query and params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabEstimatePost(body: EstimateQueryCostSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = SQLLabApiFetchParamCreator(configuration).apiV1SqllabEstimatePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Starts the execution of a SQL query
         * @param {ExecutePayloadSchema} body SQL query and params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabExecutePost(body: ExecutePayloadSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryExecutionResponseSchema> {
            const localVarFetchArgs = SQLLabApiFetchParamCreator(configuration).apiV1SqllabExecutePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Exports the SQL query results to a CSV
         * @param {number} clientId The SQL query result identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabExportClientIdGet(clientId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SQLLabApiFetchParamCreator(configuration).apiV1SqllabExportClientIdGet(clientId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the result of a SQL query execution
         * @param {SqlLabGetResultsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabResultsGet(q?: SqlLabGetResultsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryExecutionResponseSchema> {
            const localVarFetchArgs = SQLLabApiFetchParamCreator(configuration).apiV1SqllabResultsGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SQLLabApi - factory interface
 * @export
 */
export const SQLLabApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Estimates the SQL query execution cost
         * @param {EstimateQueryCostSchema} body SQL query and params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabEstimatePost(body: EstimateQueryCostSchema, options?: any) {
            return SQLLabApiFp(configuration).apiV1SqllabEstimatePost(body, options)(fetch, basePath);
        },
        /**
         * Starts the execution of a SQL query
         * @param {ExecutePayloadSchema} body SQL query and params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabExecutePost(body: ExecutePayloadSchema, options?: any) {
            return SQLLabApiFp(configuration).apiV1SqllabExecutePost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Exports the SQL query results to a CSV
         * @param {number} clientId The SQL query result identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabExportClientIdGet(clientId: number, options?: any) {
            return SQLLabApiFp(configuration).apiV1SqllabExportClientIdGet(clientId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the result of a SQL query execution
         * @param {SqlLabGetResultsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SqllabResultsGet(q?: SqlLabGetResultsSchema, options?: any) {
            return SQLLabApiFp(configuration).apiV1SqllabResultsGet(q, options)(fetch, basePath);
        },
    };
};

/**
 * SQLLabApi - object-oriented interface
 * @export
 * @class SQLLabApi
 * @extends {BaseAPI}
 */
export class SQLLabApi extends BaseAPI {
    /**
     * 
     * @summary Estimates the SQL query execution cost
     * @param {EstimateQueryCostSchema} body SQL query and params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SQLLabApi
     */
    public apiV1SqllabEstimatePost(body: EstimateQueryCostSchema, options?: any) {
        return SQLLabApiFp(this.configuration).apiV1SqllabEstimatePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Starts the execution of a SQL query
     * @param {ExecutePayloadSchema} body SQL query and params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SQLLabApi
     */
    public apiV1SqllabExecutePost(body: ExecutePayloadSchema, options?: any) {
        return SQLLabApiFp(this.configuration).apiV1SqllabExecutePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Exports the SQL query results to a CSV
     * @param {number} clientId The SQL query result identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SQLLabApi
     */
    public apiV1SqllabExportClientIdGet(clientId: number, options?: any) {
        return SQLLabApiFp(this.configuration).apiV1SqllabExportClientIdGet(clientId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the result of a SQL query execution
     * @param {SqlLabGetResultsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SQLLabApi
     */
    public apiV1SqllabResultsGet(q?: SqlLabGetResultsSchema, options?: any) {
        return SQLLabApiFp(this.configuration).apiV1SqllabResultsGet(q, options)(this.fetch, this.basePath);
    }

}
/**
 * SecurityApi - fetch parameter creator
 * @export
 */
export const SecurityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch the CSRF token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityCsrfTokenGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/security/csrf_token/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a guest token
         * @param {GuestTokenCreate} body Parameters for the guest token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityGuestTokenPost(body: GuestTokenCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1SecurityGuestTokenPost.');
            }
            const localVarPath = `/api/v1/security/guest_token/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GuestTokenCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate and get a JWT access and refresh token
         * @param {SecurityLoginBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityLoginPost(body: SecurityLoginBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1SecurityLoginPost.');
            }
            const localVarPath = `/api/v1/security/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SecurityLoginBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use the refresh token to get a new JWT access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityRefreshPost(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/security/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt_refresh required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetch the CSRF token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityCsrfTokenGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20045> {
            const localVarFetchArgs = SecurityApiFetchParamCreator(configuration).apiV1SecurityCsrfTokenGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a guest token
         * @param {GuestTokenCreate} body Parameters for the guest token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityGuestTokenPost(body: GuestTokenCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20059> {
            const localVarFetchArgs = SecurityApiFetchParamCreator(configuration).apiV1SecurityGuestTokenPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authenticate and get a JWT access and refresh token
         * @param {SecurityLoginBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityLoginPost(body: SecurityLoginBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20060> {
            const localVarFetchArgs = SecurityApiFetchParamCreator(configuration).apiV1SecurityLoginPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use the refresh token to get a new JWT access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityRefreshPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20061> {
            const localVarFetchArgs = SecurityApiFetchParamCreator(configuration).apiV1SecurityRefreshPost(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetch the CSRF token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityCsrfTokenGet(options?: any) {
            return SecurityApiFp(configuration).apiV1SecurityCsrfTokenGet(options)(fetch, basePath);
        },
        /**
         * Fetches a guest token
         * @param {GuestTokenCreate} body Parameters for the guest token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityGuestTokenPost(body: GuestTokenCreate, options?: any) {
            return SecurityApiFp(configuration).apiV1SecurityGuestTokenPost(body, options)(fetch, basePath);
        },
        /**
         * Authenticate and get a JWT access and refresh token
         * @param {SecurityLoginBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityLoginPost(body: SecurityLoginBody, options?: any) {
            return SecurityApiFp(configuration).apiV1SecurityLoginPost(body, options)(fetch, basePath);
        },
        /**
         * Use the refresh token to get a new JWT access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecurityRefreshPost(options?: any) {
            return SecurityApiFp(configuration).apiV1SecurityRefreshPost(options)(fetch, basePath);
        },
    };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * Fetch the CSRF token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public apiV1SecurityCsrfTokenGet(options?: any) {
        return SecurityApiFp(this.configuration).apiV1SecurityCsrfTokenGet(options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a guest token
     * @param {GuestTokenCreate} body Parameters for the guest token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public apiV1SecurityGuestTokenPost(body: GuestTokenCreate, options?: any) {
        return SecurityApiFp(this.configuration).apiV1SecurityGuestTokenPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Authenticate and get a JWT access and refresh token
     * @param {SecurityLoginBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public apiV1SecurityLoginPost(body: SecurityLoginBody, options?: any) {
        return SecurityApiFp(this.configuration).apiV1SecurityLoginPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Use the refresh token to get a new JWT access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public apiV1SecurityRefreshPost(options?: any) {
        return SecurityApiFp(this.configuration).apiV1SecurityRefreshPost(options)(this.fetch, this.basePath);
    }

}
/**
 * TagsApi - fetch parameter creator
 * @export
 */
export const TagsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes multiple Tags. This will remove all tagged objects with this tag
         * @param {DeleteTagsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagDelete(q?: DeleteTagsSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/tag/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of tags, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagGet(q?: GetListSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/tag/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all objects associated with a Tag.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagGetObjectsGet(tagId: number, options: any = {}): FetchArgs {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling apiV1TagGetObjectsGet.');
            }
            const localVarPath = `/api/v1/tag/get_objects/`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Several metadata information about tag API endpoints.
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagInfoGet(q?: GetInfoSchema, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/tag/_info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add tags to an object..
         * @param {ObjectTypeObjectIdBody} body Tag schema
         * @param {number} objectType 
         * @param {number} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagObjectTypeObjectIdPost(body: ObjectTypeObjectIdBody, objectType: number, objectId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1TagObjectTypeObjectIdPost.');
            }
            // verify required parameter 'objectType' is not null or undefined
            if (objectType === null || objectType === undefined) {
                throw new RequiredError('objectType','Required parameter objectType was null or undefined when calling apiV1TagObjectTypeObjectIdPost.');
            }
            // verify required parameter 'objectId' is not null or undefined
            if (objectId === null || objectId === undefined) {
                throw new RequiredError('objectId','Required parameter objectId was null or undefined when calling apiV1TagObjectTypeObjectIdPost.');
            }
            const localVarPath = `/api/v1/tag/{object_type}/{object_id}/`
                .replace(`{${"object_type"}}`, encodeURIComponent(String(objectType)))
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ObjectTypeObjectIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Tagged Object.
         * @param {string} tag 
         * @param {number} objectType 
         * @param {number} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagObjectTypeObjectIdTagDelete(tag: string, objectType: number, objectId: number, options: any = {}): FetchArgs {
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling apiV1TagObjectTypeObjectIdTagDelete.');
            }
            // verify required parameter 'objectType' is not null or undefined
            if (objectType === null || objectType === undefined) {
                throw new RequiredError('objectType','Required parameter objectType was null or undefined when calling apiV1TagObjectTypeObjectIdTagDelete.');
            }
            // verify required parameter 'objectId' is not null or undefined
            if (objectId === null || objectId === undefined) {
                throw new RequiredError('objectId','Required parameter objectId was null or undefined when calling apiV1TagObjectTypeObjectIdTagDelete.');
            }
            const localVarPath = `/api/v1/tag/{object_type}/{object_id}/{tag}/`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"object_type"}}`, encodeURIComponent(String(objectType)))
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPkDelete(pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1TagPkDelete.');
            }
            const localVarPath = `/api/v1/tag/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a tag detail information.
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPkGet(pk: number, q?: GetItemSchema, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1TagPkGet.');
            }
            const localVarPath = `/api/v1/tag/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TagRestApiPut} body Model schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPkPut(body: TagRestApiPut, pk: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1TagPkPut.');
            }
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling apiV1TagPkPut.');
            }
            const localVarPath = `/api/v1/tag/{pk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TagRestApiPut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TagRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPost(body: TagRestApiPost, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1TagPost.');
            }
            const localVarPath = `/api/v1/tag/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TagRestApiPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options: any = {}): FetchArgs {
            // verify required parameter 'columnName' is not null or undefined
            if (columnName === null || columnName === undefined) {
                throw new RequiredError('columnName','Required parameter columnName was null or undefined when calling apiV1TagRelatedColumnNameGet.');
            }
            const localVarPath = `/api/v1/tag/related/{column_name}`
                .replace(`{${"column_name"}}`, encodeURIComponent(String(columnName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes multiple Tags. This will remove all tagged objects with this tag
         * @param {DeleteTagsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagDelete(q?: DeleteTagsSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiV1TagDelete(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of tags, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagGet(q?: GetListSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20062> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiV1TagGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets all objects associated with a Tag.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagGetObjectsGet(tagId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20063> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiV1TagGetObjectsGet(tagId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Several metadata information about tag API endpoints.
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagInfoGet(q?: GetInfoSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiV1TagInfoGet(q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add tags to an object..
         * @param {ObjectTypeObjectIdBody} body Tag schema
         * @param {number} objectType 
         * @param {number} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagObjectTypeObjectIdPost(body: ObjectTypeObjectIdBody, objectType: number, objectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiV1TagObjectTypeObjectIdPost(body, objectType, objectId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Tagged Object.
         * @param {string} tag 
         * @param {number} objectType 
         * @param {number} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagObjectTypeObjectIdTagDelete(tag: string, objectType: number, objectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiV1TagObjectTypeObjectIdTagDelete(tag, objectType, objectId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPkDelete(pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse400> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiV1TagPkDelete(pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a tag detail information.
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPkGet(pk: number, q?: GetItemSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20064> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiV1TagPkGet(pk, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TagRestApiPut} body Model schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPkPut(body: TagRestApiPut, pk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20065> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiV1TagPkPut(body, pk, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {TagRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPost(body: TagRestApiPost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20116> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiV1TagPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RelatedResponseSchema> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).apiV1TagRelatedColumnNameGet(columnName, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes multiple Tags. This will remove all tagged objects with this tag
         * @param {DeleteTagsSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagDelete(q?: DeleteTagsSchema, options?: any) {
            return TagsApiFp(configuration).apiV1TagDelete(q, options)(fetch, basePath);
        },
        /**
         * Get a list of tags, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
         * @param {GetListSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagGet(q?: GetListSchema, options?: any) {
            return TagsApiFp(configuration).apiV1TagGet(q, options)(fetch, basePath);
        },
        /**
         * Gets all objects associated with a Tag.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagGetObjectsGet(tagId: number, options?: any) {
            return TagsApiFp(configuration).apiV1TagGetObjectsGet(tagId, options)(fetch, basePath);
        },
        /**
         * Several metadata information about tag API endpoints.
         * @param {GetInfoSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagInfoGet(q?: GetInfoSchema, options?: any) {
            return TagsApiFp(configuration).apiV1TagInfoGet(q, options)(fetch, basePath);
        },
        /**
         * Add tags to an object..
         * @param {ObjectTypeObjectIdBody} body Tag schema
         * @param {number} objectType 
         * @param {number} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagObjectTypeObjectIdPost(body: ObjectTypeObjectIdBody, objectType: number, objectId: number, options?: any) {
            return TagsApiFp(configuration).apiV1TagObjectTypeObjectIdPost(body, objectType, objectId, options)(fetch, basePath);
        },
        /**
         * Deletes a Tagged Object.
         * @param {string} tag 
         * @param {number} objectType 
         * @param {number} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagObjectTypeObjectIdTagDelete(tag: string, objectType: number, objectId: number, options?: any) {
            return TagsApiFp(configuration).apiV1TagObjectTypeObjectIdTagDelete(tag, objectType, objectId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPkDelete(pk: number, options?: any) {
            return TagsApiFp(configuration).apiV1TagPkDelete(pk, options)(fetch, basePath);
        },
        /**
         * Get a tag detail information.
         * @param {number} pk 
         * @param {GetItemSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPkGet(pk: number, q?: GetItemSchema, options?: any) {
            return TagsApiFp(configuration).apiV1TagPkGet(pk, q, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TagRestApiPut} body Model schema
         * @param {number} pk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPkPut(body: TagRestApiPut, pk: number, options?: any) {
            return TagsApiFp(configuration).apiV1TagPkPut(body, pk, options)(fetch, basePath);
        },
        /**
         * 
         * @param {TagRestApiPost} body Model schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagPost(body: TagRestApiPost, options?: any) {
            return TagsApiFp(configuration).apiV1TagPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} columnName 
         * @param {GetRelatedSchema} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TagRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
            return TagsApiFp(configuration).apiV1TagRelatedColumnNameGet(columnName, q, options)(fetch, basePath);
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Deletes multiple Tags. This will remove all tagged objects with this tag
     * @param {DeleteTagsSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiV1TagDelete(q?: DeleteTagsSchema, options?: any) {
        return TagsApiFp(this.configuration).apiV1TagDelete(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of tags, use Rison or JSON query parameters for filtering, sorting, pagination and  for selecting specific columns and metadata.
     * @param {GetListSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiV1TagGet(q?: GetListSchema, options?: any) {
        return TagsApiFp(this.configuration).apiV1TagGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Gets all objects associated with a Tag.
     * @param {number} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiV1TagGetObjectsGet(tagId: number, options?: any) {
        return TagsApiFp(this.configuration).apiV1TagGetObjectsGet(tagId, options)(this.fetch, this.basePath);
    }

    /**
     * Several metadata information about tag API endpoints.
     * @param {GetInfoSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiV1TagInfoGet(q?: GetInfoSchema, options?: any) {
        return TagsApiFp(this.configuration).apiV1TagInfoGet(q, options)(this.fetch, this.basePath);
    }

    /**
     * Add tags to an object..
     * @param {ObjectTypeObjectIdBody} body Tag schema
     * @param {number} objectType 
     * @param {number} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiV1TagObjectTypeObjectIdPost(body: ObjectTypeObjectIdBody, objectType: number, objectId: number, options?: any) {
        return TagsApiFp(this.configuration).apiV1TagObjectTypeObjectIdPost(body, objectType, objectId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Tagged Object.
     * @param {string} tag 
     * @param {number} objectType 
     * @param {number} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiV1TagObjectTypeObjectIdTagDelete(tag: string, objectType: number, objectId: number, options?: any) {
        return TagsApiFp(this.configuration).apiV1TagObjectTypeObjectIdTagDelete(tag, objectType, objectId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiV1TagPkDelete(pk: number, options?: any) {
        return TagsApiFp(this.configuration).apiV1TagPkDelete(pk, options)(this.fetch, this.basePath);
    }

    /**
     * Get a tag detail information.
     * @param {number} pk 
     * @param {GetItemSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiV1TagPkGet(pk: number, q?: GetItemSchema, options?: any) {
        return TagsApiFp(this.configuration).apiV1TagPkGet(pk, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TagRestApiPut} body Model schema
     * @param {number} pk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiV1TagPkPut(body: TagRestApiPut, pk: number, options?: any) {
        return TagsApiFp(this.configuration).apiV1TagPkPut(body, pk, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {TagRestApiPost} body Model schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiV1TagPost(body: TagRestApiPost, options?: any) {
        return TagsApiFp(this.configuration).apiV1TagPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} columnName 
     * @param {GetRelatedSchema} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiV1TagRelatedColumnNameGet(columnName: string, q?: GetRelatedSchema, options?: any) {
        return TagsApiFp(this.configuration).apiV1TagRelatedColumnNameGet(columnName, q, options)(this.fetch, this.basePath);
    }

}
